{"componentChunkName":"component---src-templates-blog-post-js","path":"/enumerate-matches/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"f277fa2a-d9ce-5a55-93b4-521fbe47e0ad","excerpt":"At The Guardian, we’ve got a tool called Typerighter that’s a bit like Grammarly, plus our style guide.  It’s a handy tool to check that copy matches our house…","html":"<div data-regex=\"(try|it|out)\" data-allow-edit=\"true\"></div>\n<p>At The Guardian, we’ve got a tool called <a href=\"https://github.com/guardian/typerighter\">Typerighter</a> that’s a bit like Grammarly, plus our style guide. <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> It’s a handy tool to check that copy matches our house style. The Daily Mail <a href=\"https://www.dailymail.co.uk/news/article-11427737/How-war-trans-rights-killing-free-speech-worlds-sanctimonious-paper-Guardian.html#:~:text=The%20paper%20has%20a%20new%20editorial%20tool%20called%20%27Typerighter%27%20which%20does%20not%20merely%20correct%20poor%20English%20or%20bad%20punctuation%20but%20insists%20on%20politically%20correct%20terminology.%20The%20word%20%27aboriginal%27%20is%20proscribed.%20Journalists%20are%20enjoined%20to%20write%20%27pro%2Dchoice%27%20but%20never%20%27pro%2Dlife%27.\">love it.</a></p>\n<p>It has a few different ways of matching text. It has a spellchecker, for standard dictionary words. It has some more complicated rules written for LanguageTool, an open-source spelling and grammar checker. But the majority of the corpus that doesn’t come from a dictionary is at present written in regular expressions. At the moment, there are about 13,000 of them, the vast majority written by our in-house regex genius and product manager, <a href=\"https://www.theguardian.com/profile/maxtonwalker\">Max Walker.</a></p>\n<p>One might think that if solving a problem with a regular expression means that you now have two problems,<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> the maintainers of this giant corpus have ~13,000 problems. But these rules have worked very well in practice, in combination with decent user telemetry and a good rule management system. The hard part is writing them: especially, helping non-technical users to write them.</p>\n<p>I had a thought: could I write a program that would enumerate every string a given regex would match? And if it did exist, could it help regex authors better understand what they are writing?</p>\n<p>Then I found <a href=\"https://github.com/asciimoo/exrex\">ExRex</a>, which does precisely what I wanted. But it was written in Python, and I wanted an excuse to try to solve this myself, so…</p>\n<h2>Parsing regular expressions</h2>\n<p>Like any other programming language, regular expressions parse down to an Abstract Syntax Tree (AST), and because regexes are so ubiquitous, it wasn’t hard to find a parser library — in this case, the JavaScript library <a href=\"regexp-tree\">regexp-tree</a>, as I was writing this program for a web-based app. As an example of what an AST looks like, a regular expression with a capturing group matching either ‘a’ or ‘b’, <code class=\"language-text\">/(a|b)/</code>, gives this output:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RegExp\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"body\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Group\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"capturing\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"number\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"expression\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Disjunction\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"left\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Char\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"value\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"kind\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"simple\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"symbol\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"codePoint\"</span><span class=\"token operator\">:</span> <span class=\"token number\">97</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"right\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Char\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"value\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"kind\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"simple\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"symbol\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"codePoint\"</span><span class=\"token operator\">:</span> <span class=\"token number\">98</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"flags\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>A diagram makes the tree structure a bit clearer:</p>\n<ul class=\"tree\">\n  <li> <span>RegExp</span>\n    <ul>\n      <li> <span>Group</span>\n        <ul>\n          <li> <span>Disjunction</span>\n            <ul>\n              <li> <span>Char: 'a'</span>\n              </li>\n              <li> <span>Char: 'b'</span>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<p>Given this tree, and the assumption that we can reasonably generate characters that match each leaf node in isolation, one thought might be to traverse the tree, generating combinations of characters every time we encounter ‘or’ choices (the Disjunction, <code class=\"language-text\">|</code>, above), or repetition (like the option <code class=\"language-text\">?</code> or zero-to-many <code class=\"language-text\">*</code> operators). A naive approach would be to write a handler for each node, which could recursively call other handlers for children, passing arrays of possibilities back up the tree to produce a final set of results — something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> <span class=\"token generic-function\"><span class=\"token function\">getMatchesForNode</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> AstNode<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  node<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=></span> nodeToMatches<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>node <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> negative<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> nodeToMatches <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Root node</span>\n  <span class=\"token function-variable function\">RegExp</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> AstRegexp<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">getMatchesForNode</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Always yields a single result</span>\n  <span class=\"token function-variable function\">Char</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> Char<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Will yield multiple results</span>\n  <span class=\"token function-variable function\">Disjunction</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> Disjunction<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> left <span class=\"token operator\">=</span> <span class=\"token function\">getMatchesForNode</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> right <span class=\"token operator\">=</span> <span class=\"token function\">getMatchesForNode</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> left<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// ... plus all other nodes.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>You may have spotted a flaw: some nodes, like <code class=\"language-text\">*</code>, generate infinite sequences, and so our program will attempt to generate an exhaustive series of matches and never halt.</p>\n<ul class=\"tree\">\n  <li> <span>RegExp</span>\n    <ul>\n      <li> <span>Quantifier: 0-Infinity <span class=\"node-content\">this gets stuck!</span></span>\n          <ul>\n            <li> <span>Char: 'a'</span>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<p>Faced with a potentially infinite set of possible matches, we need a program that generates as many as we want, and no more.</p>\n<h2>Generators (can’t you hear my motored heart)</h2>\n<p>JavaScript has a language feature that makes this task easier — <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\">Generators</a>. Generators are functions that, once called, can yield control back to the caller until they are next called — they can stop and start at will. If each node returns a generator that always produces a single result, we can traverse the tree just once on every iteration.</p>\n<p>This leads us to some fun combinatorial problems. What about <code class=\"language-text\">Disjunction</code> or <code class=\"language-text\">Alternative</code> nodes (lists of expressions in sequence), that yield a different result every time? Consider the regex <code class=\"language-text\">(a|b)(c|d)(e|f)</code>, which looks like:</p>\n<ul class=\"tree\">\n  <li> <span>RegExp</span>\n    <ul>\n      <li> <span>Alternative</span>\n        <ul>\n          <li> <span>Group</span>\n            <ul>\n              <li> <span>Disjunction</span>\n                <ul>\n                  <li> <span>Char: 'a'</span>\n                  </li>\n                  <li> <span>Char: 'b'</span>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n          <li> <span>Group</span>\n            <ul>\n              <li> <span>Disjunction</span>\n                <ul>\n                  <li> <span>Char: 'c'</span>\n                  </li>\n                  <li> <span>Char: 'd'</span>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n          <li> <span>Group</span>\n            <ul>\n              <li> <span>Disjunction</span>\n                <ul>\n                  <li> <span>Char: 'e'</span>\n                  </li>\n                  <li> <span>Char: 'f'</span>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<p>Here are all the possible matches for that expression:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ace\nacf\nade\nadf\nbce\nbcf\nbde\nbdf</code></pre></div>\n<p>A few things to note:</p>\n<ul>\n<li>The results are ordered by node.</li>\n<li>We do not know in advance whether a node will yield additional results.</li>\n</ul>\n<p>I had to sit down with some pen and paper to work out an algorithm.</p>\n<p>First we consider some state. For the parent <code class=\"language-text\">Alternatives</code> node, we iterate over its child nodes to yield a value. Each child node may yield 1-many values. We store the index of the current child node, indicating which child will next yield a new value.</p>\n<p>For each child <code class=\"language-text\">Expression</code> node, we store the index of the permutation it will next yield (which may not be the latest permutation), and the list of permutations it has already yielded, so we can backtrack as other child nodes yield new values.</p>\n<p>With that in mind:</p>\n<ol>\n<li>Take a result from all the child nodes, and concatenate them. Yield the output string.</li>\n<li>Increment the current child’s permutation index.</li>\n<li>If every child node’s permutation index is at the leading edge of its set of permutations:\n<ul>\n<li>If there is a next child that has not yielded all its permutations after this child, point the parent index to the next child. The next child yields a new permutation and points its permutation index at the new permutation.</li>\n<li>Else, all children have completed and all permutations have been yielded! Complete execution.</li>\n</ul>\n</li>\n<li>Else, if the current child node has completed its permutations, reset this child’s index, and move to the next available permutation in a subsequent child.</li>\n<li>Return to step 1.</li>\n</ol>\n<p>Here’s a look at it in action:</p>\n<div data-regex=\"(a|b)(c|d)(e|f)\"></div>\n<p>There’s one more problem to solve. Repeater nodes produce combinations, as they permit any combination of the values yielded by their child node. For example, the regex <code class=\"language-text\">(a|b){3}</code> (either <code class=\"language-text\">a</code> or <code class=\"language-text\">b</code>, repeated 3 times) matches</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">aaa\naab\naba\nabb\nbaa\nbab\nbba\nbbb</code></pre></div>\n<p>This is more straightforward to solve, as we can increment our child node generator until it runs out of values, and then treat the complete list as our alphabet, incrementing from right to left:</p>\n<div data-regex=\"(a|b){3}\"></div>\n<p>It’s been fun running some of our rules through this program. The (now-outdated!) rule <code class=\"language-text\">Camilla,? (Parker ?-?Bowles|(the)? Queen Consort)</code> -> <code class=\"language-text\">Camilla, the Queen Consort</code> gives an idea of the sort of mistakes that happen in the wild:</p>\n<div data-regex=\"Camilla,? (Parker ?-?Bowles|(the)? Queen Consort)\"></div>\n<p>For a fun test beyond our style guide, who doesn’t enjoy the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#basic_validation\">MDN e-mail validation regex</a>:</p>\n<div data-regex=\"^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$\"></div>\n<p>The MDN example also reveals a possible improvement — the algorithm above runs depth-first, exhausting one node before moving to another. That means that we get fewer email-like examples when running the above — a single iteration of the <code class=\"language-text\">(?:\\.[a-zA-Z0-9-]+)*</code> would give us a <code class=\"language-text\">a@a.a</code>, but there’s an infinity of alphabet in the two quantifier nodes before we get there.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a@a\nb@a\nc@a\nd@a\ne@a\n// ... for ever</code></pre></div>\n<p>How could we avoid getting stuck on nodes yielding infinite results, thus revealing more of the tree sooner? Traversing the tree breadth first might be one way. Adding a configurable limit to the number of values a node capable of generating infinite series could yield might be another.</p>\n<p>It’d be interesting to integrate this with our management tooling to give Typerighter’s users another way to verify the regexes they’re writing are along the right lines. I’ll chat to the team to see what they think.</p>\n<p>And if you fancy using this in your own projects, it’s available under a permissive license at <a href=\"https://www.npmjs.com/package/regex-enumerate-matches\">regex-enumerate-matches</a>.</p>\n<script id=\"page-script\" type=\"module\">\n  // Module code\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n    var __getProtoOf = Object.getPrototypeOf;\n    var __getOwnPropNames = Object.getOwnPropertyNames;\n    var __hasOwnProp = Object.prototype.hasOwnProperty;\n    var __toESM = (mod, isNodeMode, target) => {\n      target = mod != null ? __create(__getProtoOf(mod)) : {};\n      const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n      for (let key of __getOwnPropNames(mod))\n        if (!__hasOwnProp.call(to, key))\n          __defProp(to, key, {\n            get: () => mod[key],\n            enumerable: true\n          });\n      return to;\n    };\n    var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\n\n    // node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js\n    var require_compat_dotall_s_transform = __commonJS((exports, module) => {\n      module.exports = {\n        _hasUFlag: false,\n        shouldRun: function shouldRun(ast) {\n          var shouldRun = ast.flags.includes(\"s\");\n          if (!shouldRun) {\n            return false;\n          }\n          ast.flags = ast.flags.replace(\"s\", \"\");\n          this._hasUFlag = ast.flags.includes(\"u\");\n          return true;\n        },\n        Char: function Char(path) {\n          var node = path.node;\n          if (node.kind !== \"meta\" || node.value !== \".\") {\n            return;\n          }\n          var toValue = \"\\\\uFFFF\";\n          var toSymbol = \"\\uFFFF\";\n          if (this._hasUFlag) {\n            toValue = \"\\\\u{10FFFF}\";\n            toSymbol = \"\\uDBFF\\uDFFF\";\n          }\n          path.replace({\n            type: \"CharacterClass\",\n            expressions: [{\n              type: \"ClassRange\",\n              from: {\n                type: \"Char\",\n                value: \"\\\\0\",\n                kind: \"decimal\",\n                symbol: \"\\0\"\n              },\n              to: {\n                type: \"Char\",\n                value: toValue,\n                kind: \"unicode\",\n                symbol: toSymbol\n              }\n            }]\n          });\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js\n    var require_compat_named_capturing_groups_transform = __commonJS((exports, module) => {\n      module.exports = {\n        _groupNames: {},\n        init: function init() {\n          this._groupNames = {};\n        },\n        getExtra: function getExtra() {\n          return this._groupNames;\n        },\n        Group: function Group(path) {\n          var node = path.node;\n          if (!node.name) {\n            return;\n          }\n          this._groupNames[node.name] = node.number;\n          delete node.name;\n          delete node.nameRaw;\n        },\n        Backreference: function Backreference(path) {\n          var node = path.node;\n          if (node.kind !== \"name\") {\n            return;\n          }\n          node.kind = \"number\";\n          node.reference = node.number;\n          delete node.referenceRaw;\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js\n    var require_compat_x_flag_transform = __commonJS((exports, module) => {\n      module.exports = {\n        RegExp: function RegExp(_ref) {\n          var node = _ref.node;\n          if (node.flags.includes(\"x\")) {\n            node.flags = node.flags.replace(\"x\", \"\");\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js\n    var require_transforms = __commonJS((exports, module) => {\n      module.exports = {\n        dotAll: require_compat_dotall_s_transform(),\n        namedCapturingGroups: require_compat_named_capturing_groups_transform(),\n        xFlag: require_compat_x_flag_transform()\n      };\n    });\n\n    // node_modules/regexp-tree/dist/generator/index.js\n    var require_generator = __commonJS((exports, module) => {\n      var gen = function(node) {\n        return node ? generator[node.type](node) : \"\";\n      };\n      var generator = {\n        RegExp: function RegExp(node) {\n          return \"/\" + gen(node.body) + \"/\" + node.flags;\n        },\n        Alternative: function Alternative(node) {\n          return (node.expressions || []).map(gen).join(\"\");\n        },\n        Disjunction: function Disjunction(node) {\n          return gen(node.left) + \"|\" + gen(node.right);\n        },\n        Group: function Group(node) {\n          var expression = gen(node.expression);\n          if (node.capturing) {\n            if (node.name) {\n              return \"(?<\" + (node.nameRaw || node.name) + \">\" + expression + \")\";\n            }\n            return \"(\" + expression + \")\";\n          }\n          return \"(?:\" + expression + \")\";\n        },\n        Backreference: function Backreference(node) {\n          switch (node.kind) {\n            case \"number\":\n              return \"\\\\\" + node.reference;\n            case \"name\":\n              return \"\\\\k<\" + (node.referenceRaw || node.reference) + \">\";\n            default:\n              throw new TypeError(\"Unknown Backreference kind: \" + node.kind);\n          }\n        },\n        Assertion: function Assertion(node) {\n          switch (node.kind) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\b\":\n            case \"\\\\B\":\n              return node.kind;\n            case \"Lookahead\": {\n              var assertion = gen(node.assertion);\n              if (node.negative) {\n                return \"(?!\" + assertion + \")\";\n              }\n              return \"(?=\" + assertion + \")\";\n            }\n            case \"Lookbehind\": {\n              var _assertion = gen(node.assertion);\n              if (node.negative) {\n                return \"(?<!\" + _assertion + \")\";\n              }\n              return \"(?<=\" + _assertion + \")\";\n            }\n            default:\n              throw new TypeError(\"Unknown Assertion kind: \" + node.kind);\n          }\n        },\n        CharacterClass: function CharacterClass(node) {\n          var expressions = node.expressions.map(gen).join(\"\");\n          if (node.negative) {\n            return \"[^\" + expressions + \"]\";\n          }\n          return \"[\" + expressions + \"]\";\n        },\n        ClassRange: function ClassRange(node) {\n          return gen(node.from) + \"-\" + gen(node.to);\n        },\n        Repetition: function Repetition(node) {\n          return \"\" + gen(node.expression) + gen(node.quantifier);\n        },\n        Quantifier: function Quantifier(node) {\n          var quantifier = undefined;\n          var greedy = node.greedy ? \"\" : \"?\";\n          switch (node.kind) {\n            case \"+\":\n            case \"?\":\n            case \"*\":\n              quantifier = node.kind;\n              break;\n            case \"Range\":\n              if (node.from === node.to) {\n                quantifier = \"{\" + node.from + \"}\";\n              } else if (!node.to) {\n                quantifier = \"{\" + node.from + \",}\";\n              } else {\n                quantifier = \"{\" + node.from + \",\" + node.to + \"}\";\n              }\n              break;\n            default:\n              throw new TypeError(\"Unknown Quantifier kind: \" + node.kind);\n          }\n          return \"\" + quantifier + greedy;\n        },\n        Char: function Char(node) {\n          var value = node.value;\n          switch (node.kind) {\n            case \"simple\": {\n              if (node.escaped) {\n                return \"\\\\\" + value;\n              }\n              return value;\n            }\n            case \"hex\":\n            case \"unicode\":\n            case \"oct\":\n            case \"decimal\":\n            case \"control\":\n            case \"meta\":\n              return value;\n            default:\n              throw new TypeError(\"Unknown Char kind: \" + node.kind);\n          }\n        },\n        UnicodeProperty: function UnicodeProperty(node) {\n          var escapeChar = node.negative ? \"P\" : \"p\";\n          var namePart = undefined;\n          if (!node.shorthand && !node.binary) {\n            namePart = node.name + \"=\";\n          } else {\n            namePart = \"\";\n          }\n          return \"\\\\\" + escapeChar + \"{\" + namePart + node.value + \"}\";\n        }\n      };\n      module.exports = {\n        generate: gen\n      };\n    });\n\n    // node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js\n    var require_parser_unicode_properties = __commonJS((exports, module) => {\n      var inverseMap = function(data) {\n        var inverse = {};\n        for (var name in data) {\n          if (!data.hasOwnProperty(name)) {\n            continue;\n          }\n          var value = data[name];\n          if (Array.isArray(value)) {\n            for (var i = 0;i < value.length; i++) {\n              inverse[value[i]] = name;\n            }\n          } else {\n            inverse[value] = name;\n          }\n        }\n        return inverse;\n      };\n      var isValidName = function(name) {\n        return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);\n      };\n      var isValidValue = function(name, value) {\n        if (isGeneralCategoryName(name)) {\n          return isGeneralCategoryValue(value);\n        }\n        if (isScriptCategoryName(name)) {\n          return isScriptCategoryValue(value);\n        }\n        return false;\n      };\n      var isAlias = function(name) {\n        return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);\n      };\n      var isGeneralCategoryName = function(name) {\n        return name === \"General_Category\" || name == \"gc\";\n      };\n      var isScriptCategoryName = function(name) {\n        return name === \"Script\" || name === \"Script_Extensions\" || name === \"sc\" || name === \"scx\";\n      };\n      var isGeneralCategoryValue = function(value) {\n        return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);\n      };\n      var isScriptCategoryValue = function(value) {\n        return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);\n      };\n      var isBinaryPropertyName = function(name) {\n        return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);\n      };\n      var getCanonicalName = function(name) {\n        if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {\n          return NON_BINARY_ALIASES_TO_PROP_NAMES[name];\n        }\n        if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {\n          return BINARY_ALIASES_TO_PROP_NAMES[name];\n        }\n        return null;\n      };\n      var getCanonicalValue = function(value) {\n        if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {\n          return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];\n        }\n        if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {\n          return SCRIPT_VALUE_ALIASES_TO_VALUE[value];\n        }\n        if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {\n          return BINARY_ALIASES_TO_PROP_NAMES[value];\n        }\n        return null;\n      };\n      var NON_BINARY_PROP_NAMES_TO_ALIASES = {\n        General_Category: \"gc\",\n        Script: \"sc\",\n        Script_Extensions: \"scx\"\n      };\n      var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);\n      var BINARY_PROP_NAMES_TO_ALIASES = {\n        ASCII: \"ASCII\",\n        ASCII_Hex_Digit: \"AHex\",\n        Alphabetic: \"Alpha\",\n        Any: \"Any\",\n        Assigned: \"Assigned\",\n        Bidi_Control: \"Bidi_C\",\n        Bidi_Mirrored: \"Bidi_M\",\n        Case_Ignorable: \"CI\",\n        Cased: \"Cased\",\n        Changes_When_Casefolded: \"CWCF\",\n        Changes_When_Casemapped: \"CWCM\",\n        Changes_When_Lowercased: \"CWL\",\n        Changes_When_NFKC_Casefolded: \"CWKCF\",\n        Changes_When_Titlecased: \"CWT\",\n        Changes_When_Uppercased: \"CWU\",\n        Dash: \"Dash\",\n        Default_Ignorable_Code_Point: \"DI\",\n        Deprecated: \"Dep\",\n        Diacritic: \"Dia\",\n        Emoji: \"Emoji\",\n        Emoji_Component: \"Emoji_Component\",\n        Emoji_Modifier: \"Emoji_Modifier\",\n        Emoji_Modifier_Base: \"Emoji_Modifier_Base\",\n        Emoji_Presentation: \"Emoji_Presentation\",\n        Extended_Pictographic: \"Extended_Pictographic\",\n        Extender: \"Ext\",\n        Grapheme_Base: \"Gr_Base\",\n        Grapheme_Extend: \"Gr_Ext\",\n        Hex_Digit: \"Hex\",\n        IDS_Binary_Operator: \"IDSB\",\n        IDS_Trinary_Operator: \"IDST\",\n        ID_Continue: \"IDC\",\n        ID_Start: \"IDS\",\n        Ideographic: \"Ideo\",\n        Join_Control: \"Join_C\",\n        Logical_Order_Exception: \"LOE\",\n        Lowercase: \"Lower\",\n        Math: \"Math\",\n        Noncharacter_Code_Point: \"NChar\",\n        Pattern_Syntax: \"Pat_Syn\",\n        Pattern_White_Space: \"Pat_WS\",\n        Quotation_Mark: \"QMark\",\n        Radical: \"Radical\",\n        Regional_Indicator: \"RI\",\n        Sentence_Terminal: \"STerm\",\n        Soft_Dotted: \"SD\",\n        Terminal_Punctuation: \"Term\",\n        Unified_Ideograph: \"UIdeo\",\n        Uppercase: \"Upper\",\n        Variation_Selector: \"VS\",\n        White_Space: \"space\",\n        XID_Continue: \"XIDC\",\n        XID_Start: \"XIDS\"\n      };\n      var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);\n      var GENERAL_CATEGORY_VALUE_TO_ALIASES = {\n        Cased_Letter: \"LC\",\n        Close_Punctuation: \"Pe\",\n        Connector_Punctuation: \"Pc\",\n        Control: [\"Cc\", \"cntrl\"],\n        Currency_Symbol: \"Sc\",\n        Dash_Punctuation: \"Pd\",\n        Decimal_Number: [\"Nd\", \"digit\"],\n        Enclosing_Mark: \"Me\",\n        Final_Punctuation: \"Pf\",\n        Format: \"Cf\",\n        Initial_Punctuation: \"Pi\",\n        Letter: \"L\",\n        Letter_Number: \"Nl\",\n        Line_Separator: \"Zl\",\n        Lowercase_Letter: \"Ll\",\n        Mark: [\"M\", \"Combining_Mark\"],\n        Math_Symbol: \"Sm\",\n        Modifier_Letter: \"Lm\",\n        Modifier_Symbol: \"Sk\",\n        Nonspacing_Mark: \"Mn\",\n        Number: \"N\",\n        Open_Punctuation: \"Ps\",\n        Other: \"C\",\n        Other_Letter: \"Lo\",\n        Other_Number: \"No\",\n        Other_Punctuation: \"Po\",\n        Other_Symbol: \"So\",\n        Paragraph_Separator: \"Zp\",\n        Private_Use: \"Co\",\n        Punctuation: [\"P\", \"punct\"],\n        Separator: \"Z\",\n        Space_Separator: \"Zs\",\n        Spacing_Mark: \"Mc\",\n        Surrogate: \"Cs\",\n        Symbol: \"S\",\n        Titlecase_Letter: \"Lt\",\n        Unassigned: \"Cn\",\n        Uppercase_Letter: \"Lu\"\n      };\n      var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);\n      var SCRIPT_VALUE_TO_ALIASES = {\n        Adlam: \"Adlm\",\n        Ahom: \"Ahom\",\n        Anatolian_Hieroglyphs: \"Hluw\",\n        Arabic: \"Arab\",\n        Armenian: \"Armn\",\n        Avestan: \"Avst\",\n        Balinese: \"Bali\",\n        Bamum: \"Bamu\",\n        Bassa_Vah: \"Bass\",\n        Batak: \"Batk\",\n        Bengali: \"Beng\",\n        Bhaiksuki: \"Bhks\",\n        Bopomofo: \"Bopo\",\n        Brahmi: \"Brah\",\n        Braille: \"Brai\",\n        Buginese: \"Bugi\",\n        Buhid: \"Buhd\",\n        Canadian_Aboriginal: \"Cans\",\n        Carian: \"Cari\",\n        Caucasian_Albanian: \"Aghb\",\n        Chakma: \"Cakm\",\n        Cham: \"Cham\",\n        Cherokee: \"Cher\",\n        Common: \"Zyyy\",\n        Coptic: [\"Copt\", \"Qaac\"],\n        Cuneiform: \"Xsux\",\n        Cypriot: \"Cprt\",\n        Cyrillic: \"Cyrl\",\n        Deseret: \"Dsrt\",\n        Devanagari: \"Deva\",\n        Dogra: \"Dogr\",\n        Duployan: \"Dupl\",\n        Egyptian_Hieroglyphs: \"Egyp\",\n        Elbasan: \"Elba\",\n        Ethiopic: \"Ethi\",\n        Georgian: \"Geor\",\n        Glagolitic: \"Glag\",\n        Gothic: \"Goth\",\n        Grantha: \"Gran\",\n        Greek: \"Grek\",\n        Gujarati: \"Gujr\",\n        Gunjala_Gondi: \"Gong\",\n        Gurmukhi: \"Guru\",\n        Han: \"Hani\",\n        Hangul: \"Hang\",\n        Hanifi_Rohingya: \"Rohg\",\n        Hanunoo: \"Hano\",\n        Hatran: \"Hatr\",\n        Hebrew: \"Hebr\",\n        Hiragana: \"Hira\",\n        Imperial_Aramaic: \"Armi\",\n        Inherited: [\"Zinh\", \"Qaai\"],\n        Inscriptional_Pahlavi: \"Phli\",\n        Inscriptional_Parthian: \"Prti\",\n        Javanese: \"Java\",\n        Kaithi: \"Kthi\",\n        Kannada: \"Knda\",\n        Katakana: \"Kana\",\n        Kayah_Li: \"Kali\",\n        Kharoshthi: \"Khar\",\n        Khmer: \"Khmr\",\n        Khojki: \"Khoj\",\n        Khudawadi: \"Sind\",\n        Lao: \"Laoo\",\n        Latin: \"Latn\",\n        Lepcha: \"Lepc\",\n        Limbu: \"Limb\",\n        Linear_A: \"Lina\",\n        Linear_B: \"Linb\",\n        Lisu: \"Lisu\",\n        Lycian: \"Lyci\",\n        Lydian: \"Lydi\",\n        Mahajani: \"Mahj\",\n        Makasar: \"Maka\",\n        Malayalam: \"Mlym\",\n        Mandaic: \"Mand\",\n        Manichaean: \"Mani\",\n        Marchen: \"Marc\",\n        Medefaidrin: \"Medf\",\n        Masaram_Gondi: \"Gonm\",\n        Meetei_Mayek: \"Mtei\",\n        Mende_Kikakui: \"Mend\",\n        Meroitic_Cursive: \"Merc\",\n        Meroitic_Hieroglyphs: \"Mero\",\n        Miao: \"Plrd\",\n        Modi: \"Modi\",\n        Mongolian: \"Mong\",\n        Mro: \"Mroo\",\n        Multani: \"Mult\",\n        Myanmar: \"Mymr\",\n        Nabataean: \"Nbat\",\n        New_Tai_Lue: \"Talu\",\n        Newa: \"Newa\",\n        Nko: \"Nkoo\",\n        Nushu: \"Nshu\",\n        Ogham: \"Ogam\",\n        Ol_Chiki: \"Olck\",\n        Old_Hungarian: \"Hung\",\n        Old_Italic: \"Ital\",\n        Old_North_Arabian: \"Narb\",\n        Old_Permic: \"Perm\",\n        Old_Persian: \"Xpeo\",\n        Old_Sogdian: \"Sogo\",\n        Old_South_Arabian: \"Sarb\",\n        Old_Turkic: \"Orkh\",\n        Oriya: \"Orya\",\n        Osage: \"Osge\",\n        Osmanya: \"Osma\",\n        Pahawh_Hmong: \"Hmng\",\n        Palmyrene: \"Palm\",\n        Pau_Cin_Hau: \"Pauc\",\n        Phags_Pa: \"Phag\",\n        Phoenician: \"Phnx\",\n        Psalter_Pahlavi: \"Phlp\",\n        Rejang: \"Rjng\",\n        Runic: \"Runr\",\n        Samaritan: \"Samr\",\n        Saurashtra: \"Saur\",\n        Sharada: \"Shrd\",\n        Shavian: \"Shaw\",\n        Siddham: \"Sidd\",\n        SignWriting: \"Sgnw\",\n        Sinhala: \"Sinh\",\n        Sogdian: \"Sogd\",\n        Sora_Sompeng: \"Sora\",\n        Soyombo: \"Soyo\",\n        Sundanese: \"Sund\",\n        Syloti_Nagri: \"Sylo\",\n        Syriac: \"Syrc\",\n        Tagalog: \"Tglg\",\n        Tagbanwa: \"Tagb\",\n        Tai_Le: \"Tale\",\n        Tai_Tham: \"Lana\",\n        Tai_Viet: \"Tavt\",\n        Takri: \"Takr\",\n        Tamil: \"Taml\",\n        Tangut: \"Tang\",\n        Telugu: \"Telu\",\n        Thaana: \"Thaa\",\n        Thai: \"Thai\",\n        Tibetan: \"Tibt\",\n        Tifinagh: \"Tfng\",\n        Tirhuta: \"Tirh\",\n        Ugaritic: \"Ugar\",\n        Vai: \"Vaii\",\n        Warang_Citi: \"Wara\",\n        Yi: \"Yiii\",\n        Zanabazar_Square: \"Zanb\"\n      };\n      var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);\n      module.exports = {\n        isAlias,\n        isValidName,\n        isValidValue,\n        isGeneralCategoryValue,\n        isScriptCategoryValue,\n        isBinaryPropertyName,\n        getCanonicalName,\n        getCanonicalValue,\n        NON_BINARY_PROP_NAMES_TO_ALIASES,\n        NON_BINARY_ALIASES_TO_PROP_NAMES,\n        BINARY_PROP_NAMES_TO_ALIASES,\n        BINARY_ALIASES_TO_PROP_NAMES,\n        GENERAL_CATEGORY_VALUE_TO_ALIASES,\n        GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,\n        SCRIPT_VALUE_TO_ALIASES,\n        SCRIPT_VALUE_ALIASES_TO_VALUE\n      };\n    });\n\n    // node_modules/regexp-tree/dist/parser/generated/regexp-tree.js\n    var require_regexp_tree = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var yyloc = function(start, end) {\n        if (!yy.options.captureLocations) {\n          return null;\n        }\n        if (!start || !end) {\n          return start || end;\n        }\n        return {\n          startOffset: start.startOffset,\n          endOffset: end.endOffset,\n          startLine: start.startLine,\n          endLine: end.endLine,\n          startColumn: start.startColumn,\n          endColumn: end.endColumn\n        };\n      };\n      var getRange = function(text) {\n        var range = text.match(/\\d+/g).map(Number);\n        if (Number.isFinite(range[1]) && range[1] < range[0]) {\n          throw new SyntaxError(\"Numbers out of order in \" + text + \" quantifier\");\n        }\n        return range;\n      };\n      var checkClassRange = function(from, to) {\n        if (from.kind === \"control\" || to.kind === \"control\" || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {\n          throw new SyntaxError(\"Range \" + from.value + \"-\" + to.value + \" out of order in character class\");\n        }\n      };\n      var UnicodeProperty = function(matched, loc2) {\n        var negative = matched[1] === \"P\";\n        var separatorIdx = matched.indexOf(\"=\");\n        var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);\n        var value = undefined;\n        var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);\n        var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);\n        if (isShorthand) {\n          value = name;\n          name = \"General_Category\";\n        } else if (isBinaryProperty) {\n          value = name;\n        } else {\n          if (!unicodeProperties.isValidName(name)) {\n            throw new SyntaxError(\"Invalid unicode property name: \" + name + \".\");\n          }\n          value = matched.slice(separatorIdx + 1, -1);\n          if (!unicodeProperties.isValidValue(name, value)) {\n            throw new SyntaxError(\"Invalid \" + name + \" unicode property value: \" + value + \".\");\n          }\n        }\n        return Node({\n          type: \"UnicodeProperty\",\n          name,\n          value,\n          negative,\n          shorthand: isShorthand,\n          binary: isBinaryProperty,\n          canonicalName: unicodeProperties.getCanonicalName(name) || name,\n          canonicalValue: unicodeProperties.getCanonicalValue(value) || value\n        }, loc2);\n      };\n      var Char = function(value, kind, loc2) {\n        var symbol = undefined;\n        var codePoint = undefined;\n        switch (kind) {\n          case \"decimal\": {\n            codePoint = Number(value.slice(1));\n            symbol = String.fromCodePoint(codePoint);\n            break;\n          }\n          case \"oct\": {\n            codePoint = parseInt(value.slice(1), 8);\n            symbol = String.fromCodePoint(codePoint);\n            break;\n          }\n          case \"hex\":\n          case \"unicode\": {\n            if (value.lastIndexOf(\"\\\\u\") > 0) {\n              var _value$split$slice = value.split(\"\\\\u\").slice(1), _value$split$slice2 = _slicedToArray(_value$split$slice, 2), lead = _value$split$slice2[0], trail = _value$split$slice2[1];\n              lead = parseInt(lead, 16);\n              trail = parseInt(trail, 16);\n              codePoint = (lead - 55296) * 1024 + (trail - 56320) + 65536;\n              symbol = String.fromCodePoint(codePoint);\n            } else {\n              var hex = value.slice(2).replace(\"{\", \"\");\n              codePoint = parseInt(hex, 16);\n              if (codePoint > 1114111) {\n                throw new SyntaxError(\"Bad character escape sequence: \" + value);\n              }\n              symbol = String.fromCodePoint(codePoint);\n            }\n            break;\n          }\n          case \"meta\": {\n            switch (value) {\n              case \"\\\\t\":\n                symbol = \"\\t\";\n                codePoint = symbol.codePointAt(0);\n                break;\n              case \"\\\\n\":\n                symbol = \"\\n\";\n                codePoint = symbol.codePointAt(0);\n                break;\n              case \"\\\\r\":\n                symbol = \"\\r\";\n                codePoint = symbol.codePointAt(0);\n                break;\n              case \"\\\\v\":\n                symbol = \"\\v\";\n                codePoint = symbol.codePointAt(0);\n                break;\n              case \"\\\\f\":\n                symbol = \"\\f\";\n                codePoint = symbol.codePointAt(0);\n                break;\n              case \"\\\\b\":\n                symbol = \"\\b\";\n                codePoint = symbol.codePointAt(0);\n              case \"\\\\0\":\n                symbol = \"\\0\";\n                codePoint = 0;\n              case \".\":\n                symbol = \".\";\n                codePoint = NaN;\n                break;\n              default:\n                codePoint = NaN;\n            }\n            break;\n          }\n          case \"simple\": {\n            symbol = value;\n            codePoint = symbol.codePointAt(0);\n            break;\n          }\n        }\n        return Node({\n          type: \"Char\",\n          value,\n          kind,\n          symbol,\n          codePoint\n        }, loc2);\n      };\n      var checkFlags = function(flags) {\n        var seen = new Set;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = flags[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var flag = _step.value;\n            if (seen.has(flag) || !validFlags.includes(flag)) {\n              throw new SyntaxError(\"Invalid flags: \" + flags);\n            }\n            seen.add(flag);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        return flags.split(\"\").sort().join(\"\");\n      };\n      var GroupRefOrDecChar = function(text, textLoc) {\n        var reference = Number(text.slice(1));\n        if (reference > 0 && reference <= capturingGroupsCount) {\n          return Node({\n            type: \"Backreference\",\n            kind: \"number\",\n            number: reference,\n            reference\n          }, textLoc);\n        }\n        return Char(text, \"decimal\", textLoc);\n      };\n      var validateUnicodeGroupName = function(name, state) {\n        var isUnicodeName = ucpReAnywhere.test(name);\n        var isUnicodeState = state === \"u\" || state === \"xu\" || state === \"u_class\";\n        if (isUnicodeName && !isUnicodeState) {\n          throw new SyntaxError('invalid group Unicode name \"' + name + '\", use `u` flag.');\n        }\n        return name;\n      };\n      var decodeUnicodeGroupName = function(name) {\n        return name.replace(new RegExp(uidRe, \"g\"), function(_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {\n          if (leadSurrogate) {\n            return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));\n          }\n          if (leadSurrogateOnly) {\n            return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));\n          }\n          if (trailSurrogateOnly) {\n            return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));\n          }\n          if (nonSurrogate) {\n            return String.fromCodePoint(parseInt(nonSurrogate, 16));\n          }\n          if (codePoint) {\n            return String.fromCodePoint(parseInt(codePoint, 16));\n          }\n          return _;\n        });\n      };\n      var NamedGroupRefOrChars = function(text, textLoc) {\n        var referenceRaw = text.slice(3, -1);\n        var reference = decodeUnicodeGroupName(referenceRaw);\n        if (namedGroups.hasOwnProperty(reference)) {\n          return Node({\n            type: \"Backreference\",\n            kind: \"name\",\n            number: namedGroups[reference],\n            reference,\n            referenceRaw\n          }, textLoc);\n        }\n        var startOffset = null;\n        var startLine = null;\n        var endLine = null;\n        var startColumn = null;\n        if (textLoc) {\n          startOffset = textLoc.startOffset;\n          startLine = textLoc.startLine;\n          endLine = textLoc.endLine;\n          startColumn = textLoc.startColumn;\n        }\n        var charRe = /^[\\w$<>]/;\n        var loc2 = undefined;\n        var chars = [\n          Char(text.slice(1, 2), \"simple\", startOffset ? {\n            startLine,\n            endLine,\n            startColumn,\n            startOffset,\n            endOffset: startOffset += 2,\n            endColumn: startColumn += 2\n          } : null)\n        ];\n        chars[0].escaped = true;\n        text = text.slice(2);\n        while (text.length > 0) {\n          var matched = null;\n          if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {\n            if (startOffset) {\n              loc2 = {\n                startLine,\n                endLine,\n                startColumn,\n                startOffset,\n                endOffset: startOffset += matched[0].length,\n                endColumn: startColumn += matched[0].length\n              };\n            }\n            chars.push(Char(matched[0], \"unicode\", loc2));\n            text = text.slice(matched[0].length);\n          } else if (matched = text.match(charRe)) {\n            if (startOffset) {\n              loc2 = {\n                startLine,\n                endLine,\n                startColumn,\n                startOffset,\n                endOffset: ++startOffset,\n                endColumn: ++startColumn\n              };\n            }\n            chars.push(Char(matched[0], \"simple\", loc2));\n            text = text.slice(1);\n          }\n        }\n        return chars;\n      };\n      var Node = function(node, loc2) {\n        if (yy.options.captureLocations) {\n          node.loc = {\n            source: parsingString.slice(loc2.startOffset, loc2.endOffset),\n            start: {\n              line: loc2.startLine,\n              column: loc2.startColumn,\n              offset: loc2.startOffset\n            },\n            end: {\n              line: loc2.endLine,\n              column: loc2.endColumn,\n              offset: loc2.endOffset\n            }\n          };\n        }\n        return node;\n      };\n      var loc = function(start, end) {\n        if (!yy.options.captureLocations) {\n          return null;\n        }\n        return {\n          startOffset: start.startOffset,\n          endOffset: end.endOffset,\n          startLine: start.startLine,\n          endLine: end.endLine,\n          startColumn: start.startColumn,\n          endColumn: end.endColumn\n        };\n      };\n      var unexpectedToken = function(token) {\n        if (token.type === EOF) {\n          unexpectedEndOfInput();\n        }\n        tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);\n      };\n      var unexpectedEndOfInput = function() {\n        parseError(\"Unexpected end of input.\");\n      };\n      var parseError = function(message) {\n        throw new SyntaxError(message);\n      };\n      var _slicedToArray = function() {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n          try {\n            for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n              if (i && _arr.length === i)\n                break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"])\n                _i[\"return\"]();\n            } finally {\n              if (_d)\n                throw _e;\n            }\n          }\n          return _arr;\n        }\n        return function(arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n      var yytext = undefined;\n      var yyleng = undefined;\n      var yy = {};\n      var __ = undefined;\n      var __loc = undefined;\n      var EOF = \"$\";\n      var productions = [[-1, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [0, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {\n        __loc = yyloc(_1loc, _4loc);\n        __ = Node({\n          type: \"RegExp\",\n          body: _2,\n          flags: checkFlags(_4)\n        }, loc(_1loc, _4loc || _3loc));\n      }], [1, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [1, 0, function() {\n        __loc = null;\n        __ = \"\";\n      }], [2, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [2, 2, function(_1, _2, _1loc, _2loc) {\n        __loc = yyloc(_1loc, _2loc);\n        __ = _1 + _2;\n      }], [3, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [4, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [4, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        var _loc = null;\n        if (_2loc) {\n          _loc = loc(_1loc || _2loc, _3loc || _2loc);\n        }\n        __ = Node({\n          type: \"Disjunction\",\n          left: _1,\n          right: _3\n        }, _loc);\n      }], [5, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        if (_1.length === 0) {\n          __ = null;\n          return;\n        }\n        if (_1.length === 1) {\n          __ = Node(_1[0], __loc);\n        } else {\n          __ = Node({\n            type: \"Alternative\",\n            expressions: _1\n          }, __loc);\n        }\n      }], [6, 0, function() {\n        __loc = null;\n        __ = [];\n      }], [6, 2, function(_1, _2, _1loc, _2loc) {\n        __loc = yyloc(_1loc, _2loc);\n        __ = _1.concat(_2);\n      }], [7, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Node(Object.assign({ type: \"Assertion\" }, _1), __loc);\n      }], [7, 2, function(_1, _2, _1loc, _2loc) {\n        __loc = yyloc(_1loc, _2loc);\n        __ = _1;\n        if (_2) {\n          __ = Node({\n            type: \"Repetition\",\n            expression: _1,\n            quantifier: _2\n          }, __loc);\n        }\n      }], [8, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = { kind: \"^\" };\n      }], [8, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = { kind: \"$\" };\n      }], [8, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = { kind: \"\\\\b\" };\n      }], [8, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = { kind: \"\\\\B\" };\n      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = {\n          kind: \"Lookahead\",\n          assertion: _2\n        };\n      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = {\n          kind: \"Lookahead\",\n          negative: true,\n          assertion: _2\n        };\n      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = {\n          kind: \"Lookbehind\",\n          assertion: _2\n        };\n      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = {\n          kind: \"Lookbehind\",\n          negative: true,\n          assertion: _2\n        };\n      }], [9, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [9, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [9, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"simple\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1.slice(1), \"simple\", __loc);\n        __.escaped = true;\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"unicode\", __loc);\n        __.isSurrogatePair = true;\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"unicode\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = UnicodeProperty(_1, __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"control\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"hex\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"oct\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = GroupRefOrDecChar(_1, __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"meta\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"meta\", __loc);\n      }], [10, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = NamedGroupRefOrChars(_1, _1loc);\n      }], [11, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [11, 0], [12, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [12, 2, function(_1, _2, _1loc, _2loc) {\n        __loc = yyloc(_1loc, _2loc);\n        _1.greedy = false;\n        __ = _1;\n      }], [13, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Node({\n          type: \"Quantifier\",\n          kind: _1,\n          greedy: true\n        }, __loc);\n      }], [13, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Node({\n          type: \"Quantifier\",\n          kind: _1,\n          greedy: true\n        }, __loc);\n      }], [13, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Node({\n          type: \"Quantifier\",\n          kind: _1,\n          greedy: true\n        }, __loc);\n      }], [13, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        var range = getRange(_1);\n        __ = Node({\n          type: \"Quantifier\",\n          kind: \"Range\",\n          from: range[0],\n          to: range[0],\n          greedy: true\n        }, __loc);\n      }], [13, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Node({\n          type: \"Quantifier\",\n          kind: \"Range\",\n          from: getRange(_1)[0],\n          greedy: true\n        }, __loc);\n      }], [13, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        var range = getRange(_1);\n        __ = Node({\n          type: \"Quantifier\",\n          kind: \"Range\",\n          from: range[0],\n          to: range[1],\n          greedy: true\n        }, __loc);\n      }], [14, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [14, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        var nameRaw = String(_1);\n        var name = decodeUnicodeGroupName(nameRaw);\n        if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {\n          throw new SyntaxError('Duplicate of the named group \"' + name + '\".');\n        }\n        namedGroups[name] = _1.groupNumber;\n        __ = Node({\n          type: \"Group\",\n          capturing: true,\n          name,\n          nameRaw,\n          number: _1.groupNumber,\n          expression: _2\n        }, __loc);\n      }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = Node({\n          type: \"Group\",\n          capturing: true,\n          number: _1.groupNumber,\n          expression: _2\n        }, __loc);\n      }], [16, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = Node({\n          type: \"Group\",\n          capturing: false,\n          expression: _2\n        }, __loc);\n      }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = Node({\n          type: \"CharacterClass\",\n          negative: true,\n          expressions: _2\n        }, __loc);\n      }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {\n        __loc = yyloc(_1loc, _3loc);\n        __ = Node({\n          type: \"CharacterClass\",\n          expressions: _2\n        }, __loc);\n      }], [18, 0, function() {\n        __loc = null;\n        __ = [];\n      }], [18, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [19, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = [_1];\n      }], [19, 2, function(_1, _2, _1loc, _2loc) {\n        __loc = yyloc(_1loc, _2loc);\n        __ = [_1].concat(_2);\n      }], [19, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {\n        __loc = yyloc(_1loc, _4loc);\n        checkClassRange(_1, _3);\n        __ = [Node({\n          type: \"ClassRange\",\n          from: _1,\n          to: _3\n        }, loc(_1loc, _3loc))];\n        if (_4) {\n          __ = __.concat(_4);\n        }\n      }], [20, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [20, 2, function(_1, _2, _1loc, _2loc) {\n        __loc = yyloc(_1loc, _2loc);\n        __ = [_1].concat(_2);\n      }], [20, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {\n        __loc = yyloc(_1loc, _4loc);\n        checkClassRange(_1, _3);\n        __ = [Node({\n          type: \"ClassRange\",\n          from: _1,\n          to: _3\n        }, loc(_1loc, _3loc))];\n        if (_4) {\n          __ = __.concat(_4);\n        }\n      }], [21, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"simple\", __loc);\n      }], [21, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [22, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = _1;\n      }], [22, 1, function(_1, _1loc) {\n        __loc = yyloc(_1loc, _1loc);\n        __ = Char(_1, \"meta\", __loc);\n      }]];\n      var tokens = { SLASH: \"23\", CHAR: \"24\", BAR: \"25\", BOS: \"26\", EOS: \"27\", ESC_b: \"28\", ESC_B: \"29\", POS_LA_ASSERT: \"30\", R_PAREN: \"31\", NEG_LA_ASSERT: \"32\", POS_LB_ASSERT: \"33\", NEG_LB_ASSERT: \"34\", ESC_CHAR: \"35\", U_CODE_SURROGATE: \"36\", U_CODE: \"37\", U_PROP_VALUE_EXP: \"38\", CTRL_CH: \"39\", HEX_CODE: \"40\", OCT_CODE: \"41\", DEC_CODE: \"42\", META_CHAR: \"43\", ANY: \"44\", NAMED_GROUP_REF: \"45\", Q_MARK: \"46\", STAR: \"47\", PLUS: \"48\", RANGE_EXACT: \"49\", RANGE_OPEN: \"50\", RANGE_CLOSED: \"51\", NAMED_CAPTURE_GROUP: \"52\", L_PAREN: \"53\", NON_CAPTURE_GROUP: \"54\", NEG_CLASS: \"55\", R_BRACKET: \"56\", L_BRACKET: \"57\", DASH: \"58\", $: \"59\" };\n      var table = [{ \"0\": 1, \"23\": \"s2\" }, { \"59\": \"acc\" }, { \"3\": 3, \"4\": 4, \"5\": 5, \"6\": 6, \"23\": \"r10\", \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"23\": \"s7\" }, { \"23\": \"r6\", \"25\": \"s12\" }, { \"23\": \"r7\", \"25\": \"r7\", \"31\": \"r7\" }, { \"7\": 14, \"8\": 15, \"9\": 16, \"10\": 25, \"14\": 27, \"15\": 42, \"16\": 43, \"17\": 26, \"23\": \"r9\", \"24\": \"s28\", \"25\": \"r9\", \"26\": \"s17\", \"27\": \"s18\", \"28\": \"s19\", \"29\": \"s20\", \"30\": \"s21\", \"31\": \"r9\", \"32\": \"s22\", \"33\": \"s23\", \"34\": \"s24\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"52\": \"s44\", \"53\": \"s45\", \"54\": \"s46\", \"55\": \"s40\", \"57\": \"s41\" }, { \"1\": 8, \"2\": 9, \"24\": \"s10\", \"59\": \"r3\" }, { \"59\": \"r1\" }, { \"24\": \"s11\", \"59\": \"r2\" }, { \"24\": \"r4\", \"59\": \"r4\" }, { \"24\": \"r5\", \"59\": \"r5\" }, { \"5\": 13, \"6\": 6, \"23\": \"r10\", \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"23\": \"r8\", \"25\": \"r8\", \"31\": \"r8\" }, { \"23\": \"r11\", \"24\": \"r11\", \"25\": \"r11\", \"26\": \"r11\", \"27\": \"r11\", \"28\": \"r11\", \"29\": \"r11\", \"30\": \"r11\", \"31\": \"r11\", \"32\": \"r11\", \"33\": \"r11\", \"34\": \"r11\", \"35\": \"r11\", \"36\": \"r11\", \"37\": \"r11\", \"38\": \"r11\", \"39\": \"r11\", \"40\": \"r11\", \"41\": \"r11\", \"42\": \"r11\", \"43\": \"r11\", \"44\": \"r11\", \"45\": \"r11\", \"52\": \"r11\", \"53\": \"r11\", \"54\": \"r11\", \"55\": \"r11\", \"57\": \"r11\" }, { \"23\": \"r12\", \"24\": \"r12\", \"25\": \"r12\", \"26\": \"r12\", \"27\": \"r12\", \"28\": \"r12\", \"29\": \"r12\", \"30\": \"r12\", \"31\": \"r12\", \"32\": \"r12\", \"33\": \"r12\", \"34\": \"r12\", \"35\": \"r12\", \"36\": \"r12\", \"37\": \"r12\", \"38\": \"r12\", \"39\": \"r12\", \"40\": \"r12\", \"41\": \"r12\", \"42\": \"r12\", \"43\": \"r12\", \"44\": \"r12\", \"45\": \"r12\", \"52\": \"r12\", \"53\": \"r12\", \"54\": \"r12\", \"55\": \"r12\", \"57\": \"r12\" }, { \"11\": 47, \"12\": 48, \"13\": 49, \"23\": \"r38\", \"24\": \"r38\", \"25\": \"r38\", \"26\": \"r38\", \"27\": \"r38\", \"28\": \"r38\", \"29\": \"r38\", \"30\": \"r38\", \"31\": \"r38\", \"32\": \"r38\", \"33\": \"r38\", \"34\": \"r38\", \"35\": \"r38\", \"36\": \"r38\", \"37\": \"r38\", \"38\": \"r38\", \"39\": \"r38\", \"40\": \"r38\", \"41\": \"r38\", \"42\": \"r38\", \"43\": \"r38\", \"44\": \"r38\", \"45\": \"r38\", \"46\": \"s52\", \"47\": \"s50\", \"48\": \"s51\", \"49\": \"s53\", \"50\": \"s54\", \"51\": \"s55\", \"52\": \"r38\", \"53\": \"r38\", \"54\": \"r38\", \"55\": \"r38\", \"57\": \"r38\" }, { \"23\": \"r14\", \"24\": \"r14\", \"25\": \"r14\", \"26\": \"r14\", \"27\": \"r14\", \"28\": \"r14\", \"29\": \"r14\", \"30\": \"r14\", \"31\": \"r14\", \"32\": \"r14\", \"33\": \"r14\", \"34\": \"r14\", \"35\": \"r14\", \"36\": \"r14\", \"37\": \"r14\", \"38\": \"r14\", \"39\": \"r14\", \"40\": \"r14\", \"41\": \"r14\", \"42\": \"r14\", \"43\": \"r14\", \"44\": \"r14\", \"45\": \"r14\", \"52\": \"r14\", \"53\": \"r14\", \"54\": \"r14\", \"55\": \"r14\", \"57\": \"r14\" }, { \"23\": \"r15\", \"24\": \"r15\", \"25\": \"r15\", \"26\": \"r15\", \"27\": \"r15\", \"28\": \"r15\", \"29\": \"r15\", \"30\": \"r15\", \"31\": \"r15\", \"32\": \"r15\", \"33\": \"r15\", \"34\": \"r15\", \"35\": \"r15\", \"36\": \"r15\", \"37\": \"r15\", \"38\": \"r15\", \"39\": \"r15\", \"40\": \"r15\", \"41\": \"r15\", \"42\": \"r15\", \"43\": \"r15\", \"44\": \"r15\", \"45\": \"r15\", \"52\": \"r15\", \"53\": \"r15\", \"54\": \"r15\", \"55\": \"r15\", \"57\": \"r15\" }, { \"23\": \"r16\", \"24\": \"r16\", \"25\": \"r16\", \"26\": \"r16\", \"27\": \"r16\", \"28\": \"r16\", \"29\": \"r16\", \"30\": \"r16\", \"31\": \"r16\", \"32\": \"r16\", \"33\": \"r16\", \"34\": \"r16\", \"35\": \"r16\", \"36\": \"r16\", \"37\": \"r16\", \"38\": \"r16\", \"39\": \"r16\", \"40\": \"r16\", \"41\": \"r16\", \"42\": \"r16\", \"43\": \"r16\", \"44\": \"r16\", \"45\": \"r16\", \"52\": \"r16\", \"53\": \"r16\", \"54\": \"r16\", \"55\": \"r16\", \"57\": \"r16\" }, { \"23\": \"r17\", \"24\": \"r17\", \"25\": \"r17\", \"26\": \"r17\", \"27\": \"r17\", \"28\": \"r17\", \"29\": \"r17\", \"30\": \"r17\", \"31\": \"r17\", \"32\": \"r17\", \"33\": \"r17\", \"34\": \"r17\", \"35\": \"r17\", \"36\": \"r17\", \"37\": \"r17\", \"38\": \"r17\", \"39\": \"r17\", \"40\": \"r17\", \"41\": \"r17\", \"42\": \"r17\", \"43\": \"r17\", \"44\": \"r17\", \"45\": \"r17\", \"52\": \"r17\", \"53\": \"r17\", \"54\": \"r17\", \"55\": \"r17\", \"57\": \"r17\" }, { \"4\": 57, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"4\": 59, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"4\": 61, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"4\": 63, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"23\": \"r22\", \"24\": \"r22\", \"25\": \"r22\", \"26\": \"r22\", \"27\": \"r22\", \"28\": \"r22\", \"29\": \"r22\", \"30\": \"r22\", \"31\": \"r22\", \"32\": \"r22\", \"33\": \"r22\", \"34\": \"r22\", \"35\": \"r22\", \"36\": \"r22\", \"37\": \"r22\", \"38\": \"r22\", \"39\": \"r22\", \"40\": \"r22\", \"41\": \"r22\", \"42\": \"r22\", \"43\": \"r22\", \"44\": \"r22\", \"45\": \"r22\", \"46\": \"r22\", \"47\": \"r22\", \"48\": \"r22\", \"49\": \"r22\", \"50\": \"r22\", \"51\": \"r22\", \"52\": \"r22\", \"53\": \"r22\", \"54\": \"r22\", \"55\": \"r22\", \"57\": \"r22\" }, { \"23\": \"r23\", \"24\": \"r23\", \"25\": \"r23\", \"26\": \"r23\", \"27\": \"r23\", \"28\": \"r23\", \"29\": \"r23\", \"30\": \"r23\", \"31\": \"r23\", \"32\": \"r23\", \"33\": \"r23\", \"34\": \"r23\", \"35\": \"r23\", \"36\": \"r23\", \"37\": \"r23\", \"38\": \"r23\", \"39\": \"r23\", \"40\": \"r23\", \"41\": \"r23\", \"42\": \"r23\", \"43\": \"r23\", \"44\": \"r23\", \"45\": \"r23\", \"46\": \"r23\", \"47\": \"r23\", \"48\": \"r23\", \"49\": \"r23\", \"50\": \"r23\", \"51\": \"r23\", \"52\": \"r23\", \"53\": \"r23\", \"54\": \"r23\", \"55\": \"r23\", \"57\": \"r23\" }, { \"23\": \"r24\", \"24\": \"r24\", \"25\": \"r24\", \"26\": \"r24\", \"27\": \"r24\", \"28\": \"r24\", \"29\": \"r24\", \"30\": \"r24\", \"31\": \"r24\", \"32\": \"r24\", \"33\": \"r24\", \"34\": \"r24\", \"35\": \"r24\", \"36\": \"r24\", \"37\": \"r24\", \"38\": \"r24\", \"39\": \"r24\", \"40\": \"r24\", \"41\": \"r24\", \"42\": \"r24\", \"43\": \"r24\", \"44\": \"r24\", \"45\": \"r24\", \"46\": \"r24\", \"47\": \"r24\", \"48\": \"r24\", \"49\": \"r24\", \"50\": \"r24\", \"51\": \"r24\", \"52\": \"r24\", \"53\": \"r24\", \"54\": \"r24\", \"55\": \"r24\", \"57\": \"r24\" }, { \"23\": \"r25\", \"24\": \"r25\", \"25\": \"r25\", \"26\": \"r25\", \"27\": \"r25\", \"28\": \"r25\", \"29\": \"r25\", \"30\": \"r25\", \"31\": \"r25\", \"32\": \"r25\", \"33\": \"r25\", \"34\": \"r25\", \"35\": \"r25\", \"36\": \"r25\", \"37\": \"r25\", \"38\": \"r25\", \"39\": \"r25\", \"40\": \"r25\", \"41\": \"r25\", \"42\": \"r25\", \"43\": \"r25\", \"44\": \"r25\", \"45\": \"r25\", \"46\": \"r25\", \"47\": \"r25\", \"48\": \"r25\", \"49\": \"r25\", \"50\": \"r25\", \"51\": \"r25\", \"52\": \"r25\", \"53\": \"r25\", \"54\": \"r25\", \"55\": \"r25\", \"56\": \"r25\", \"57\": \"r25\", \"58\": \"r25\" }, { \"23\": \"r26\", \"24\": \"r26\", \"25\": \"r26\", \"26\": \"r26\", \"27\": \"r26\", \"28\": \"r26\", \"29\": \"r26\", \"30\": \"r26\", \"31\": \"r26\", \"32\": \"r26\", \"33\": \"r26\", \"34\": \"r26\", \"35\": \"r26\", \"36\": \"r26\", \"37\": \"r26\", \"38\": \"r26\", \"39\": \"r26\", \"40\": \"r26\", \"41\": \"r26\", \"42\": \"r26\", \"43\": \"r26\", \"44\": \"r26\", \"45\": \"r26\", \"46\": \"r26\", \"47\": \"r26\", \"48\": \"r26\", \"49\": \"r26\", \"50\": \"r26\", \"51\": \"r26\", \"52\": \"r26\", \"53\": \"r26\", \"54\": \"r26\", \"55\": \"r26\", \"56\": \"r26\", \"57\": \"r26\", \"58\": \"r26\" }, { \"23\": \"r27\", \"24\": \"r27\", \"25\": \"r27\", \"26\": \"r27\", \"27\": \"r27\", \"28\": \"r27\", \"29\": \"r27\", \"30\": \"r27\", \"31\": \"r27\", \"32\": \"r27\", \"33\": \"r27\", \"34\": \"r27\", \"35\": \"r27\", \"36\": \"r27\", \"37\": \"r27\", \"38\": \"r27\", \"39\": \"r27\", \"40\": \"r27\", \"41\": \"r27\", \"42\": \"r27\", \"43\": \"r27\", \"44\": \"r27\", \"45\": \"r27\", \"46\": \"r27\", \"47\": \"r27\", \"48\": \"r27\", \"49\": \"r27\", \"50\": \"r27\", \"51\": \"r27\", \"52\": \"r27\", \"53\": \"r27\", \"54\": \"r27\", \"55\": \"r27\", \"56\": \"r27\", \"57\": \"r27\", \"58\": \"r27\" }, { \"23\": \"r28\", \"24\": \"r28\", \"25\": \"r28\", \"26\": \"r28\", \"27\": \"r28\", \"28\": \"r28\", \"29\": \"r28\", \"30\": \"r28\", \"31\": \"r28\", \"32\": \"r28\", \"33\": \"r28\", \"34\": \"r28\", \"35\": \"r28\", \"36\": \"r28\", \"37\": \"r28\", \"38\": \"r28\", \"39\": \"r28\", \"40\": \"r28\", \"41\": \"r28\", \"42\": \"r28\", \"43\": \"r28\", \"44\": \"r28\", \"45\": \"r28\", \"46\": \"r28\", \"47\": \"r28\", \"48\": \"r28\", \"49\": \"r28\", \"50\": \"r28\", \"51\": \"r28\", \"52\": \"r28\", \"53\": \"r28\", \"54\": \"r28\", \"55\": \"r28\", \"56\": \"r28\", \"57\": \"r28\", \"58\": \"r28\" }, { \"23\": \"r29\", \"24\": \"r29\", \"25\": \"r29\", \"26\": \"r29\", \"27\": \"r29\", \"28\": \"r29\", \"29\": \"r29\", \"30\": \"r29\", \"31\": \"r29\", \"32\": \"r29\", \"33\": \"r29\", \"34\": \"r29\", \"35\": \"r29\", \"36\": \"r29\", \"37\": \"r29\", \"38\": \"r29\", \"39\": \"r29\", \"40\": \"r29\", \"41\": \"r29\", \"42\": \"r29\", \"43\": \"r29\", \"44\": \"r29\", \"45\": \"r29\", \"46\": \"r29\", \"47\": \"r29\", \"48\": \"r29\", \"49\": \"r29\", \"50\": \"r29\", \"51\": \"r29\", \"52\": \"r29\", \"53\": \"r29\", \"54\": \"r29\", \"55\": \"r29\", \"56\": \"r29\", \"57\": \"r29\", \"58\": \"r29\" }, { \"23\": \"r30\", \"24\": \"r30\", \"25\": \"r30\", \"26\": \"r30\", \"27\": \"r30\", \"28\": \"r30\", \"29\": \"r30\", \"30\": \"r30\", \"31\": \"r30\", \"32\": \"r30\", \"33\": \"r30\", \"34\": \"r30\", \"35\": \"r30\", \"36\": \"r30\", \"37\": \"r30\", \"38\": \"r30\", \"39\": \"r30\", \"40\": \"r30\", \"41\": \"r30\", \"42\": \"r30\", \"43\": \"r30\", \"44\": \"r30\", \"45\": \"r30\", \"46\": \"r30\", \"47\": \"r30\", \"48\": \"r30\", \"49\": \"r30\", \"50\": \"r30\", \"51\": \"r30\", \"52\": \"r30\", \"53\": \"r30\", \"54\": \"r30\", \"55\": \"r30\", \"56\": \"r30\", \"57\": \"r30\", \"58\": \"r30\" }, { \"23\": \"r31\", \"24\": \"r31\", \"25\": \"r31\", \"26\": \"r31\", \"27\": \"r31\", \"28\": \"r31\", \"29\": \"r31\", \"30\": \"r31\", \"31\": \"r31\", \"32\": \"r31\", \"33\": \"r31\", \"34\": \"r31\", \"35\": \"r31\", \"36\": \"r31\", \"37\": \"r31\", \"38\": \"r31\", \"39\": \"r31\", \"40\": \"r31\", \"41\": \"r31\", \"42\": \"r31\", \"43\": \"r31\", \"44\": \"r31\", \"45\": \"r31\", \"46\": \"r31\", \"47\": \"r31\", \"48\": \"r31\", \"49\": \"r31\", \"50\": \"r31\", \"51\": \"r31\", \"52\": \"r31\", \"53\": \"r31\", \"54\": \"r31\", \"55\": \"r31\", \"56\": \"r31\", \"57\": \"r31\", \"58\": \"r31\" }, { \"23\": \"r32\", \"24\": \"r32\", \"25\": \"r32\", \"26\": \"r32\", \"27\": \"r32\", \"28\": \"r32\", \"29\": \"r32\", \"30\": \"r32\", \"31\": \"r32\", \"32\": \"r32\", \"33\": \"r32\", \"34\": \"r32\", \"35\": \"r32\", \"36\": \"r32\", \"37\": \"r32\", \"38\": \"r32\", \"39\": \"r32\", \"40\": \"r32\", \"41\": \"r32\", \"42\": \"r32\", \"43\": \"r32\", \"44\": \"r32\", \"45\": \"r32\", \"46\": \"r32\", \"47\": \"r32\", \"48\": \"r32\", \"49\": \"r32\", \"50\": \"r32\", \"51\": \"r32\", \"52\": \"r32\", \"53\": \"r32\", \"54\": \"r32\", \"55\": \"r32\", \"56\": \"r32\", \"57\": \"r32\", \"58\": \"r32\" }, { \"23\": \"r33\", \"24\": \"r33\", \"25\": \"r33\", \"26\": \"r33\", \"27\": \"r33\", \"28\": \"r33\", \"29\": \"r33\", \"30\": \"r33\", \"31\": \"r33\", \"32\": \"r33\", \"33\": \"r33\", \"34\": \"r33\", \"35\": \"r33\", \"36\": \"r33\", \"37\": \"r33\", \"38\": \"r33\", \"39\": \"r33\", \"40\": \"r33\", \"41\": \"r33\", \"42\": \"r33\", \"43\": \"r33\", \"44\": \"r33\", \"45\": \"r33\", \"46\": \"r33\", \"47\": \"r33\", \"48\": \"r33\", \"49\": \"r33\", \"50\": \"r33\", \"51\": \"r33\", \"52\": \"r33\", \"53\": \"r33\", \"54\": \"r33\", \"55\": \"r33\", \"56\": \"r33\", \"57\": \"r33\", \"58\": \"r33\" }, { \"23\": \"r34\", \"24\": \"r34\", \"25\": \"r34\", \"26\": \"r34\", \"27\": \"r34\", \"28\": \"r34\", \"29\": \"r34\", \"30\": \"r34\", \"31\": \"r34\", \"32\": \"r34\", \"33\": \"r34\", \"34\": \"r34\", \"35\": \"r34\", \"36\": \"r34\", \"37\": \"r34\", \"38\": \"r34\", \"39\": \"r34\", \"40\": \"r34\", \"41\": \"r34\", \"42\": \"r34\", \"43\": \"r34\", \"44\": \"r34\", \"45\": \"r34\", \"46\": \"r34\", \"47\": \"r34\", \"48\": \"r34\", \"49\": \"r34\", \"50\": \"r34\", \"51\": \"r34\", \"52\": \"r34\", \"53\": \"r34\", \"54\": \"r34\", \"55\": \"r34\", \"56\": \"r34\", \"57\": \"r34\", \"58\": \"r34\" }, { \"23\": \"r35\", \"24\": \"r35\", \"25\": \"r35\", \"26\": \"r35\", \"27\": \"r35\", \"28\": \"r35\", \"29\": \"r35\", \"30\": \"r35\", \"31\": \"r35\", \"32\": \"r35\", \"33\": \"r35\", \"34\": \"r35\", \"35\": \"r35\", \"36\": \"r35\", \"37\": \"r35\", \"38\": \"r35\", \"39\": \"r35\", \"40\": \"r35\", \"41\": \"r35\", \"42\": \"r35\", \"43\": \"r35\", \"44\": \"r35\", \"45\": \"r35\", \"46\": \"r35\", \"47\": \"r35\", \"48\": \"r35\", \"49\": \"r35\", \"50\": \"r35\", \"51\": \"r35\", \"52\": \"r35\", \"53\": \"r35\", \"54\": \"r35\", \"55\": \"r35\", \"56\": \"r35\", \"57\": \"r35\", \"58\": \"r35\" }, { \"23\": \"r36\", \"24\": \"r36\", \"25\": \"r36\", \"26\": \"r36\", \"27\": \"r36\", \"28\": \"r36\", \"29\": \"r36\", \"30\": \"r36\", \"31\": \"r36\", \"32\": \"r36\", \"33\": \"r36\", \"34\": \"r36\", \"35\": \"r36\", \"36\": \"r36\", \"37\": \"r36\", \"38\": \"r36\", \"39\": \"r36\", \"40\": \"r36\", \"41\": \"r36\", \"42\": \"r36\", \"43\": \"r36\", \"44\": \"r36\", \"45\": \"r36\", \"46\": \"r36\", \"47\": \"r36\", \"48\": \"r36\", \"49\": \"r36\", \"50\": \"r36\", \"51\": \"r36\", \"52\": \"r36\", \"53\": \"r36\", \"54\": \"r36\", \"55\": \"r36\", \"56\": \"r36\", \"57\": \"r36\", \"58\": \"r36\" }, { \"10\": 70, \"18\": 65, \"19\": 66, \"21\": 67, \"22\": 69, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r54\", \"58\": \"s68\" }, { \"10\": 70, \"18\": 83, \"19\": 66, \"21\": 67, \"22\": 69, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r54\", \"58\": \"s68\" }, { \"23\": \"r47\", \"24\": \"r47\", \"25\": \"r47\", \"26\": \"r47\", \"27\": \"r47\", \"28\": \"r47\", \"29\": \"r47\", \"30\": \"r47\", \"31\": \"r47\", \"32\": \"r47\", \"33\": \"r47\", \"34\": \"r47\", \"35\": \"r47\", \"36\": \"r47\", \"37\": \"r47\", \"38\": \"r47\", \"39\": \"r47\", \"40\": \"r47\", \"41\": \"r47\", \"42\": \"r47\", \"43\": \"r47\", \"44\": \"r47\", \"45\": \"r47\", \"46\": \"r47\", \"47\": \"r47\", \"48\": \"r47\", \"49\": \"r47\", \"50\": \"r47\", \"51\": \"r47\", \"52\": \"r47\", \"53\": \"r47\", \"54\": \"r47\", \"55\": \"r47\", \"57\": \"r47\" }, { \"23\": \"r48\", \"24\": \"r48\", \"25\": \"r48\", \"26\": \"r48\", \"27\": \"r48\", \"28\": \"r48\", \"29\": \"r48\", \"30\": \"r48\", \"31\": \"r48\", \"32\": \"r48\", \"33\": \"r48\", \"34\": \"r48\", \"35\": \"r48\", \"36\": \"r48\", \"37\": \"r48\", \"38\": \"r48\", \"39\": \"r48\", \"40\": \"r48\", \"41\": \"r48\", \"42\": \"r48\", \"43\": \"r48\", \"44\": \"r48\", \"45\": \"r48\", \"46\": \"r48\", \"47\": \"r48\", \"48\": \"r48\", \"49\": \"r48\", \"50\": \"r48\", \"51\": \"r48\", \"52\": \"r48\", \"53\": \"r48\", \"54\": \"r48\", \"55\": \"r48\", \"57\": \"r48\" }, { \"4\": 85, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"4\": 87, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"4\": 89, \"5\": 5, \"6\": 6, \"24\": \"r10\", \"25\": \"r10\", \"26\": \"r10\", \"27\": \"r10\", \"28\": \"r10\", \"29\": \"r10\", \"30\": \"r10\", \"31\": \"r10\", \"32\": \"r10\", \"33\": \"r10\", \"34\": \"r10\", \"35\": \"r10\", \"36\": \"r10\", \"37\": \"r10\", \"38\": \"r10\", \"39\": \"r10\", \"40\": \"r10\", \"41\": \"r10\", \"42\": \"r10\", \"43\": \"r10\", \"44\": \"r10\", \"45\": \"r10\", \"52\": \"r10\", \"53\": \"r10\", \"54\": \"r10\", \"55\": \"r10\", \"57\": \"r10\" }, { \"23\": \"r13\", \"24\": \"r13\", \"25\": \"r13\", \"26\": \"r13\", \"27\": \"r13\", \"28\": \"r13\", \"29\": \"r13\", \"30\": \"r13\", \"31\": \"r13\", \"32\": \"r13\", \"33\": \"r13\", \"34\": \"r13\", \"35\": \"r13\", \"36\": \"r13\", \"37\": \"r13\", \"38\": \"r13\", \"39\": \"r13\", \"40\": \"r13\", \"41\": \"r13\", \"42\": \"r13\", \"43\": \"r13\", \"44\": \"r13\", \"45\": \"r13\", \"52\": \"r13\", \"53\": \"r13\", \"54\": \"r13\", \"55\": \"r13\", \"57\": \"r13\" }, { \"23\": \"r37\", \"24\": \"r37\", \"25\": \"r37\", \"26\": \"r37\", \"27\": \"r37\", \"28\": \"r37\", \"29\": \"r37\", \"30\": \"r37\", \"31\": \"r37\", \"32\": \"r37\", \"33\": \"r37\", \"34\": \"r37\", \"35\": \"r37\", \"36\": \"r37\", \"37\": \"r37\", \"38\": \"r37\", \"39\": \"r37\", \"40\": \"r37\", \"41\": \"r37\", \"42\": \"r37\", \"43\": \"r37\", \"44\": \"r37\", \"45\": \"r37\", \"52\": \"r37\", \"53\": \"r37\", \"54\": \"r37\", \"55\": \"r37\", \"57\": \"r37\" }, { \"23\": \"r39\", \"24\": \"r39\", \"25\": \"r39\", \"26\": \"r39\", \"27\": \"r39\", \"28\": \"r39\", \"29\": \"r39\", \"30\": \"r39\", \"31\": \"r39\", \"32\": \"r39\", \"33\": \"r39\", \"34\": \"r39\", \"35\": \"r39\", \"36\": \"r39\", \"37\": \"r39\", \"38\": \"r39\", \"39\": \"r39\", \"40\": \"r39\", \"41\": \"r39\", \"42\": \"r39\", \"43\": \"r39\", \"44\": \"r39\", \"45\": \"r39\", \"46\": \"s56\", \"52\": \"r39\", \"53\": \"r39\", \"54\": \"r39\", \"55\": \"r39\", \"57\": \"r39\" }, { \"23\": \"r41\", \"24\": \"r41\", \"25\": \"r41\", \"26\": \"r41\", \"27\": \"r41\", \"28\": \"r41\", \"29\": \"r41\", \"30\": \"r41\", \"31\": \"r41\", \"32\": \"r41\", \"33\": \"r41\", \"34\": \"r41\", \"35\": \"r41\", \"36\": \"r41\", \"37\": \"r41\", \"38\": \"r41\", \"39\": \"r41\", \"40\": \"r41\", \"41\": \"r41\", \"42\": \"r41\", \"43\": \"r41\", \"44\": \"r41\", \"45\": \"r41\", \"46\": \"r41\", \"52\": \"r41\", \"53\": \"r41\", \"54\": \"r41\", \"55\": \"r41\", \"57\": \"r41\" }, { \"23\": \"r42\", \"24\": \"r42\", \"25\": \"r42\", \"26\": \"r42\", \"27\": \"r42\", \"28\": \"r42\", \"29\": \"r42\", \"30\": \"r42\", \"31\": \"r42\", \"32\": \"r42\", \"33\": \"r42\", \"34\": \"r42\", \"35\": \"r42\", \"36\": \"r42\", \"37\": \"r42\", \"38\": \"r42\", \"39\": \"r42\", \"40\": \"r42\", \"41\": \"r42\", \"42\": \"r42\", \"43\": \"r42\", \"44\": \"r42\", \"45\": \"r42\", \"46\": \"r42\", \"52\": \"r42\", \"53\": \"r42\", \"54\": \"r42\", \"55\": \"r42\", \"57\": \"r42\" }, { \"23\": \"r43\", \"24\": \"r43\", \"25\": \"r43\", \"26\": \"r43\", \"27\": \"r43\", \"28\": \"r43\", \"29\": \"r43\", \"30\": \"r43\", \"31\": \"r43\", \"32\": \"r43\", \"33\": \"r43\", \"34\": \"r43\", \"35\": \"r43\", \"36\": \"r43\", \"37\": \"r43\", \"38\": \"r43\", \"39\": \"r43\", \"40\": \"r43\", \"41\": \"r43\", \"42\": \"r43\", \"43\": \"r43\", \"44\": \"r43\", \"45\": \"r43\", \"46\": \"r43\", \"52\": \"r43\", \"53\": \"r43\", \"54\": \"r43\", \"55\": \"r43\", \"57\": \"r43\" }, { \"23\": \"r44\", \"24\": \"r44\", \"25\": \"r44\", \"26\": \"r44\", \"27\": \"r44\", \"28\": \"r44\", \"29\": \"r44\", \"30\": \"r44\", \"31\": \"r44\", \"32\": \"r44\", \"33\": \"r44\", \"34\": \"r44\", \"35\": \"r44\", \"36\": \"r44\", \"37\": \"r44\", \"38\": \"r44\", \"39\": \"r44\", \"40\": \"r44\", \"41\": \"r44\", \"42\": \"r44\", \"43\": \"r44\", \"44\": \"r44\", \"45\": \"r44\", \"46\": \"r44\", \"52\": \"r44\", \"53\": \"r44\", \"54\": \"r44\", \"55\": \"r44\", \"57\": \"r44\" }, { \"23\": \"r45\", \"24\": \"r45\", \"25\": \"r45\", \"26\": \"r45\", \"27\": \"r45\", \"28\": \"r45\", \"29\": \"r45\", \"30\": \"r45\", \"31\": \"r45\", \"32\": \"r45\", \"33\": \"r45\", \"34\": \"r45\", \"35\": \"r45\", \"36\": \"r45\", \"37\": \"r45\", \"38\": \"r45\", \"39\": \"r45\", \"40\": \"r45\", \"41\": \"r45\", \"42\": \"r45\", \"43\": \"r45\", \"44\": \"r45\", \"45\": \"r45\", \"46\": \"r45\", \"52\": \"r45\", \"53\": \"r45\", \"54\": \"r45\", \"55\": \"r45\", \"57\": \"r45\" }, { \"23\": \"r46\", \"24\": \"r46\", \"25\": \"r46\", \"26\": \"r46\", \"27\": \"r46\", \"28\": \"r46\", \"29\": \"r46\", \"30\": \"r46\", \"31\": \"r46\", \"32\": \"r46\", \"33\": \"r46\", \"34\": \"r46\", \"35\": \"r46\", \"36\": \"r46\", \"37\": \"r46\", \"38\": \"r46\", \"39\": \"r46\", \"40\": \"r46\", \"41\": \"r46\", \"42\": \"r46\", \"43\": \"r46\", \"44\": \"r46\", \"45\": \"r46\", \"46\": \"r46\", \"52\": \"r46\", \"53\": \"r46\", \"54\": \"r46\", \"55\": \"r46\", \"57\": \"r46\" }, { \"23\": \"r40\", \"24\": \"r40\", \"25\": \"r40\", \"26\": \"r40\", \"27\": \"r40\", \"28\": \"r40\", \"29\": \"r40\", \"30\": \"r40\", \"31\": \"r40\", \"32\": \"r40\", \"33\": \"r40\", \"34\": \"r40\", \"35\": \"r40\", \"36\": \"r40\", \"37\": \"r40\", \"38\": \"r40\", \"39\": \"r40\", \"40\": \"r40\", \"41\": \"r40\", \"42\": \"r40\", \"43\": \"r40\", \"44\": \"r40\", \"45\": \"r40\", \"52\": \"r40\", \"53\": \"r40\", \"54\": \"r40\", \"55\": \"r40\", \"57\": \"r40\" }, { \"25\": \"s12\", \"31\": \"s58\" }, { \"23\": \"r18\", \"24\": \"r18\", \"25\": \"r18\", \"26\": \"r18\", \"27\": \"r18\", \"28\": \"r18\", \"29\": \"r18\", \"30\": \"r18\", \"31\": \"r18\", \"32\": \"r18\", \"33\": \"r18\", \"34\": \"r18\", \"35\": \"r18\", \"36\": \"r18\", \"37\": \"r18\", \"38\": \"r18\", \"39\": \"r18\", \"40\": \"r18\", \"41\": \"r18\", \"42\": \"r18\", \"43\": \"r18\", \"44\": \"r18\", \"45\": \"r18\", \"52\": \"r18\", \"53\": \"r18\", \"54\": \"r18\", \"55\": \"r18\", \"57\": \"r18\" }, { \"25\": \"s12\", \"31\": \"s60\" }, { \"23\": \"r19\", \"24\": \"r19\", \"25\": \"r19\", \"26\": \"r19\", \"27\": \"r19\", \"28\": \"r19\", \"29\": \"r19\", \"30\": \"r19\", \"31\": \"r19\", \"32\": \"r19\", \"33\": \"r19\", \"34\": \"r19\", \"35\": \"r19\", \"36\": \"r19\", \"37\": \"r19\", \"38\": \"r19\", \"39\": \"r19\", \"40\": \"r19\", \"41\": \"r19\", \"42\": \"r19\", \"43\": \"r19\", \"44\": \"r19\", \"45\": \"r19\", \"52\": \"r19\", \"53\": \"r19\", \"54\": \"r19\", \"55\": \"r19\", \"57\": \"r19\" }, { \"25\": \"s12\", \"31\": \"s62\" }, { \"23\": \"r20\", \"24\": \"r20\", \"25\": \"r20\", \"26\": \"r20\", \"27\": \"r20\", \"28\": \"r20\", \"29\": \"r20\", \"30\": \"r20\", \"31\": \"r20\", \"32\": \"r20\", \"33\": \"r20\", \"34\": \"r20\", \"35\": \"r20\", \"36\": \"r20\", \"37\": \"r20\", \"38\": \"r20\", \"39\": \"r20\", \"40\": \"r20\", \"41\": \"r20\", \"42\": \"r20\", \"43\": \"r20\", \"44\": \"r20\", \"45\": \"r20\", \"52\": \"r20\", \"53\": \"r20\", \"54\": \"r20\", \"55\": \"r20\", \"57\": \"r20\" }, { \"25\": \"s12\", \"31\": \"s64\" }, { \"23\": \"r21\", \"24\": \"r21\", \"25\": \"r21\", \"26\": \"r21\", \"27\": \"r21\", \"28\": \"r21\", \"29\": \"r21\", \"30\": \"r21\", \"31\": \"r21\", \"32\": \"r21\", \"33\": \"r21\", \"34\": \"r21\", \"35\": \"r21\", \"36\": \"r21\", \"37\": \"r21\", \"38\": \"r21\", \"39\": \"r21\", \"40\": \"r21\", \"41\": \"r21\", \"42\": \"r21\", \"43\": \"r21\", \"44\": \"r21\", \"45\": \"r21\", \"52\": \"r21\", \"53\": \"r21\", \"54\": \"r21\", \"55\": \"r21\", \"57\": \"r21\" }, { \"56\": \"s72\" }, { \"56\": \"r55\" }, { \"10\": 70, \"20\": 73, \"21\": 75, \"22\": 76, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r56\", \"58\": \"s74\" }, { \"24\": \"r62\", \"28\": \"r62\", \"35\": \"r62\", \"36\": \"r62\", \"37\": \"r62\", \"38\": \"r62\", \"39\": \"r62\", \"40\": \"r62\", \"41\": \"r62\", \"42\": \"r62\", \"43\": \"r62\", \"44\": \"r62\", \"45\": \"r62\", \"56\": \"r62\", \"58\": \"r62\" }, { \"24\": \"r63\", \"28\": \"r63\", \"35\": \"r63\", \"36\": \"r63\", \"37\": \"r63\", \"38\": \"r63\", \"39\": \"r63\", \"40\": \"r63\", \"41\": \"r63\", \"42\": \"r63\", \"43\": \"r63\", \"44\": \"r63\", \"45\": \"r63\", \"56\": \"r63\", \"58\": \"r63\" }, { \"24\": \"r64\", \"28\": \"r64\", \"35\": \"r64\", \"36\": \"r64\", \"37\": \"r64\", \"38\": \"r64\", \"39\": \"r64\", \"40\": \"r64\", \"41\": \"r64\", \"42\": \"r64\", \"43\": \"r64\", \"44\": \"r64\", \"45\": \"r64\", \"56\": \"r64\", \"58\": \"r64\" }, { \"24\": \"r65\", \"28\": \"r65\", \"35\": \"r65\", \"36\": \"r65\", \"37\": \"r65\", \"38\": \"r65\", \"39\": \"r65\", \"40\": \"r65\", \"41\": \"r65\", \"42\": \"r65\", \"43\": \"r65\", \"44\": \"r65\", \"45\": \"r65\", \"56\": \"r65\", \"58\": \"r65\" }, { \"23\": \"r52\", \"24\": \"r52\", \"25\": \"r52\", \"26\": \"r52\", \"27\": \"r52\", \"28\": \"r52\", \"29\": \"r52\", \"30\": \"r52\", \"31\": \"r52\", \"32\": \"r52\", \"33\": \"r52\", \"34\": \"r52\", \"35\": \"r52\", \"36\": \"r52\", \"37\": \"r52\", \"38\": \"r52\", \"39\": \"r52\", \"40\": \"r52\", \"41\": \"r52\", \"42\": \"r52\", \"43\": \"r52\", \"44\": \"r52\", \"45\": \"r52\", \"46\": \"r52\", \"47\": \"r52\", \"48\": \"r52\", \"49\": \"r52\", \"50\": \"r52\", \"51\": \"r52\", \"52\": \"r52\", \"53\": \"r52\", \"54\": \"r52\", \"55\": \"r52\", \"57\": \"r52\" }, { \"56\": \"r57\" }, { \"10\": 70, \"21\": 77, \"22\": 69, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r62\", \"58\": \"s68\" }, { \"56\": \"r59\" }, { \"10\": 70, \"20\": 79, \"21\": 75, \"22\": 76, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r63\", \"58\": \"s80\" }, { \"10\": 70, \"18\": 78, \"19\": 66, \"21\": 67, \"22\": 69, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r54\", \"58\": \"s68\" }, { \"56\": \"r58\" }, { \"56\": \"r60\" }, { \"10\": 70, \"21\": 81, \"22\": 69, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r62\", \"58\": \"s68\" }, { \"10\": 70, \"18\": 82, \"19\": 66, \"21\": 67, \"22\": 69, \"24\": \"s28\", \"28\": \"s71\", \"35\": \"s29\", \"36\": \"s30\", \"37\": \"s31\", \"38\": \"s32\", \"39\": \"s33\", \"40\": \"s34\", \"41\": \"s35\", \"42\": \"s36\", \"43\": \"s37\", \"44\": \"s38\", \"45\": \"s39\", \"56\": \"r54\", \"58\": \"s68\" }, { \"56\": \"r61\" }, { \"56\": \"s84\" }, { \"23\": \"r53\", \"24\": \"r53\", \"25\": \"r53\", \"26\": \"r53\", \"27\": \"r53\", \"28\": \"r53\", \"29\": \"r53\", \"30\": \"r53\", \"31\": \"r53\", \"32\": \"r53\", \"33\": \"r53\", \"34\": \"r53\", \"35\": \"r53\", \"36\": \"r53\", \"37\": \"r53\", \"38\": \"r53\", \"39\": \"r53\", \"40\": \"r53\", \"41\": \"r53\", \"42\": \"r53\", \"43\": \"r53\", \"44\": \"r53\", \"45\": \"r53\", \"46\": \"r53\", \"47\": \"r53\", \"48\": \"r53\", \"49\": \"r53\", \"50\": \"r53\", \"51\": \"r53\", \"52\": \"r53\", \"53\": \"r53\", \"54\": \"r53\", \"55\": \"r53\", \"57\": \"r53\" }, { \"25\": \"s12\", \"31\": \"s86\" }, { \"23\": \"r49\", \"24\": \"r49\", \"25\": \"r49\", \"26\": \"r49\", \"27\": \"r49\", \"28\": \"r49\", \"29\": \"r49\", \"30\": \"r49\", \"31\": \"r49\", \"32\": \"r49\", \"33\": \"r49\", \"34\": \"r49\", \"35\": \"r49\", \"36\": \"r49\", \"37\": \"r49\", \"38\": \"r49\", \"39\": \"r49\", \"40\": \"r49\", \"41\": \"r49\", \"42\": \"r49\", \"43\": \"r49\", \"44\": \"r49\", \"45\": \"r49\", \"46\": \"r49\", \"47\": \"r49\", \"48\": \"r49\", \"49\": \"r49\", \"50\": \"r49\", \"51\": \"r49\", \"52\": \"r49\", \"53\": \"r49\", \"54\": \"r49\", \"55\": \"r49\", \"57\": \"r49\" }, { \"25\": \"s12\", \"31\": \"s88\" }, { \"23\": \"r50\", \"24\": \"r50\", \"25\": \"r50\", \"26\": \"r50\", \"27\": \"r50\", \"28\": \"r50\", \"29\": \"r50\", \"30\": \"r50\", \"31\": \"r50\", \"32\": \"r50\", \"33\": \"r50\", \"34\": \"r50\", \"35\": \"r50\", \"36\": \"r50\", \"37\": \"r50\", \"38\": \"r50\", \"39\": \"r50\", \"40\": \"r50\", \"41\": \"r50\", \"42\": \"r50\", \"43\": \"r50\", \"44\": \"r50\", \"45\": \"r50\", \"46\": \"r50\", \"47\": \"r50\", \"48\": \"r50\", \"49\": \"r50\", \"50\": \"r50\", \"51\": \"r50\", \"52\": \"r50\", \"53\": \"r50\", \"54\": \"r50\", \"55\": \"r50\", \"57\": \"r50\" }, { \"25\": \"s12\", \"31\": \"s90\" }, { \"23\": \"r51\", \"24\": \"r51\", \"25\": \"r51\", \"26\": \"r51\", \"27\": \"r51\", \"28\": \"r51\", \"29\": \"r51\", \"30\": \"r51\", \"31\": \"r51\", \"32\": \"r51\", \"33\": \"r51\", \"34\": \"r51\", \"35\": \"r51\", \"36\": \"r51\", \"37\": \"r51\", \"38\": \"r51\", \"39\": \"r51\", \"40\": \"r51\", \"41\": \"r51\", \"42\": \"r51\", \"43\": \"r51\", \"44\": \"r51\", \"45\": \"r51\", \"46\": \"r51\", \"47\": \"r51\", \"48\": \"r51\", \"49\": \"r51\", \"50\": \"r51\", \"51\": \"r51\", \"52\": \"r51\", \"53\": \"r51\", \"54\": \"r51\", \"55\": \"r51\", \"57\": \"r51\" }];\n      var stack = [];\n      var tokenizer = undefined;\n      var lexRules = [[/^#[^\\n]+/, function() {\n      }], [/^\\s+/, function() {\n      }], [/^-/, function() {\n        return \"DASH\";\n      }], [/^\\//, function() {\n        return \"CHAR\";\n      }], [/^#/, function() {\n        return \"CHAR\";\n      }], [/^\\|/, function() {\n        return \"CHAR\";\n      }], [/^\\./, function() {\n        return \"CHAR\";\n      }], [/^\\{/, function() {\n        return \"CHAR\";\n      }], [/^\\{\\d+\\}/, function() {\n        return \"RANGE_EXACT\";\n      }], [/^\\{\\d+,\\}/, function() {\n        return \"RANGE_OPEN\";\n      }], [/^\\{\\d+,\\d+\\}/, function() {\n        return \"RANGE_CLOSED\";\n      }], [/^\\\\k<(([\\u0041-\\u005a\\u0061-\\u007a\\u00aa\\u00b5\\u00ba\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376-\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e-\\u066f\\u0671-\\u06d3\\u06d5\\u06e5-\\u06e6\\u06ee-\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4-\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f-\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc-\\u09dd\\u09df-\\u09e1\\u09f0-\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f-\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32-\\u0a33\\u0a35-\\u0a36\\u0a38-\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2-\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0-\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f-\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32-\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c-\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99-\\u0b9a\\u0b9c\\u0b9e-\\u0b9f\\u0ba3-\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60-\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0-\\u0ce1\\u0cf1-\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32-\\u0e33\\u0e40-\\u0e46\\u0e81-\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2-\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065-\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae-\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5-\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a-\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd-\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5-\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]|\\ud800[\\udc00-\\udc0b\\udc0d-\\udc26\\udc28-\\udc3a\\udc3c-\\udc3d\\udc3f-\\udc4d\\udc50-\\udc5d\\udc80-\\udcfa\\udd40-\\udd74\\ude80-\\ude9c\\udea0-\\uded0\\udf00-\\udf1f\\udf2d-\\udf4a\\udf50-\\udf75\\udf80-\\udf9d\\udfa0-\\udfc3\\udfc8-\\udfcf\\udfd1-\\udfd5]|\\ud801[\\udc00-\\udc9d\\udcb0-\\udcd3\\udcd8-\\udcfb\\udd00-\\udd27\\udd30-\\udd63\\ude00-\\udf36\\udf40-\\udf55\\udf60-\\udf67]|\\ud802[\\udc00-\\udc05\\udc08\\udc0a-\\udc35\\udc37-\\udc38\\udc3c\\udc3f-\\udc55\\udc60-\\udc76\\udc80-\\udc9e\\udce0-\\udcf2\\udcf4-\\udcf5\\udd00-\\udd15\\udd20-\\udd39\\udd80-\\uddb7\\uddbe-\\uddbf\\ude00\\ude10-\\ude13\\ude15-\\ude17\\ude19-\\ude35\\ude60-\\ude7c\\ude80-\\ude9c\\udec0-\\udec7\\udec9-\\udee4\\udf00-\\udf35\\udf40-\\udf55\\udf60-\\udf72\\udf80-\\udf91]|\\ud803[\\udc00-\\udc48\\udc80-\\udcb2\\udcc0-\\udcf2\\udd00-\\udd23\\udf00-\\udf1c\\udf27\\udf30-\\udf45\\udfe0-\\udff6]|\\ud804[\\udc03-\\udc37\\udc83-\\udcaf\\udcd0-\\udce8\\udd03-\\udd26\\udd44\\udd50-\\udd72\\udd76\\udd83-\\uddb2\\uddc1-\\uddc4\\uddda\\udddc\\ude00-\\ude11\\ude13-\\ude2b\\ude80-\\ude86\\ude88\\ude8a-\\ude8d\\ude8f-\\ude9d\\ude9f-\\udea8\\udeb0-\\udede\\udf05-\\udf0c\\udf0f-\\udf10\\udf13-\\udf28\\udf2a-\\udf30\\udf32-\\udf33\\udf35-\\udf39\\udf3d\\udf50\\udf5d-\\udf61]|\\ud805[\\udc00-\\udc34\\udc47-\\udc4a\\udc5f\\udc80-\\udcaf\\udcc4-\\udcc5\\udcc7\\udd80-\\uddae\\uddd8-\\udddb\\ude00-\\ude2f\\ude44\\ude80-\\udeaa\\udeb8\\udf00-\\udf1a]|\\ud806[\\udc00-\\udc2b\\udca0-\\udcdf\\udcff\\udda0-\\udda7\\uddaa-\\uddd0\\udde1\\udde3\\ude00\\ude0b-\\ude32\\ude3a\\ude50\\ude5c-\\ude89\\ude9d\\udec0-\\udef8]|\\ud807[\\udc00-\\udc08\\udc0a-\\udc2e\\udc40\\udc72-\\udc8f\\udd00-\\udd06\\udd08-\\udd09\\udd0b-\\udd30\\udd46\\udd60-\\udd65\\udd67-\\udd68\\udd6a-\\udd89\\udd98\\udee0-\\udef2]|\\ud808[\\udc00-\\udf99]|\\ud809[\\udc00-\\udc6e\\udc80-\\udd43]|\\ud80c[\\udc00-\\udfff]|\\ud80d[\\udc00-\\udc2e]|\\ud811[\\udc00-\\ude46]|\\ud81a[\\udc00-\\ude38\\ude40-\\ude5e\\uded0-\\udeed\\udf00-\\udf2f\\udf40-\\udf43\\udf63-\\udf77\\udf7d-\\udf8f]|\\ud81b[\\ude40-\\ude7f\\udf00-\\udf4a\\udf50\\udf93-\\udf9f\\udfe0-\\udfe1\\udfe3]|\\ud81c[\\udc00-\\udfff]|\\ud81d[\\udc00-\\udfff]|\\ud81e[\\udc00-\\udfff]|\\ud81f[\\udc00-\\udfff]|\\ud820[\\udc00-\\udfff]|\\ud821[\\udc00-\\udff7]|\\ud822[\\udc00-\\udef2]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67\\udd70-\\udefb]|\\ud82f[\\udc00-\\udc6a\\udc70-\\udc7c\\udc80-\\udc88\\udc90-\\udc99]|\\ud835[\\udc00-\\udc54\\udc56-\\udc9c\\udc9e-\\udc9f\\udca2\\udca5-\\udca6\\udca9-\\udcac\\udcae-\\udcb9\\udcbb\\udcbd-\\udcc3\\udcc5-\\udd05\\udd07-\\udd0a\\udd0d-\\udd14\\udd16-\\udd1c\\udd1e-\\udd39\\udd3b-\\udd3e\\udd40-\\udd44\\udd46\\udd4a-\\udd50\\udd52-\\udea5\\udea8-\\udec0\\udec2-\\udeda\\udedc-\\udefa\\udefc-\\udf14\\udf16-\\udf34\\udf36-\\udf4e\\udf50-\\udf6e\\udf70-\\udf88\\udf8a-\\udfa8\\udfaa-\\udfc2\\udfc4-\\udfcb]|\\ud838[\\udd00-\\udd2c\\udd37-\\udd3d\\udd4e\\udec0-\\udeeb]|\\ud83a[\\udc00-\\udcc4\\udd00-\\udd43\\udd4b]|\\ud83b[\\ude00-\\ude03\\ude05-\\ude1f\\ude21-\\ude22\\ude24\\ude27\\ude29-\\ude32\\ude34-\\ude37\\ude39\\ude3b\\ude42\\ude47\\ude49\\ude4b\\ude4d-\\ude4f\\ude51-\\ude52\\ude54\\ude57\\ude59\\ude5b\\ude5d\\ude5f\\ude61-\\ude62\\ude64\\ude67-\\ude6a\\ude6c-\\ude72\\ude74-\\ude77\\ude79-\\ude7c\\ude7e\\ude80-\\ude89\\ude8b-\\ude9b\\udea1-\\udea3\\udea5-\\udea9\\udeab-\\udebb]|\\ud840[\\udc00-\\udfff]|\\ud841[\\udc00-\\udfff]|\\ud842[\\udc00-\\udfff]|\\ud843[\\udc00-\\udfff]|\\ud844[\\udc00-\\udfff]|\\ud845[\\udc00-\\udfff]|\\ud846[\\udc00-\\udfff]|\\ud847[\\udc00-\\udfff]|\\ud848[\\udc00-\\udfff]|\\ud849[\\udc00-\\udfff]|\\ud84a[\\udc00-\\udfff]|\\ud84b[\\udc00-\\udfff]|\\ud84c[\\udc00-\\udfff]|\\ud84d[\\udc00-\\udfff]|\\ud84e[\\udc00-\\udfff]|\\ud84f[\\udc00-\\udfff]|\\ud850[\\udc00-\\udfff]|\\ud851[\\udc00-\\udfff]|\\ud852[\\udc00-\\udfff]|\\ud853[\\udc00-\\udfff]|\\ud854[\\udc00-\\udfff]|\\ud855[\\udc00-\\udfff]|\\ud856[\\udc00-\\udfff]|\\ud857[\\udc00-\\udfff]|\\ud858[\\udc00-\\udfff]|\\ud859[\\udc00-\\udfff]|\\ud85a[\\udc00-\\udfff]|\\ud85b[\\udc00-\\udfff]|\\ud85c[\\udc00-\\udfff]|\\ud85d[\\udc00-\\udfff]|\\ud85e[\\udc00-\\udfff]|\\ud85f[\\udc00-\\udfff]|\\ud860[\\udc00-\\udfff]|\\ud861[\\udc00-\\udfff]|\\ud862[\\udc00-\\udfff]|\\ud863[\\udc00-\\udfff]|\\ud864[\\udc00-\\udfff]|\\ud865[\\udc00-\\udfff]|\\ud866[\\udc00-\\udfff]|\\ud867[\\udc00-\\udfff]|\\ud868[\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86a[\\udc00-\\udfff]|\\ud86b[\\udc00-\\udfff]|\\ud86c[\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud86f[\\udc00-\\udfff]|\\ud870[\\udc00-\\udfff]|\\ud871[\\udc00-\\udfff]|\\ud872[\\udc00-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud874[\\udc00-\\udfff]|\\ud875[\\udc00-\\udfff]|\\ud876[\\udc00-\\udfff]|\\ud877[\\udc00-\\udfff]|\\ud878[\\udc00-\\udfff]|\\ud879[\\udc00-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])|[$_]|(\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]{1,}\\}))(([\\u0030-\\u0039\\u0041-\\u005a\\u005f\\u0061-\\u007a\\u00aa\\u00b5\\u00b7\\u00ba\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376-\\u0377\\u037a-\\u037d\\u037f\\u0386-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u07fd\\u0800-\\u082d\\u0840-\\u085b\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u08d3-\\u08e1\\u08e3-\\u0963\\u0966-\\u096f\\u0971-\\u0983\\u0985-\\u098c\\u098f-\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7-\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc-\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u09fc\\u09fe\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f-\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32-\\u0a33\\u0a35-\\u0a36\\u0a38-\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2-\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0af9-\\u0aff\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f-\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32-\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47-\\u0b48\\u0b4b-\\u0b4d\\u0b56-\\u0b57\\u0b5c-\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82-\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99-\\u0b9a\\u0b9c\\u0b9e-\\u0b9f\\u0ba3-\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56\\u0c58-\\u0c5a\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c80-\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5-\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1-\\u0cf2\\u0d00-\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d54-\\u0d57\\u0d5f-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82-\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2-\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81-\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18-\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1369-\\u1371\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772-\\u1773\\u1780-\\u17d3\\u17d7\\u17dc-\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19da\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1ab0-\\u1abd\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1cd0-\\u1cd2\\u1cd4-\\u1cfa\\u1d00-\\u1df9\\u1dfb-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u203f-\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua827\\ua840-\\ua873\\ua880-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua8fd-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\ua9e0-\\ua9fe\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabea\\uabec-\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33-\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]|\\ud800[\\udc00-\\udc0b\\udc0d-\\udc26\\udc28-\\udc3a\\udc3c-\\udc3d\\udc3f-\\udc4d\\udc50-\\udc5d\\udc80-\\udcfa\\udd40-\\udd74\\uddfd\\ude80-\\ude9c\\udea0-\\uded0\\udee0\\udf00-\\udf1f\\udf2d-\\udf4a\\udf50-\\udf7a\\udf80-\\udf9d\\udfa0-\\udfc3\\udfc8-\\udfcf\\udfd1-\\udfd5]|\\ud801[\\udc00-\\udc9d\\udca0-\\udca9\\udcb0-\\udcd3\\udcd8-\\udcfb\\udd00-\\udd27\\udd30-\\udd63\\ude00-\\udf36\\udf40-\\udf55\\udf60-\\udf67]|\\ud802[\\udc00-\\udc05\\udc08\\udc0a-\\udc35\\udc37-\\udc38\\udc3c\\udc3f-\\udc55\\udc60-\\udc76\\udc80-\\udc9e\\udce0-\\udcf2\\udcf4-\\udcf5\\udd00-\\udd15\\udd20-\\udd39\\udd80-\\uddb7\\uddbe-\\uddbf\\ude00-\\ude03\\ude05-\\ude06\\ude0c-\\ude13\\ude15-\\ude17\\ude19-\\ude35\\ude38-\\ude3a\\ude3f\\ude60-\\ude7c\\ude80-\\ude9c\\udec0-\\udec7\\udec9-\\udee6\\udf00-\\udf35\\udf40-\\udf55\\udf60-\\udf72\\udf80-\\udf91]|\\ud803[\\udc00-\\udc48\\udc80-\\udcb2\\udcc0-\\udcf2\\udd00-\\udd27\\udd30-\\udd39\\udf00-\\udf1c\\udf27\\udf30-\\udf50\\udfe0-\\udff6]|\\ud804[\\udc00-\\udc46\\udc66-\\udc6f\\udc7f-\\udcba\\udcd0-\\udce8\\udcf0-\\udcf9\\udd00-\\udd34\\udd36-\\udd3f\\udd44-\\udd46\\udd50-\\udd73\\udd76\\udd80-\\uddc4\\uddc9-\\uddcc\\uddd0-\\uddda\\udddc\\ude00-\\ude11\\ude13-\\ude37\\ude3e\\ude80-\\ude86\\ude88\\ude8a-\\ude8d\\ude8f-\\ude9d\\ude9f-\\udea8\\udeb0-\\udeea\\udef0-\\udef9\\udf00-\\udf03\\udf05-\\udf0c\\udf0f-\\udf10\\udf13-\\udf28\\udf2a-\\udf30\\udf32-\\udf33\\udf35-\\udf39\\udf3b-\\udf44\\udf47-\\udf48\\udf4b-\\udf4d\\udf50\\udf57\\udf5d-\\udf63\\udf66-\\udf6c\\udf70-\\udf74]|\\ud805[\\udc00-\\udc4a\\udc50-\\udc59\\udc5e-\\udc5f\\udc80-\\udcc5\\udcc7\\udcd0-\\udcd9\\udd80-\\uddb5\\uddb8-\\uddc0\\uddd8-\\udddd\\ude00-\\ude40\\ude44\\ude50-\\ude59\\ude80-\\udeb8\\udec0-\\udec9\\udf00-\\udf1a\\udf1d-\\udf2b\\udf30-\\udf39]|\\ud806[\\udc00-\\udc3a\\udca0-\\udce9\\udcff\\udda0-\\udda7\\uddaa-\\uddd7\\uddda-\\udde1\\udde3-\\udde4\\ude00-\\ude3e\\ude47\\ude50-\\ude99\\ude9d\\udec0-\\udef8]|\\ud807[\\udc00-\\udc08\\udc0a-\\udc36\\udc38-\\udc40\\udc50-\\udc59\\udc72-\\udc8f\\udc92-\\udca7\\udca9-\\udcb6\\udd00-\\udd06\\udd08-\\udd09\\udd0b-\\udd36\\udd3a\\udd3c-\\udd3d\\udd3f-\\udd47\\udd50-\\udd59\\udd60-\\udd65\\udd67-\\udd68\\udd6a-\\udd8e\\udd90-\\udd91\\udd93-\\udd98\\udda0-\\udda9\\udee0-\\udef6]|\\ud808[\\udc00-\\udf99]|\\ud809[\\udc00-\\udc6e\\udc80-\\udd43]|\\ud80c[\\udc00-\\udfff]|\\ud80d[\\udc00-\\udc2e]|\\ud811[\\udc00-\\ude46]|\\ud81a[\\udc00-\\ude38\\ude40-\\ude5e\\ude60-\\ude69\\uded0-\\udeed\\udef0-\\udef4\\udf00-\\udf36\\udf40-\\udf43\\udf50-\\udf59\\udf63-\\udf77\\udf7d-\\udf8f]|\\ud81b[\\ude40-\\ude7f\\udf00-\\udf4a\\udf4f-\\udf87\\udf8f-\\udf9f\\udfe0-\\udfe1\\udfe3]|\\ud81c[\\udc00-\\udfff]|\\ud81d[\\udc00-\\udfff]|\\ud81e[\\udc00-\\udfff]|\\ud81f[\\udc00-\\udfff]|\\ud820[\\udc00-\\udfff]|\\ud821[\\udc00-\\udff7]|\\ud822[\\udc00-\\udef2]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67\\udd70-\\udefb]|\\ud82f[\\udc00-\\udc6a\\udc70-\\udc7c\\udc80-\\udc88\\udc90-\\udc99\\udc9d-\\udc9e]|\\ud834[\\udd65-\\udd69\\udd6d-\\udd72\\udd7b-\\udd82\\udd85-\\udd8b\\uddaa-\\uddad\\ude42-\\ude44]|\\ud835[\\udc00-\\udc54\\udc56-\\udc9c\\udc9e-\\udc9f\\udca2\\udca5-\\udca6\\udca9-\\udcac\\udcae-\\udcb9\\udcbb\\udcbd-\\udcc3\\udcc5-\\udd05\\udd07-\\udd0a\\udd0d-\\udd14\\udd16-\\udd1c\\udd1e-\\udd39\\udd3b-\\udd3e\\udd40-\\udd44\\udd46\\udd4a-\\udd50\\udd52-\\udea5\\udea8-\\udec0\\udec2-\\udeda\\udedc-\\udefa\\udefc-\\udf14\\udf16-\\udf34\\udf36-\\udf4e\\udf50-\\udf6e\\udf70-\\udf88\\udf8a-\\udfa8\\udfaa-\\udfc2\\udfc4-\\udfcb\\udfce-\\udfff]|\\ud836[\\ude00-\\ude36\\ude3b-\\ude6c\\ude75\\ude84\\ude9b-\\ude9f\\udea1-\\udeaf]|\\ud838[\\udc00-\\udc06\\udc08-\\udc18\\udc1b-\\udc21\\udc23-\\udc24\\udc26-\\udc2a\\udd00-\\udd2c\\udd30-\\udd3d\\udd40-\\udd49\\udd4e\\udec0-\\udef9]|\\ud83a[\\udc00-\\udcc4\\udcd0-\\udcd6\\udd00-\\udd4b\\udd50-\\udd59]|\\ud83b[\\ude00-\\ude03\\ude05-\\ude1f\\ude21-\\ude22\\ude24\\ude27\\ude29-\\ude32\\ude34-\\ude37\\ude39\\ude3b\\ude42\\ude47\\ude49\\ude4b\\ude4d-\\ude4f\\ude51-\\ude52\\ude54\\ude57\\ude59\\ude5b\\ude5d\\ude5f\\ude61-\\ude62\\ude64\\ude67-\\ude6a\\ude6c-\\ude72\\ude74-\\ude77\\ude79-\\ude7c\\ude7e\\ude80-\\ude89\\ude8b-\\ude9b\\udea1-\\udea3\\udea5-\\udea9\\udeab-\\udebb]|\\ud840[\\udc00-\\udfff]|\\ud841[\\udc00-\\udfff]|\\ud842[\\udc00-\\udfff]|\\ud843[\\udc00-\\udfff]|\\ud844[\\udc00-\\udfff]|\\ud845[\\udc00-\\udfff]|\\ud846[\\udc00-\\udfff]|\\ud847[\\udc00-\\udfff]|\\ud848[\\udc00-\\udfff]|\\ud849[\\udc00-\\udfff]|\\ud84a[\\udc00-\\udfff]|\\ud84b[\\udc00-\\udfff]|\\ud84c[\\udc00-\\udfff]|\\ud84d[\\udc00-\\udfff]|\\ud84e[\\udc00-\\udfff]|\\ud84f[\\udc00-\\udfff]|\\ud850[\\udc00-\\udfff]|\\ud851[\\udc00-\\udfff]|\\ud852[\\udc00-\\udfff]|\\ud853[\\udc00-\\udfff]|\\ud854[\\udc00-\\udfff]|\\ud855[\\udc00-\\udfff]|\\ud856[\\udc00-\\udfff]|\\ud857[\\udc00-\\udfff]|\\ud858[\\udc00-\\udfff]|\\ud859[\\udc00-\\udfff]|\\ud85a[\\udc00-\\udfff]|\\ud85b[\\udc00-\\udfff]|\\ud85c[\\udc00-\\udfff]|\\ud85d[\\udc00-\\udfff]|\\ud85e[\\udc00-\\udfff]|\\ud85f[\\udc00-\\udfff]|\\ud860[\\udc00-\\udfff]|\\ud861[\\udc00-\\udfff]|\\ud862[\\udc00-\\udfff]|\\ud863[\\udc00-\\udfff]|\\ud864[\\udc00-\\udfff]|\\ud865[\\udc00-\\udfff]|\\ud866[\\udc00-\\udfff]|\\ud867[\\udc00-\\udfff]|\\ud868[\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86a[\\udc00-\\udfff]|\\ud86b[\\udc00-\\udfff]|\\ud86c[\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud86f[\\udc00-\\udfff]|\\ud870[\\udc00-\\udfff]|\\ud871[\\udc00-\\udfff]|\\ud872[\\udc00-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud874[\\udc00-\\udfff]|\\ud875[\\udc00-\\udfff]|\\ud876[\\udc00-\\udfff]|\\ud877[\\udc00-\\udfff]|\\ud878[\\udc00-\\udfff]|\\ud879[\\udc00-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d]|\\udb40[\\udd00-\\uddef])|[$_]|(\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]{1,}\\})|[\\u200c\\u200d])*>/, function() {\n        var groupName = yytext.slice(3, -1);\n        validateUnicodeGroupName(groupName, this.getCurrentState());\n        return \"NAMED_GROUP_REF\";\n      }], [/^\\\\b/, function() {\n        return \"ESC_b\";\n      }], [/^\\\\B/, function() {\n        return \"ESC_B\";\n      }], [/^\\\\c[a-zA-Z]/, function() {\n        return \"CTRL_CH\";\n      }], [/^\\\\0\\d{1,2}/, function() {\n        return \"OCT_CODE\";\n      }], [/^\\\\0/, function() {\n        return \"DEC_CODE\";\n      }], [/^\\\\\\d{1,3}/, function() {\n        return \"DEC_CODE\";\n      }], [/^\\\\u[dD][89abAB][0-9a-fA-F]{2}\\\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function() {\n        return \"U_CODE_SURROGATE\";\n      }], [/^\\\\u\\{[0-9a-fA-F]{1,}\\}/, function() {\n        return \"U_CODE\";\n      }], [/^\\\\u[0-9a-fA-F]{4}/, function() {\n        return \"U_CODE\";\n      }], [/^\\\\[pP]\\{\\w+(?:=\\w+)?\\}/, function() {\n        return \"U_PROP_VALUE_EXP\";\n      }], [/^\\\\x[0-9a-fA-F]{2}/, function() {\n        return \"HEX_CODE\";\n      }], [/^\\\\[tnrdDsSwWvf]/, function() {\n        return \"META_CHAR\";\n      }], [/^\\\\\\//, function() {\n        return \"ESC_CHAR\";\n      }], [/^\\\\[ #]/, function() {\n        return \"ESC_CHAR\";\n      }], [/^\\\\[\\^\\$\\.\\*\\+\\?\\(\\)\\\\\\[\\]\\{\\}\\|\\/]/, function() {\n        return \"ESC_CHAR\";\n      }], [/^\\\\[^*?+\\[()\\\\|]/, function() {\n        var s = this.getCurrentState();\n        if (s === \"u_class\" && yytext === \"\\\\-\") {\n          return \"ESC_CHAR\";\n        } else if (s === \"u\" || s === \"xu\" || s === \"u_class\") {\n          throw new SyntaxError(\"invalid Unicode escape \" + yytext);\n        }\n        return \"ESC_CHAR\";\n      }], [/^\\(/, function() {\n        return \"CHAR\";\n      }], [/^\\)/, function() {\n        return \"CHAR\";\n      }], [/^\\(\\?=/, function() {\n        return \"POS_LA_ASSERT\";\n      }], [/^\\(\\?!/, function() {\n        return \"NEG_LA_ASSERT\";\n      }], [/^\\(\\?<=/, function() {\n        return \"POS_LB_ASSERT\";\n      }], [/^\\(\\?<!/, function() {\n        return \"NEG_LB_ASSERT\";\n      }], [/^\\(\\?:/, function() {\n        return \"NON_CAPTURE_GROUP\";\n      }], [/^\\(\\?<(([\\u0041-\\u005a\\u0061-\\u007a\\u00aa\\u00b5\\u00ba\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376-\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e-\\u066f\\u0671-\\u06d3\\u06d5\\u06e5-\\u06e6\\u06ee-\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4-\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f-\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc-\\u09dd\\u09df-\\u09e1\\u09f0-\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f-\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32-\\u0a33\\u0a35-\\u0a36\\u0a38-\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2-\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0-\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f-\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32-\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c-\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99-\\u0b9a\\u0b9c\\u0b9e-\\u0b9f\\u0ba3-\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60-\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0-\\u0ce1\\u0cf1-\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32-\\u0e33\\u0e40-\\u0e46\\u0e81-\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2-\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065-\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae-\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5-\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a-\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd-\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5-\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]|\\ud800[\\udc00-\\udc0b\\udc0d-\\udc26\\udc28-\\udc3a\\udc3c-\\udc3d\\udc3f-\\udc4d\\udc50-\\udc5d\\udc80-\\udcfa\\udd40-\\udd74\\ude80-\\ude9c\\udea0-\\uded0\\udf00-\\udf1f\\udf2d-\\udf4a\\udf50-\\udf75\\udf80-\\udf9d\\udfa0-\\udfc3\\udfc8-\\udfcf\\udfd1-\\udfd5]|\\ud801[\\udc00-\\udc9d\\udcb0-\\udcd3\\udcd8-\\udcfb\\udd00-\\udd27\\udd30-\\udd63\\ude00-\\udf36\\udf40-\\udf55\\udf60-\\udf67]|\\ud802[\\udc00-\\udc05\\udc08\\udc0a-\\udc35\\udc37-\\udc38\\udc3c\\udc3f-\\udc55\\udc60-\\udc76\\udc80-\\udc9e\\udce0-\\udcf2\\udcf4-\\udcf5\\udd00-\\udd15\\udd20-\\udd39\\udd80-\\uddb7\\uddbe-\\uddbf\\ude00\\ude10-\\ude13\\ude15-\\ude17\\ude19-\\ude35\\ude60-\\ude7c\\ude80-\\ude9c\\udec0-\\udec7\\udec9-\\udee4\\udf00-\\udf35\\udf40-\\udf55\\udf60-\\udf72\\udf80-\\udf91]|\\ud803[\\udc00-\\udc48\\udc80-\\udcb2\\udcc0-\\udcf2\\udd00-\\udd23\\udf00-\\udf1c\\udf27\\udf30-\\udf45\\udfe0-\\udff6]|\\ud804[\\udc03-\\udc37\\udc83-\\udcaf\\udcd0-\\udce8\\udd03-\\udd26\\udd44\\udd50-\\udd72\\udd76\\udd83-\\uddb2\\uddc1-\\uddc4\\uddda\\udddc\\ude00-\\ude11\\ude13-\\ude2b\\ude80-\\ude86\\ude88\\ude8a-\\ude8d\\ude8f-\\ude9d\\ude9f-\\udea8\\udeb0-\\udede\\udf05-\\udf0c\\udf0f-\\udf10\\udf13-\\udf28\\udf2a-\\udf30\\udf32-\\udf33\\udf35-\\udf39\\udf3d\\udf50\\udf5d-\\udf61]|\\ud805[\\udc00-\\udc34\\udc47-\\udc4a\\udc5f\\udc80-\\udcaf\\udcc4-\\udcc5\\udcc7\\udd80-\\uddae\\uddd8-\\udddb\\ude00-\\ude2f\\ude44\\ude80-\\udeaa\\udeb8\\udf00-\\udf1a]|\\ud806[\\udc00-\\udc2b\\udca0-\\udcdf\\udcff\\udda0-\\udda7\\uddaa-\\uddd0\\udde1\\udde3\\ude00\\ude0b-\\ude32\\ude3a\\ude50\\ude5c-\\ude89\\ude9d\\udec0-\\udef8]|\\ud807[\\udc00-\\udc08\\udc0a-\\udc2e\\udc40\\udc72-\\udc8f\\udd00-\\udd06\\udd08-\\udd09\\udd0b-\\udd30\\udd46\\udd60-\\udd65\\udd67-\\udd68\\udd6a-\\udd89\\udd98\\udee0-\\udef2]|\\ud808[\\udc00-\\udf99]|\\ud809[\\udc00-\\udc6e\\udc80-\\udd43]|\\ud80c[\\udc00-\\udfff]|\\ud80d[\\udc00-\\udc2e]|\\ud811[\\udc00-\\ude46]|\\ud81a[\\udc00-\\ude38\\ude40-\\ude5e\\uded0-\\udeed\\udf00-\\udf2f\\udf40-\\udf43\\udf63-\\udf77\\udf7d-\\udf8f]|\\ud81b[\\ude40-\\ude7f\\udf00-\\udf4a\\udf50\\udf93-\\udf9f\\udfe0-\\udfe1\\udfe3]|\\ud81c[\\udc00-\\udfff]|\\ud81d[\\udc00-\\udfff]|\\ud81e[\\udc00-\\udfff]|\\ud81f[\\udc00-\\udfff]|\\ud820[\\udc00-\\udfff]|\\ud821[\\udc00-\\udff7]|\\ud822[\\udc00-\\udef2]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67\\udd70-\\udefb]|\\ud82f[\\udc00-\\udc6a\\udc70-\\udc7c\\udc80-\\udc88\\udc90-\\udc99]|\\ud835[\\udc00-\\udc54\\udc56-\\udc9c\\udc9e-\\udc9f\\udca2\\udca5-\\udca6\\udca9-\\udcac\\udcae-\\udcb9\\udcbb\\udcbd-\\udcc3\\udcc5-\\udd05\\udd07-\\udd0a\\udd0d-\\udd14\\udd16-\\udd1c\\udd1e-\\udd39\\udd3b-\\udd3e\\udd40-\\udd44\\udd46\\udd4a-\\udd50\\udd52-\\udea5\\udea8-\\udec0\\udec2-\\udeda\\udedc-\\udefa\\udefc-\\udf14\\udf16-\\udf34\\udf36-\\udf4e\\udf50-\\udf6e\\udf70-\\udf88\\udf8a-\\udfa8\\udfaa-\\udfc2\\udfc4-\\udfcb]|\\ud838[\\udd00-\\udd2c\\udd37-\\udd3d\\udd4e\\udec0-\\udeeb]|\\ud83a[\\udc00-\\udcc4\\udd00-\\udd43\\udd4b]|\\ud83b[\\ude00-\\ude03\\ude05-\\ude1f\\ude21-\\ude22\\ude24\\ude27\\ude29-\\ude32\\ude34-\\ude37\\ude39\\ude3b\\ude42\\ude47\\ude49\\ude4b\\ude4d-\\ude4f\\ude51-\\ude52\\ude54\\ude57\\ude59\\ude5b\\ude5d\\ude5f\\ude61-\\ude62\\ude64\\ude67-\\ude6a\\ude6c-\\ude72\\ude74-\\ude77\\ude79-\\ude7c\\ude7e\\ude80-\\ude89\\ude8b-\\ude9b\\udea1-\\udea3\\udea5-\\udea9\\udeab-\\udebb]|\\ud840[\\udc00-\\udfff]|\\ud841[\\udc00-\\udfff]|\\ud842[\\udc00-\\udfff]|\\ud843[\\udc00-\\udfff]|\\ud844[\\udc00-\\udfff]|\\ud845[\\udc00-\\udfff]|\\ud846[\\udc00-\\udfff]|\\ud847[\\udc00-\\udfff]|\\ud848[\\udc00-\\udfff]|\\ud849[\\udc00-\\udfff]|\\ud84a[\\udc00-\\udfff]|\\ud84b[\\udc00-\\udfff]|\\ud84c[\\udc00-\\udfff]|\\ud84d[\\udc00-\\udfff]|\\ud84e[\\udc00-\\udfff]|\\ud84f[\\udc00-\\udfff]|\\ud850[\\udc00-\\udfff]|\\ud851[\\udc00-\\udfff]|\\ud852[\\udc00-\\udfff]|\\ud853[\\udc00-\\udfff]|\\ud854[\\udc00-\\udfff]|\\ud855[\\udc00-\\udfff]|\\ud856[\\udc00-\\udfff]|\\ud857[\\udc00-\\udfff]|\\ud858[\\udc00-\\udfff]|\\ud859[\\udc00-\\udfff]|\\ud85a[\\udc00-\\udfff]|\\ud85b[\\udc00-\\udfff]|\\ud85c[\\udc00-\\udfff]|\\ud85d[\\udc00-\\udfff]|\\ud85e[\\udc00-\\udfff]|\\ud85f[\\udc00-\\udfff]|\\ud860[\\udc00-\\udfff]|\\ud861[\\udc00-\\udfff]|\\ud862[\\udc00-\\udfff]|\\ud863[\\udc00-\\udfff]|\\ud864[\\udc00-\\udfff]|\\ud865[\\udc00-\\udfff]|\\ud866[\\udc00-\\udfff]|\\ud867[\\udc00-\\udfff]|\\ud868[\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86a[\\udc00-\\udfff]|\\ud86b[\\udc00-\\udfff]|\\ud86c[\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud86f[\\udc00-\\udfff]|\\ud870[\\udc00-\\udfff]|\\ud871[\\udc00-\\udfff]|\\ud872[\\udc00-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud874[\\udc00-\\udfff]|\\ud875[\\udc00-\\udfff]|\\ud876[\\udc00-\\udfff]|\\ud877[\\udc00-\\udfff]|\\ud878[\\udc00-\\udfff]|\\ud879[\\udc00-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])|[$_]|(\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]{1,}\\}))(([\\u0030-\\u0039\\u0041-\\u005a\\u005f\\u0061-\\u007a\\u00aa\\u00b5\\u00b7\\u00ba\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376-\\u0377\\u037a-\\u037d\\u037f\\u0386-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u07fd\\u0800-\\u082d\\u0840-\\u085b\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u08d3-\\u08e1\\u08e3-\\u0963\\u0966-\\u096f\\u0971-\\u0983\\u0985-\\u098c\\u098f-\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7-\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc-\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u09fc\\u09fe\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f-\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32-\\u0a33\\u0a35-\\u0a36\\u0a38-\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2-\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0af9-\\u0aff\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f-\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32-\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47-\\u0b48\\u0b4b-\\u0b4d\\u0b56-\\u0b57\\u0b5c-\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82-\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99-\\u0b9a\\u0b9c\\u0b9e-\\u0b9f\\u0ba3-\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56\\u0c58-\\u0c5a\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c80-\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5-\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1-\\u0cf2\\u0d00-\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d54-\\u0d57\\u0d5f-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82-\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2-\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81-\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18-\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1369-\\u1371\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772-\\u1773\\u1780-\\u17d3\\u17d7\\u17dc-\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19da\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1ab0-\\u1abd\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1cd0-\\u1cd2\\u1cd4-\\u1cfa\\u1d00-\\u1df9\\u1dfb-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u203f-\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua827\\ua840-\\ua873\\ua880-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua8fd-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\ua9e0-\\ua9fe\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabea\\uabec-\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33-\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]|\\ud800[\\udc00-\\udc0b\\udc0d-\\udc26\\udc28-\\udc3a\\udc3c-\\udc3d\\udc3f-\\udc4d\\udc50-\\udc5d\\udc80-\\udcfa\\udd40-\\udd74\\uddfd\\ude80-\\ude9c\\udea0-\\uded0\\udee0\\udf00-\\udf1f\\udf2d-\\udf4a\\udf50-\\udf7a\\udf80-\\udf9d\\udfa0-\\udfc3\\udfc8-\\udfcf\\udfd1-\\udfd5]|\\ud801[\\udc00-\\udc9d\\udca0-\\udca9\\udcb0-\\udcd3\\udcd8-\\udcfb\\udd00-\\udd27\\udd30-\\udd63\\ude00-\\udf36\\udf40-\\udf55\\udf60-\\udf67]|\\ud802[\\udc00-\\udc05\\udc08\\udc0a-\\udc35\\udc37-\\udc38\\udc3c\\udc3f-\\udc55\\udc60-\\udc76\\udc80-\\udc9e\\udce0-\\udcf2\\udcf4-\\udcf5\\udd00-\\udd15\\udd20-\\udd39\\udd80-\\uddb7\\uddbe-\\uddbf\\ude00-\\ude03\\ude05-\\ude06\\ude0c-\\ude13\\ude15-\\ude17\\ude19-\\ude35\\ude38-\\ude3a\\ude3f\\ude60-\\ude7c\\ude80-\\ude9c\\udec0-\\udec7\\udec9-\\udee6\\udf00-\\udf35\\udf40-\\udf55\\udf60-\\udf72\\udf80-\\udf91]|\\ud803[\\udc00-\\udc48\\udc80-\\udcb2\\udcc0-\\udcf2\\udd00-\\udd27\\udd30-\\udd39\\udf00-\\udf1c\\udf27\\udf30-\\udf50\\udfe0-\\udff6]|\\ud804[\\udc00-\\udc46\\udc66-\\udc6f\\udc7f-\\udcba\\udcd0-\\udce8\\udcf0-\\udcf9\\udd00-\\udd34\\udd36-\\udd3f\\udd44-\\udd46\\udd50-\\udd73\\udd76\\udd80-\\uddc4\\uddc9-\\uddcc\\uddd0-\\uddda\\udddc\\ude00-\\ude11\\ude13-\\ude37\\ude3e\\ude80-\\ude86\\ude88\\ude8a-\\ude8d\\ude8f-\\ude9d\\ude9f-\\udea8\\udeb0-\\udeea\\udef0-\\udef9\\udf00-\\udf03\\udf05-\\udf0c\\udf0f-\\udf10\\udf13-\\udf28\\udf2a-\\udf30\\udf32-\\udf33\\udf35-\\udf39\\udf3b-\\udf44\\udf47-\\udf48\\udf4b-\\udf4d\\udf50\\udf57\\udf5d-\\udf63\\udf66-\\udf6c\\udf70-\\udf74]|\\ud805[\\udc00-\\udc4a\\udc50-\\udc59\\udc5e-\\udc5f\\udc80-\\udcc5\\udcc7\\udcd0-\\udcd9\\udd80-\\uddb5\\uddb8-\\uddc0\\uddd8-\\udddd\\ude00-\\ude40\\ude44\\ude50-\\ude59\\ude80-\\udeb8\\udec0-\\udec9\\udf00-\\udf1a\\udf1d-\\udf2b\\udf30-\\udf39]|\\ud806[\\udc00-\\udc3a\\udca0-\\udce9\\udcff\\udda0-\\udda7\\uddaa-\\uddd7\\uddda-\\udde1\\udde3-\\udde4\\ude00-\\ude3e\\ude47\\ude50-\\ude99\\ude9d\\udec0-\\udef8]|\\ud807[\\udc00-\\udc08\\udc0a-\\udc36\\udc38-\\udc40\\udc50-\\udc59\\udc72-\\udc8f\\udc92-\\udca7\\udca9-\\udcb6\\udd00-\\udd06\\udd08-\\udd09\\udd0b-\\udd36\\udd3a\\udd3c-\\udd3d\\udd3f-\\udd47\\udd50-\\udd59\\udd60-\\udd65\\udd67-\\udd68\\udd6a-\\udd8e\\udd90-\\udd91\\udd93-\\udd98\\udda0-\\udda9\\udee0-\\udef6]|\\ud808[\\udc00-\\udf99]|\\ud809[\\udc00-\\udc6e\\udc80-\\udd43]|\\ud80c[\\udc00-\\udfff]|\\ud80d[\\udc00-\\udc2e]|\\ud811[\\udc00-\\ude46]|\\ud81a[\\udc00-\\ude38\\ude40-\\ude5e\\ude60-\\ude69\\uded0-\\udeed\\udef0-\\udef4\\udf00-\\udf36\\udf40-\\udf43\\udf50-\\udf59\\udf63-\\udf77\\udf7d-\\udf8f]|\\ud81b[\\ude40-\\ude7f\\udf00-\\udf4a\\udf4f-\\udf87\\udf8f-\\udf9f\\udfe0-\\udfe1\\udfe3]|\\ud81c[\\udc00-\\udfff]|\\ud81d[\\udc00-\\udfff]|\\ud81e[\\udc00-\\udfff]|\\ud81f[\\udc00-\\udfff]|\\ud820[\\udc00-\\udfff]|\\ud821[\\udc00-\\udff7]|\\ud822[\\udc00-\\udef2]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67\\udd70-\\udefb]|\\ud82f[\\udc00-\\udc6a\\udc70-\\udc7c\\udc80-\\udc88\\udc90-\\udc99\\udc9d-\\udc9e]|\\ud834[\\udd65-\\udd69\\udd6d-\\udd72\\udd7b-\\udd82\\udd85-\\udd8b\\uddaa-\\uddad\\ude42-\\ude44]|\\ud835[\\udc00-\\udc54\\udc56-\\udc9c\\udc9e-\\udc9f\\udca2\\udca5-\\udca6\\udca9-\\udcac\\udcae-\\udcb9\\udcbb\\udcbd-\\udcc3\\udcc5-\\udd05\\udd07-\\udd0a\\udd0d-\\udd14\\udd16-\\udd1c\\udd1e-\\udd39\\udd3b-\\udd3e\\udd40-\\udd44\\udd46\\udd4a-\\udd50\\udd52-\\udea5\\udea8-\\udec0\\udec2-\\udeda\\udedc-\\udefa\\udefc-\\udf14\\udf16-\\udf34\\udf36-\\udf4e\\udf50-\\udf6e\\udf70-\\udf88\\udf8a-\\udfa8\\udfaa-\\udfc2\\udfc4-\\udfcb\\udfce-\\udfff]|\\ud836[\\ude00-\\ude36\\ude3b-\\ude6c\\ude75\\ude84\\ude9b-\\ude9f\\udea1-\\udeaf]|\\ud838[\\udc00-\\udc06\\udc08-\\udc18\\udc1b-\\udc21\\udc23-\\udc24\\udc26-\\udc2a\\udd00-\\udd2c\\udd30-\\udd3d\\udd40-\\udd49\\udd4e\\udec0-\\udef9]|\\ud83a[\\udc00-\\udcc4\\udcd0-\\udcd6\\udd00-\\udd4b\\udd50-\\udd59]|\\ud83b[\\ude00-\\ude03\\ude05-\\ude1f\\ude21-\\ude22\\ude24\\ude27\\ude29-\\ude32\\ude34-\\ude37\\ude39\\ude3b\\ude42\\ude47\\ude49\\ude4b\\ude4d-\\ude4f\\ude51-\\ude52\\ude54\\ude57\\ude59\\ude5b\\ude5d\\ude5f\\ude61-\\ude62\\ude64\\ude67-\\ude6a\\ude6c-\\ude72\\ude74-\\ude77\\ude79-\\ude7c\\ude7e\\ude80-\\ude89\\ude8b-\\ude9b\\udea1-\\udea3\\udea5-\\udea9\\udeab-\\udebb]|\\ud840[\\udc00-\\udfff]|\\ud841[\\udc00-\\udfff]|\\ud842[\\udc00-\\udfff]|\\ud843[\\udc00-\\udfff]|\\ud844[\\udc00-\\udfff]|\\ud845[\\udc00-\\udfff]|\\ud846[\\udc00-\\udfff]|\\ud847[\\udc00-\\udfff]|\\ud848[\\udc00-\\udfff]|\\ud849[\\udc00-\\udfff]|\\ud84a[\\udc00-\\udfff]|\\ud84b[\\udc00-\\udfff]|\\ud84c[\\udc00-\\udfff]|\\ud84d[\\udc00-\\udfff]|\\ud84e[\\udc00-\\udfff]|\\ud84f[\\udc00-\\udfff]|\\ud850[\\udc00-\\udfff]|\\ud851[\\udc00-\\udfff]|\\ud852[\\udc00-\\udfff]|\\ud853[\\udc00-\\udfff]|\\ud854[\\udc00-\\udfff]|\\ud855[\\udc00-\\udfff]|\\ud856[\\udc00-\\udfff]|\\ud857[\\udc00-\\udfff]|\\ud858[\\udc00-\\udfff]|\\ud859[\\udc00-\\udfff]|\\ud85a[\\udc00-\\udfff]|\\ud85b[\\udc00-\\udfff]|\\ud85c[\\udc00-\\udfff]|\\ud85d[\\udc00-\\udfff]|\\ud85e[\\udc00-\\udfff]|\\ud85f[\\udc00-\\udfff]|\\ud860[\\udc00-\\udfff]|\\ud861[\\udc00-\\udfff]|\\ud862[\\udc00-\\udfff]|\\ud863[\\udc00-\\udfff]|\\ud864[\\udc00-\\udfff]|\\ud865[\\udc00-\\udfff]|\\ud866[\\udc00-\\udfff]|\\ud867[\\udc00-\\udfff]|\\ud868[\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86a[\\udc00-\\udfff]|\\ud86b[\\udc00-\\udfff]|\\ud86c[\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud86f[\\udc00-\\udfff]|\\ud870[\\udc00-\\udfff]|\\ud871[\\udc00-\\udfff]|\\ud872[\\udc00-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud874[\\udc00-\\udfff]|\\ud875[\\udc00-\\udfff]|\\ud876[\\udc00-\\udfff]|\\ud877[\\udc00-\\udfff]|\\ud878[\\udc00-\\udfff]|\\ud879[\\udc00-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d]|\\udb40[\\udd00-\\uddef])|[$_]|(\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]{1,}\\})|[\\u200c\\u200d])*>/, function() {\n        yytext = yytext.slice(3, -1);\n        validateUnicodeGroupName(yytext, this.getCurrentState());\n        return \"NAMED_CAPTURE_GROUP\";\n      }], [/^\\(/, function() {\n        return \"L_PAREN\";\n      }], [/^\\)/, function() {\n        return \"R_PAREN\";\n      }], [/^[*?+[^$]/, function() {\n        return \"CHAR\";\n      }], [/^\\\\\\]/, function() {\n        return \"ESC_CHAR\";\n      }], [/^\\]/, function() {\n        this.popState();\n        return \"R_BRACKET\";\n      }], [/^\\^/, function() {\n        return \"BOS\";\n      }], [/^\\$/, function() {\n        return \"EOS\";\n      }], [/^\\*/, function() {\n        return \"STAR\";\n      }], [/^\\?/, function() {\n        return \"Q_MARK\";\n      }], [/^\\+/, function() {\n        return \"PLUS\";\n      }], [/^\\|/, function() {\n        return \"BAR\";\n      }], [/^\\./, function() {\n        return \"ANY\";\n      }], [/^\\//, function() {\n        return \"SLASH\";\n      }], [/^[^*?+\\[()\\\\|]/, function() {\n        return \"CHAR\";\n      }], [/^\\[\\^/, function() {\n        var s = this.getCurrentState();\n        this.pushState(s === \"u\" || s === \"xu\" ? \"u_class\" : \"class\");\n        return \"NEG_CLASS\";\n      }], [/^\\[/, function() {\n        var s = this.getCurrentState();\n        this.pushState(s === \"u\" || s === \"xu\" ? \"u_class\" : \"class\");\n        return \"L_BRACKET\";\n      }]];\n      var lexRulesByConditions = { INITIAL: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], u: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], xu: [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], x: [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], u_class: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], class: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };\n      var EOF_TOKEN = {\n        type: EOF,\n        value: \"\"\n      };\n      tokenizer = {\n        initString: function initString(string) {\n          this._string = string;\n          this._cursor = 0;\n          this._states = [\"INITIAL\"];\n          this._tokensQueue = [];\n          this._currentLine = 1;\n          this._currentColumn = 0;\n          this._currentLineBeginOffset = 0;\n          this._tokenStartOffset = 0;\n          this._tokenEndOffset = 0;\n          this._tokenStartLine = 1;\n          this._tokenEndLine = 1;\n          this._tokenStartColumn = 0;\n          this._tokenEndColumn = 0;\n          return this;\n        },\n        getStates: function getStates() {\n          return this._states;\n        },\n        getCurrentState: function getCurrentState() {\n          return this._states[this._states.length - 1];\n        },\n        pushState: function pushState(state) {\n          this._states.push(state);\n        },\n        begin: function begin(state) {\n          this.pushState(state);\n        },\n        popState: function popState() {\n          if (this._states.length > 1) {\n            return this._states.pop();\n          }\n          return this._states[0];\n        },\n        getNextToken: function getNextToken() {\n          if (this._tokensQueue.length > 0) {\n            return this.onToken(this._toToken(this._tokensQueue.shift()));\n          }\n          if (!this.hasMoreTokens()) {\n            return this.onToken(EOF_TOKEN);\n          }\n          var string = this._string.slice(this._cursor);\n          var lexRulesForState = lexRulesByConditions[this.getCurrentState()];\n          for (var i = 0;i < lexRulesForState.length; i++) {\n            var lexRuleIndex = lexRulesForState[i];\n            var lexRule = lexRules[lexRuleIndex];\n            var matched = this._match(string, lexRule[0]);\n            if (string === \"\" && matched === \"\") {\n              this._cursor++;\n            }\n            if (matched !== null) {\n              yytext = matched;\n              yyleng = yytext.length;\n              var token = lexRule[1].call(this);\n              if (!token) {\n                return this.getNextToken();\n              }\n              if (Array.isArray(token)) {\n                var tokensToQueue = token.slice(1);\n                token = token[0];\n                if (tokensToQueue.length > 0) {\n                  var _tokensQueue;\n                  (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray(tokensToQueue));\n                }\n              }\n              return this.onToken(this._toToken(token, yytext));\n            }\n          }\n          if (this.isEOF()) {\n            this._cursor++;\n            return EOF_TOKEN;\n          }\n          this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);\n        },\n        throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {\n          var lineSource = this._string.split(\"\\n\")[line - 1];\n          var lineData = \"\";\n          if (lineSource) {\n            var pad = \" \".repeat(column);\n            lineData = \"\\n\\n\" + lineSource + \"\\n\" + pad + \"^\\n\";\n          }\n          throw new SyntaxError(lineData + 'Unexpected token: \"' + symbol + '\" ' + (\"at \" + line + \":\" + column + \".\"));\n        },\n        getCursor: function getCursor() {\n          return this._cursor;\n        },\n        getCurrentLine: function getCurrentLine() {\n          return this._currentLine;\n        },\n        getCurrentColumn: function getCurrentColumn() {\n          return this._currentColumn;\n        },\n        _captureLocation: function _captureLocation(matched) {\n          var nlRe = /\\n/g;\n          this._tokenStartOffset = this._cursor;\n          this._tokenStartLine = this._currentLine;\n          this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;\n          var nlMatch = undefined;\n          while ((nlMatch = nlRe.exec(matched)) !== null) {\n            this._currentLine++;\n            this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;\n          }\n          this._tokenEndOffset = this._cursor + matched.length;\n          this._tokenEndLine = this._currentLine;\n          this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;\n        },\n        _toToken: function _toToken(tokenType) {\n          var yytext2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n          return {\n            type: tokenType,\n            value: yytext2,\n            startOffset: this._tokenStartOffset,\n            endOffset: this._tokenEndOffset,\n            startLine: this._tokenStartLine,\n            endLine: this._tokenEndLine,\n            startColumn: this._tokenStartColumn,\n            endColumn: this._tokenEndColumn\n          };\n        },\n        isEOF: function isEOF() {\n          return this._cursor === this._string.length;\n        },\n        hasMoreTokens: function hasMoreTokens() {\n          return this._cursor <= this._string.length;\n        },\n        _match: function _match(string, regexp) {\n          var matched = string.match(regexp);\n          if (matched) {\n            this._captureLocation(matched[0]);\n            this._cursor += matched[0].length;\n            return matched[0];\n          }\n          return null;\n        },\n        onToken: function onToken(token) {\n          return token;\n        }\n      };\n      yy.lexer = tokenizer;\n      yy.tokenizer = tokenizer;\n      yy.options = {\n        captureLocations: true\n      };\n      var yyparse = {\n        setOptions: function setOptions(options) {\n          yy.options = options;\n          return this;\n        },\n        getOptions: function getOptions() {\n          return yy.options;\n        },\n        parse: function parse(string, parseOptions) {\n          if (!tokenizer) {\n            throw new Error(\"Tokenizer instance wasn\\'t specified.\");\n          }\n          tokenizer.initString(string);\n          var globalOptions = yy.options;\n          if (parseOptions) {\n            yy.options = Object.assign({}, yy.options, parseOptions);\n          }\n          yyparse.onParseBegin(string, tokenizer, yy.options);\n          stack.length = 0;\n          stack.push(0);\n          var token = tokenizer.getNextToken();\n          var shiftedToken = null;\n          do {\n            if (!token) {\n              yy.options = globalOptions;\n              unexpectedEndOfInput();\n            }\n            var state = stack[stack.length - 1];\n            var column = tokens[token.type];\n            if (!table[state].hasOwnProperty(column)) {\n              yy.options = globalOptions;\n              unexpectedToken(token);\n            }\n            var entry = table[state][column];\n            if (entry[0] === \"s\") {\n              var _loc2 = null;\n              if (yy.options.captureLocations) {\n                _loc2 = {\n                  startOffset: token.startOffset,\n                  endOffset: token.endOffset,\n                  startLine: token.startLine,\n                  endLine: token.endLine,\n                  startColumn: token.startColumn,\n                  endColumn: token.endColumn\n                };\n              }\n              shiftedToken = this.onShift(token);\n              stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));\n              token = tokenizer.getNextToken();\n            } else if (entry[0] === \"r\") {\n              var productionNumber = entry.slice(1);\n              var production = productions[productionNumber];\n              var hasSemanticAction = typeof production[2] === \"function\";\n              var semanticValueArgs = hasSemanticAction ? [] : null;\n              var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;\n              if (production[1] !== 0) {\n                var rhsLength = production[1];\n                while (rhsLength-- > 0) {\n                  stack.pop();\n                  var stackEntry = stack.pop();\n                  if (hasSemanticAction) {\n                    semanticValueArgs.unshift(stackEntry.semanticValue);\n                    if (locationArgs) {\n                      locationArgs.unshift(stackEntry.loc);\n                    }\n                  }\n                }\n              }\n              var reduceStackEntry = { symbol: production[0] };\n              if (hasSemanticAction) {\n                yytext = shiftedToken ? shiftedToken.value : null;\n                yyleng = shiftedToken ? shiftedToken.value.length : null;\n                var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;\n                production[2].apply(production, _toConsumableArray(semanticActionArgs));\n                reduceStackEntry.semanticValue = __;\n                if (locationArgs) {\n                  reduceStackEntry.loc = __loc;\n                }\n              }\n              var nextState = stack[stack.length - 1];\n              var symbolToReduceWith = production[0];\n              stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);\n            } else if (entry === \"acc\") {\n              stack.pop();\n              var parsed = stack.pop();\n              if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {\n                yy.options = globalOptions;\n                unexpectedToken(token);\n              }\n              if (parsed.hasOwnProperty(\"semanticValue\")) {\n                yy.options = globalOptions;\n                yyparse.onParseEnd(parsed.semanticValue);\n                return parsed.semanticValue;\n              }\n              yyparse.onParseEnd();\n              yy.options = globalOptions;\n              return true;\n            }\n          } while (tokenizer.hasMoreTokens() || stack.length > 1);\n        },\n        setTokenizer: function setTokenizer(customTokenizer) {\n          tokenizer = customTokenizer;\n          return yyparse;\n        },\n        getTokenizer: function getTokenizer() {\n          return tokenizer;\n        },\n        onParseBegin: function onParseBegin(string, tokenizer2, options) {\n        },\n        onParseEnd: function onParseEnd(parsed) {\n        },\n        onShift: function onShift(token) {\n          return token;\n        }\n      };\n      var capturingGroupsCount = 0;\n      var namedGroups = {};\n      var parsingString = \"\";\n      yyparse.onParseBegin = function(string, lexer) {\n        parsingString = string;\n        capturingGroupsCount = 0;\n        namedGroups = {};\n        var lastSlash = string.lastIndexOf(\"/\");\n        var flags = string.slice(lastSlash);\n        if (flags.includes(\"x\") && flags.includes(\"u\")) {\n          lexer.pushState(\"xu\");\n        } else {\n          if (flags.includes(\"x\")) {\n            lexer.pushState(\"x\");\n          }\n          if (flags.includes(\"u\")) {\n            lexer.pushState(\"u\");\n          }\n        }\n      };\n      yyparse.onShift = function(token) {\n        if (token.type === \"L_PAREN\" || token.type === \"NAMED_CAPTURE_GROUP\") {\n          token.value = new String(token.value);\n          token.value.groupNumber = ++capturingGroupsCount;\n        }\n        return token;\n      };\n      var unicodeProperties = require_parser_unicode_properties();\n      var validFlags = \"gimsuxy\";\n      var uReStart = /^\\\\u[0-9a-fA-F]{4}/;\n      var ucpReStart = /^\\\\u\\{[0-9a-fA-F]{1,}\\}/;\n      var ucpReAnywhere = /\\\\u\\{[0-9a-fA-F]{1,}\\}/;\n      var uidRe = /\\\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\\})/;\n      module.exports = yyparse;\n    });\n\n    // node_modules/regexp-tree/dist/parser/index.js\n    var require_parser = __commonJS((exports, module) => {\n      var regexpTreeParser = require_regexp_tree();\n      var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);\n      regexpTreeParser.parse = function(regexp, options) {\n        return generatedParseFn(\"\" + regexp, options);\n      };\n      regexpTreeParser.setOptions({ captureLocations: false });\n      module.exports = regexpTreeParser;\n    });\n\n    // node_modules/regexp-tree/dist/traverse/node-path.js\n    var require_node_path = __commonJS((exports, module) => {\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var jsonSkipLoc = function(prop, value) {\n        if (prop === \"loc\") {\n          return;\n        }\n        return value;\n      };\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var DEFAULT_COLLECTION_PROP = \"expressions\";\n      var DEFAULT_SINGLE_PROP = \"expression\";\n      var NodePath = function() {\n        function NodePath2(node) {\n          var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n          var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n          _classCallCheck(this, NodePath2);\n          this.node = node;\n          this.parentPath = parentPath;\n          this.parent = parentPath ? parentPath.node : null;\n          this.property = property;\n          this.index = index;\n        }\n        _createClass(NodePath2, [{\n          key: \"_enforceProp\",\n          value: function _enforceProp(property) {\n            if (!this.node.hasOwnProperty(property)) {\n              throw new Error(\"Node of type \" + this.node.type + ' doesn\\'t have \"' + property + '\" collection.');\n            }\n          }\n        }, {\n          key: \"setChild\",\n          value: function setChild(node) {\n            var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var childPath = undefined;\n            if (index != null) {\n              if (!property) {\n                property = DEFAULT_COLLECTION_PROP;\n              }\n              this._enforceProp(property);\n              this.node[property][index] = node;\n              childPath = NodePath2.getForNode(node, this, property, index);\n            } else {\n              if (!property) {\n                property = DEFAULT_SINGLE_PROP;\n              }\n              this._enforceProp(property);\n              this.node[property] = node;\n              childPath = NodePath2.getForNode(node, this, property, null);\n            }\n            return childPath;\n          }\n        }, {\n          key: \"appendChild\",\n          value: function appendChild(node) {\n            var property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            if (!property) {\n              property = DEFAULT_COLLECTION_PROP;\n            }\n            this._enforceProp(property);\n            var end = this.node[property].length;\n            return this.setChild(node, end, property);\n          }\n        }, {\n          key: \"insertChildAt\",\n          value: function insertChildAt(node, index) {\n            var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_COLLECTION_PROP;\n            this._enforceProp(property);\n            this.node[property].splice(index, 0, node);\n            if (index <= NodePath2.getTraversingIndex()) {\n              NodePath2.updateTraversingIndex(1);\n            }\n            this._rebuildIndex(this.node, property);\n          }\n        }, {\n          key: \"remove\",\n          value: function remove() {\n            if (this.isRemoved()) {\n              return;\n            }\n            NodePath2.registry.delete(this.node);\n            this.node = null;\n            if (!this.parent) {\n              return;\n            }\n            if (this.index !== null) {\n              this.parent[this.property].splice(this.index, 1);\n              if (this.index <= NodePath2.getTraversingIndex()) {\n                NodePath2.updateTraversingIndex(-1);\n              }\n              this._rebuildIndex(this.parent, this.property);\n              this.index = null;\n              this.property = null;\n              return;\n            }\n            delete this.parent[this.property];\n            this.property = null;\n          }\n        }, {\n          key: \"_rebuildIndex\",\n          value: function _rebuildIndex(parent, property) {\n            var parentPath = NodePath2.getForNode(parent);\n            for (var i = 0;i < parent[property].length; i++) {\n              var path = NodePath2.getForNode(parent[property][i], parentPath, property, i);\n              path.index = i;\n            }\n          }\n        }, {\n          key: \"isRemoved\",\n          value: function isRemoved() {\n            return this.node === null;\n          }\n        }, {\n          key: \"replace\",\n          value: function replace(newNode) {\n            NodePath2.registry.delete(this.node);\n            this.node = newNode;\n            if (!this.parent) {\n              return null;\n            }\n            if (this.index !== null) {\n              this.parent[this.property][this.index] = newNode;\n            } else {\n              this.parent[this.property] = newNode;\n            }\n            return NodePath2.getForNode(newNode, this.parentPath, this.property, this.index);\n          }\n        }, {\n          key: \"update\",\n          value: function update(nodeProps) {\n            Object.assign(this.node, nodeProps);\n          }\n        }, {\n          key: \"getParent\",\n          value: function getParent() {\n            return this.parentPath;\n          }\n        }, {\n          key: \"getChild\",\n          value: function getChild() {\n            var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            if (this.node.expressions) {\n              return NodePath2.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);\n            } else if (this.node.expression && n == 0) {\n              return NodePath2.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);\n            }\n            return null;\n          }\n        }, {\n          key: \"hasEqualSource\",\n          value: function hasEqualSource(path) {\n            return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);\n          }\n        }, {\n          key: \"jsonEncode\",\n          value: function jsonEncode() {\n            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, format = _ref.format, useLoc = _ref.useLoc;\n            return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format);\n          }\n        }, {\n          key: \"getPreviousSibling\",\n          value: function getPreviousSibling() {\n            if (!this.parent || this.index == null) {\n              return null;\n            }\n            return NodePath2.getForNode(this.parent[this.property][this.index - 1], NodePath2.getForNode(this.parent), this.property, this.index - 1);\n          }\n        }, {\n          key: \"getNextSibling\",\n          value: function getNextSibling() {\n            if (!this.parent || this.index == null) {\n              return null;\n            }\n            return NodePath2.getForNode(this.parent[this.property][this.index + 1], NodePath2.getForNode(this.parent), this.property, this.index + 1);\n          }\n        }], [{\n          key: \"getForNode\",\n          value: function getForNode(node) {\n            var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n            if (!node) {\n              return null;\n            }\n            if (!NodePath2.registry.has(node)) {\n              NodePath2.registry.set(node, new NodePath2(node, parentPath, prop, index == -1 ? null : index));\n            }\n            var path = NodePath2.registry.get(node);\n            if (parentPath !== null) {\n              path.parentPath = parentPath;\n              path.parent = path.parentPath.node;\n            }\n            if (prop !== null) {\n              path.property = prop;\n            }\n            if (index >= 0) {\n              path.index = index;\n            }\n            return path;\n          }\n        }, {\n          key: \"initRegistry\",\n          value: function initRegistry() {\n            if (!NodePath2.registry) {\n              NodePath2.registry = new Map;\n            }\n            NodePath2.registry.clear();\n          }\n        }, {\n          key: \"updateTraversingIndex\",\n          value: function updateTraversingIndex(dx) {\n            return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1] += dx;\n          }\n        }, {\n          key: \"getTraversingIndex\",\n          value: function getTraversingIndex() {\n            return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1];\n          }\n        }]);\n        return NodePath2;\n      }();\n      NodePath.initRegistry();\n      NodePath.traversingIndexStack = [];\n      module.exports = NodePath;\n    });\n\n    // node_modules/regexp-tree/dist/traverse/index.js\n    var require_traverse = __commonJS((exports, module) => {\n      var astTraverse = function(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var pre = options.pre;\n        var post = options.post;\n        var skipProperty = options.skipProperty;\n        function visit(node, parent, prop, idx) {\n          if (!node || typeof node.type !== \"string\") {\n            return;\n          }\n          var res = undefined;\n          if (pre) {\n            res = pre(node, parent, prop, idx);\n          }\n          if (res !== false) {\n            if (parent && parent[prop]) {\n              if (!isNaN(idx)) {\n                node = parent[prop][idx];\n              } else {\n                node = parent[prop];\n              }\n            }\n            for (var _prop in node) {\n              if (node.hasOwnProperty(_prop)) {\n                if (skipProperty ? skipProperty(_prop, node) : _prop[0] === \"$\") {\n                  continue;\n                }\n                var child = node[_prop];\n                if (Array.isArray(child)) {\n                  var index = 0;\n                  NodePath.traversingIndexStack.push(index);\n                  while (index < child.length) {\n                    visit(child[index], node, _prop, index);\n                    index = NodePath.updateTraversingIndex(1);\n                  }\n                  NodePath.traversingIndexStack.pop();\n                } else {\n                  visit(child, node, _prop);\n                }\n              }\n            }\n          }\n          if (post) {\n            post(node, parent, prop, idx);\n          }\n        }\n        visit(root, null);\n      };\n      var NodePath = require_node_path();\n      module.exports = {\n        traverse: function traverse(ast, handlers) {\n          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { asNodes: false };\n          if (!Array.isArray(handlers)) {\n            handlers = [handlers];\n          }\n          handlers = handlers.filter(function(handler) {\n            if (typeof handler.shouldRun !== \"function\") {\n              return true;\n            }\n            return handler.shouldRun(ast);\n          });\n          NodePath.initRegistry();\n          handlers.forEach(function(handler) {\n            if (typeof handler.init === \"function\") {\n              handler.init(ast);\n            }\n          });\n          function getPathFor(node, parent, prop, index) {\n            var parentPath = NodePath.getForNode(parent);\n            var nodePath = NodePath.getForNode(node, parentPath, prop, index);\n            return nodePath;\n          }\n          astTraverse(ast, {\n            pre: function pre(node, parent, prop, index) {\n              var nodePath = undefined;\n              if (!options.asNodes) {\n                nodePath = getPathFor(node, parent, prop, index);\n              }\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n              try {\n                for (var _iterator = handlers[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var handler = _step.value;\n                  if (typeof handler[\"*\"] === \"function\") {\n                    if (nodePath) {\n                      if (!nodePath.isRemoved()) {\n                        var handlerResult = handler[\"*\"](nodePath);\n                        if (handlerResult === false) {\n                          return false;\n                        }\n                      }\n                    } else {\n                      handler[\"*\"](node, parent, prop, index);\n                    }\n                  }\n                  var handlerFuncPre = undefined;\n                  if (typeof handler[node.type] === \"function\") {\n                    handlerFuncPre = handler[node.type];\n                  } else if (typeof handler[node.type] === \"object\" && typeof handler[node.type].pre === \"function\") {\n                    handlerFuncPre = handler[node.type].pre;\n                  }\n                  if (handlerFuncPre) {\n                    if (nodePath) {\n                      if (!nodePath.isRemoved()) {\n                        var _handlerResult = handlerFuncPre.call(handler, nodePath);\n                        if (_handlerResult === false) {\n                          return false;\n                        }\n                      }\n                    } else {\n                      handlerFuncPre.call(handler, node, parent, prop, index);\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            },\n            post: function post(node, parent, prop, index) {\n              if (!node) {\n                return;\n              }\n              var nodePath = undefined;\n              if (!options.asNodes) {\n                nodePath = getPathFor(node, parent, prop, index);\n              }\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n              try {\n                for (var _iterator2 = handlers[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  var handler = _step2.value;\n                  var handlerFuncPost = undefined;\n                  if (typeof handler[node.type] === \"object\" && typeof handler[node.type].post === \"function\") {\n                    handlerFuncPost = handler[node.type].post;\n                  }\n                  if (handlerFuncPost) {\n                    if (nodePath) {\n                      if (!nodePath.isRemoved()) {\n                        var handlerResult = handlerFuncPost.call(handler, nodePath);\n                        if (handlerResult === false) {\n                          return false;\n                        }\n                      }\n                    } else {\n                      handlerFuncPost.call(handler, node, parent, prop, index);\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            },\n            skipProperty: function skipProperty(prop) {\n              return prop === \"loc\";\n            }\n          });\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/transform/index.js\n    var require_transform = __commonJS((exports, module) => {\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var generator = require_generator();\n      var parser = require_parser();\n      var traverse = require_traverse();\n      var TransformResult = function() {\n        function TransformResult2(ast) {\n          var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          _classCallCheck(this, TransformResult2);\n          this._ast = ast;\n          this._source = null;\n          this._string = null;\n          this._regexp = null;\n          this._extra = extra;\n        }\n        _createClass(TransformResult2, [{\n          key: \"getAST\",\n          value: function getAST() {\n            return this._ast;\n          }\n        }, {\n          key: \"setExtra\",\n          value: function setExtra(extra) {\n            this._extra = extra;\n          }\n        }, {\n          key: \"getExtra\",\n          value: function getExtra() {\n            return this._extra;\n          }\n        }, {\n          key: \"toRegExp\",\n          value: function toRegExp() {\n            if (!this._regexp) {\n              this._regexp = new RegExp(this.getSource(), this._ast.flags);\n            }\n            return this._regexp;\n          }\n        }, {\n          key: \"getSource\",\n          value: function getSource() {\n            if (!this._source) {\n              this._source = generator.generate(this._ast.body);\n            }\n            return this._source;\n          }\n        }, {\n          key: \"getFlags\",\n          value: function getFlags() {\n            return this._ast.flags;\n          }\n        }, {\n          key: \"toString\",\n          value: function toString() {\n            if (!this._string) {\n              this._string = generator.generate(this._ast);\n            }\n            return this._string;\n          }\n        }]);\n        return TransformResult2;\n      }();\n      module.exports = {\n        TransformResult,\n        transform: function transform(regexp, handlers) {\n          var ast = regexp;\n          if (regexp instanceof RegExp) {\n            regexp = \"\" + regexp;\n          }\n          if (typeof regexp === \"string\") {\n            ast = parser.parse(regexp, {\n              captureLocations: true\n            });\n          }\n          traverse.traverse(ast, handlers);\n          return new TransformResult(ast);\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/compat-transpiler/index.js\n    var require_compat_transpiler = __commonJS((exports, module) => {\n      var compatTransforms = require_transforms();\n      var _transform = require_transform();\n      module.exports = {\n        transform: function transform(regexp) {\n          var transformsWhitelist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          var transformToApply = transformsWhitelist.length > 0 ? transformsWhitelist : Object.keys(compatTransforms);\n          var result = undefined;\n          var extra = {};\n          transformToApply.forEach(function(transformName) {\n            if (!compatTransforms.hasOwnProperty(transformName)) {\n              throw new Error(\"Unknown compat-transform: \" + transformName + \". Available transforms are: \" + Object.keys(compatTransforms).join(\", \"));\n            }\n            var handler = compatTransforms[transformName];\n            result = _transform.transform(regexp, handler);\n            regexp = result.getAST();\n            if (typeof handler.getExtra === \"function\") {\n              extra[transformName] = handler.getExtra();\n            }\n          });\n          result.setExtra(extra);\n          return result;\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/utils/clone.js\n    var require_clone = __commonJS((exports, module) => {\n      module.exports = function clone(obj) {\n        if (obj === null || typeof obj !== \"object\") {\n          return obj;\n        }\n        var res = undefined;\n        if (Array.isArray(obj)) {\n          res = [];\n        } else {\n          res = {};\n        }\n        for (var i in obj) {\n          res[i] = clone(obj[i]);\n        }\n        return res;\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js\n    var require_char_surrogate_pair_to_single_unicode_transform = __commonJS((exports, module) => {\n      module.exports = {\n        shouldRun: function shouldRun(ast) {\n          return ast.flags.includes(\"u\");\n        },\n        Char: function Char(path) {\n          var node = path.node;\n          if (node.kind !== \"unicode\" || !node.isSurrogatePair || isNaN(node.codePoint)) {\n            return;\n          }\n          node.value = \"\\\\u{\" + node.codePoint.toString(16) + \"}\";\n          delete node.isSurrogatePair;\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js\n    var require_char_code_to_simple_char_transform = __commonJS((exports, module) => {\n      var isSimpleRange = function(classRange) {\n        var { from, to } = classRange;\n        return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;\n      };\n      var isPrintableASCIIChar = function(codePoint) {\n        return codePoint >= 32 && codePoint <= 126;\n      };\n      var needsEscape = function(symbol, parentType) {\n        if (parentType === \"ClassRange\" || parentType === \"CharacterClass\") {\n          return /[\\]\\\\^-]/.test(symbol);\n        }\n        return /[*[()+?^$./\\\\|{}]/.test(symbol);\n      };\n      var UPPER_A_CP = \"A\".codePointAt(0);\n      var UPPER_Z_CP = \"Z\".codePointAt(0);\n      var LOWER_A_CP = \"a\".codePointAt(0);\n      var LOWER_Z_CP = \"z\".codePointAt(0);\n      var DIGIT_0_CP = \"0\".codePointAt(0);\n      var DIGIT_9_CP = \"9\".codePointAt(0);\n      module.exports = {\n        Char: function Char(path) {\n          var { node, parent } = path;\n          if (isNaN(node.codePoint) || node.kind === \"simple\") {\n            return;\n          }\n          if (parent.type === \"ClassRange\") {\n            if (!isSimpleRange(parent)) {\n              return;\n            }\n          }\n          if (!isPrintableASCIIChar(node.codePoint)) {\n            return;\n          }\n          var symbol = String.fromCodePoint(node.codePoint);\n          var newChar = {\n            type: \"Char\",\n            kind: \"simple\",\n            value: symbol,\n            symbol,\n            codePoint: node.codePoint\n          };\n          if (needsEscape(symbol, parent.type)) {\n            newChar.escaped = true;\n          }\n          path.replace(newChar);\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js\n    var require_char_case_insensitive_lowercase_transform = __commonJS((exports, module) => {\n      var isAZClassRange = function(classRange) {\n        var { from, to } = classRange;\n        return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;\n      };\n      var displaySymbolAsValue = function(symbol, node) {\n        var codePoint = symbol.codePointAt(0);\n        if (node.kind === \"decimal\") {\n          return \"\\\\\" + codePoint;\n        }\n        if (node.kind === \"oct\") {\n          return \"\\\\0\" + codePoint.toString(8);\n        }\n        if (node.kind === \"hex\") {\n          return \"\\\\x\" + codePoint.toString(16);\n        }\n        if (node.kind === \"unicode\") {\n          if (node.isSurrogatePair) {\n            var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint), lead = _getSurrogatePairFrom.lead, trail = _getSurrogatePairFrom.trail;\n            return \"\\\\u\" + \"0\".repeat(4 - lead.length) + lead + \"\\\\u\" + \"0\".repeat(4 - trail.length) + trail;\n          } else if (node.value.includes(\"{\")) {\n            return \"\\\\u{\" + codePoint.toString(16) + \"}\";\n          } else {\n            var code = codePoint.toString(16);\n            return \"\\\\u\" + \"0\".repeat(4 - code.length) + code;\n          }\n        }\n        return symbol;\n      };\n      var getSurrogatePairFromCodePoint = function(codePoint) {\n        var lead = Math.floor((codePoint - 65536) / 1024) + 55296;\n        var trail = (codePoint - 65536) % 1024 + 56320;\n        return {\n          lead: lead.toString(16),\n          trail: trail.toString(16)\n        };\n      };\n      var UPPER_A_CP = \"A\".codePointAt(0);\n      var UPPER_Z_CP = \"Z\".codePointAt(0);\n      module.exports = {\n        _AZClassRanges: null,\n        _hasUFlag: false,\n        init: function init(ast) {\n          this._AZClassRanges = new Set;\n          this._hasUFlag = ast.flags.includes(\"u\");\n        },\n        shouldRun: function shouldRun(ast) {\n          return ast.flags.includes(\"i\");\n        },\n        Char: function Char(path) {\n          var { node, parent } = path;\n          if (isNaN(node.codePoint)) {\n            return;\n          }\n          if (!this._hasUFlag && node.codePoint >= 4096) {\n            return;\n          }\n          if (parent.type === \"ClassRange\") {\n            if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {\n              return;\n            }\n            this._AZClassRanges.add(parent);\n          }\n          var lower = node.symbol.toLowerCase();\n          if (lower !== node.symbol) {\n            node.value = displaySymbolAsValue(lower, node);\n            node.symbol = lower;\n            node.codePoint = lower.codePointAt(0);\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js\n    var require_char_class_remove_duplicates_transform = __commonJS((exports, module) => {\n      module.exports = {\n        CharacterClass: function CharacterClass(path) {\n          var node = path.node;\n          var sources = {};\n          for (var i = 0;i < node.expressions.length; i++) {\n            var childPath = path.getChild(i);\n            var source = childPath.jsonEncode();\n            if (sources.hasOwnProperty(source)) {\n              childPath.remove();\n              i--;\n            }\n            sources[source] = true;\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/transform/utils.js\n    var require_utils = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var disjunctionToList = function(node) {\n        if (node.type !== \"Disjunction\") {\n          throw new TypeError('Expected \"Disjunction\" node, got \"' + node.type + '\"');\n        }\n        var list = [];\n        if (node.left && node.left.type === \"Disjunction\") {\n          list.push.apply(list, _toConsumableArray(disjunctionToList(node.left)).concat([node.right]));\n        } else {\n          list.push(node.left, node.right);\n        }\n        return list;\n      };\n      var listToDisjunction = function(list) {\n        return list.reduce(function(left, right) {\n          return {\n            type: \"Disjunction\",\n            left,\n            right\n          };\n        });\n      };\n      var increaseQuantifierByOne = function(quantifier) {\n        if (quantifier.kind === \"*\") {\n          quantifier.kind = \"+\";\n        } else if (quantifier.kind === \"+\") {\n          quantifier.kind = \"Range\";\n          quantifier.from = 2;\n          delete quantifier.to;\n        } else if (quantifier.kind === \"?\") {\n          quantifier.kind = \"Range\";\n          quantifier.from = 1;\n          quantifier.to = 2;\n        } else if (quantifier.kind === \"Range\") {\n          quantifier.from += 1;\n          if (quantifier.to) {\n            quantifier.to += 1;\n          }\n        }\n      };\n      module.exports = {\n        disjunctionToList,\n        listToDisjunction,\n        increaseQuantifierByOne\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js\n    var require_quantifiers_merge_transform = __commonJS((exports, module) => {\n      var isGreedyOpenRange = function(quantifier) {\n        return quantifier.greedy && (quantifier.kind === \"+\" || quantifier.kind === \"*\" || quantifier.kind === \"Range\" && !quantifier.to);\n      };\n      var extractFromTo = function(quantifier) {\n        var from = undefined, to = undefined;\n        if (quantifier.kind === \"*\") {\n          from = 0;\n        } else if (quantifier.kind === \"+\") {\n          from = 1;\n        } else if (quantifier.kind === \"?\") {\n          from = 0;\n          to = 1;\n        } else {\n          from = quantifier.from;\n          if (quantifier.to) {\n            to = quantifier.to;\n          }\n        }\n        return { from, to };\n      };\n      var _require = require_utils();\n      var increaseQuantifierByOne = _require.increaseQuantifierByOne;\n      module.exports = {\n        Repetition: function Repetition(path) {\n          var { node, parent } = path;\n          if (parent.type !== \"Alternative\" || !path.index) {\n            return;\n          }\n          var previousSibling = path.getPreviousSibling();\n          if (!previousSibling) {\n            return;\n          }\n          if (previousSibling.node.type === \"Repetition\") {\n            if (!previousSibling.getChild().hasEqualSource(path.getChild())) {\n              return;\n            }\n            var _extractFromTo = extractFromTo(previousSibling.node.quantifier), previousSiblingFrom = _extractFromTo.from, previousSiblingTo = _extractFromTo.to;\n            var _extractFromTo2 = extractFromTo(node.quantifier), nodeFrom = _extractFromTo2.from, nodeTo = _extractFromTo2.to;\n            if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {\n              return;\n            }\n            node.quantifier.kind = \"Range\";\n            node.quantifier.from = previousSiblingFrom + nodeFrom;\n            if (previousSiblingTo && nodeTo) {\n              node.quantifier.to = previousSiblingTo + nodeTo;\n            } else {\n              delete node.quantifier.to;\n            }\n            if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {\n              node.quantifier.greedy = true;\n            }\n            previousSibling.remove();\n          } else {\n            if (!previousSibling.hasEqualSource(path.getChild())) {\n              return;\n            }\n            increaseQuantifierByOne(node.quantifier);\n            previousSibling.remove();\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js\n    var require_quantifier_range_to_symbol_transform = __commonJS((exports, module) => {\n      var rewriteOpenZero = function(path) {\n        var node = path.node;\n        if (node.from !== 0 || node.to) {\n          return;\n        }\n        node.kind = \"*\";\n        delete node.from;\n      };\n      var rewriteOpenOne = function(path) {\n        var node = path.node;\n        if (node.from !== 1 || node.to) {\n          return;\n        }\n        node.kind = \"+\";\n        delete node.from;\n      };\n      var rewriteExactOne = function(path) {\n        var node = path.node;\n        if (node.from !== 1 || node.to !== 1) {\n          return;\n        }\n        path.parentPath.replace(path.parentPath.node.expression);\n      };\n      module.exports = {\n        Quantifier: function Quantifier(path) {\n          var node = path.node;\n          if (node.kind !== \"Range\") {\n            return;\n          }\n          rewriteOpenZero(path);\n          rewriteOpenOne(path);\n          rewriteExactOne(path);\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js\n    var require_char_class_classranges_to_chars_transform = __commonJS((exports, module) => {\n      module.exports = {\n        ClassRange: function ClassRange(path) {\n          var node = path.node;\n          if (node.from.codePoint === node.to.codePoint) {\n            path.replace(node.from);\n          } else if (node.from.codePoint === node.to.codePoint - 1) {\n            path.getParent().insertChildAt(node.to, path.index + 1);\n            path.replace(node.from);\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js\n    var require_char_class_to_meta_transform = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var rewriteNumberRanges = function(path) {\n        var node = path.node;\n        node.expressions.forEach(function(expression, i) {\n          if (isFullNumberRange(expression)) {\n            path.getChild(i).replace({\n              type: \"Char\",\n              value: \"\\\\d\",\n              kind: \"meta\"\n            });\n          }\n        });\n      };\n      var rewriteWordRanges = function(path, hasIFlag, hasUFlag) {\n        var node = path.node;\n        var numberPath = null;\n        var lowerCasePath = null;\n        var upperCasePath = null;\n        var underscorePath = null;\n        var u017fPath = null;\n        var u212aPath = null;\n        node.expressions.forEach(function(expression, i) {\n          if (isMetaChar(expression, \"\\\\d\")) {\n            numberPath = path.getChild(i);\n          } else if (isLowerCaseRange(expression)) {\n            lowerCasePath = path.getChild(i);\n          } else if (isUpperCaseRange(expression)) {\n            upperCasePath = path.getChild(i);\n          } else if (isUnderscore(expression)) {\n            underscorePath = path.getChild(i);\n          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 383)) {\n            u017fPath = path.getChild(i);\n          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 8490)) {\n            u212aPath = path.getChild(i);\n          }\n        });\n        if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {\n          numberPath.replace({\n            type: \"Char\",\n            value: \"\\\\w\",\n            kind: \"meta\"\n          });\n          if (lowerCasePath) {\n            lowerCasePath.remove();\n          }\n          if (upperCasePath) {\n            upperCasePath.remove();\n          }\n          underscorePath.remove();\n          if (u017fPath) {\n            u017fPath.remove();\n          }\n          if (u212aPath) {\n            u212aPath.remove();\n          }\n        }\n      };\n      var rewriteWhitespaceRanges = function(path) {\n        var node = path.node;\n        if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function(test) {\n          return node.expressions.some(function(expression) {\n            return test(expression);\n          });\n        })) {\n          return;\n        }\n        var nNode = node.expressions.find(function(expression) {\n          return isMetaChar(expression, \"\\\\n\");\n        });\n        nNode.value = \"\\\\s\";\n        nNode.symbol = undefined;\n        nNode.codePoint = NaN;\n        node.expressions.map(function(expression, i) {\n          return whitespaceRangeTests.some(function(test) {\n            return test(expression);\n          }) ? path.getChild(i) : undefined;\n        }).filter(Boolean).forEach(function(path2) {\n          return path2.remove();\n        });\n      };\n      var isFullNumberRange = function(node) {\n        return node.type === \"ClassRange\" && node.from.value === \"0\" && node.to.value === \"9\";\n      };\n      var isChar = function(node, value) {\n        var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"simple\";\n        return node.type === \"Char\" && node.value === value && node.kind === kind;\n      };\n      var isMetaChar = function(node, value) {\n        return isChar(node, value, \"meta\");\n      };\n      var isLowerCaseRange = function(node) {\n        return node.type === \"ClassRange\" && node.from.value === \"a\" && node.to.value === \"z\";\n      };\n      var isUpperCaseRange = function(node) {\n        return node.type === \"ClassRange\" && node.from.value === \"A\" && node.to.value === \"Z\";\n      };\n      var isUnderscore = function(node) {\n        return node.type === \"Char\" && node.value === \"_\" && node.kind === \"simple\";\n      };\n      var isCodePoint = function(node, codePoint) {\n        return node.type === \"Char\" && node.kind === \"unicode\" && node.codePoint === codePoint;\n      };\n      module.exports = {\n        _hasIFlag: false,\n        _hasUFlag: false,\n        init: function init(ast) {\n          this._hasIFlag = ast.flags.includes(\"i\");\n          this._hasUFlag = ast.flags.includes(\"u\");\n        },\n        CharacterClass: function CharacterClass(path) {\n          rewriteNumberRanges(path);\n          rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);\n          rewriteWhitespaceRanges(path);\n        }\n      };\n      var whitespaceRangeTests = [function(node) {\n        return isChar(node, \" \");\n      }].concat(_toConsumableArray([\"\\\\f\", \"\\\\n\", \"\\\\r\", \"\\\\t\", \"\\\\v\"].map(function(char) {\n        return function(node) {\n          return isMetaChar(node, char);\n        };\n      })), _toConsumableArray([160, 5760, 8232, 8233, 8239, 8287, 12288, 65279].map(function(codePoint) {\n        return function(node) {\n          return isCodePoint(node, codePoint);\n        };\n      })), [function(node) {\n        return node.type === \"ClassRange\" && isCodePoint(node.from, 8192) && isCodePoint(node.to, 8202);\n      }]);\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js\n    var require_char_class_to_single_char_transform = __commonJS((exports, module) => {\n      var isAppropriateChar = function(node) {\n        return node.type === \"Char\" && node.value !== \"\\\\b\";\n      };\n      var isMeta = function(value) {\n        return /^\\\\[dwsDWS]$/.test(value);\n      };\n      var getInverseMeta = function(value) {\n        return /[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase();\n      };\n      var hasAppropriateSiblings = function(path) {\n        var { parent, index } = path;\n        if (parent.type !== \"Alternative\") {\n          return true;\n        }\n        var previousNode = parent.expressions[index - 1];\n        if (previousNode == null) {\n          return true;\n        }\n        if (previousNode.type === \"Backreference\" && previousNode.kind === \"number\") {\n          return false;\n        }\n        if (previousNode.type === \"Char\" && previousNode.kind === \"decimal\") {\n          return false;\n        }\n        return true;\n      };\n      var shouldEscape = function(value) {\n        return /[*[()+?$./{}|]/.test(value);\n      };\n      module.exports = {\n        CharacterClass: function CharacterClass(path) {\n          var node = path.node;\n          if (node.expressions.length !== 1 || !hasAppropriateSiblings(path) || !isAppropriateChar(node.expressions[0])) {\n            return;\n          }\n          var _node$expressions$ = node.expressions[0], value = _node$expressions$.value, kind = _node$expressions$.kind, escaped = _node$expressions$.escaped;\n          if (node.negative) {\n            if (!isMeta(value)) {\n              return;\n            }\n            value = getInverseMeta(value);\n          }\n          path.replace({\n            type: \"Char\",\n            value,\n            kind,\n            escaped: escaped || shouldEscape(value)\n          });\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js\n    var require_char_escape_unescape_transform = __commonJS((exports, module) => {\n      var shouldUnescape = function(path, hasXFlag) {\n        var value = path.node.value, index = path.index, parent = path.parent;\n        if (parent.type !== \"CharacterClass\" && parent.type !== \"ClassRange\") {\n          return !preservesEscape(value, index, parent, hasXFlag);\n        }\n        return !preservesInCharClass(value, index, parent);\n      };\n      var preservesInCharClass = function(value, index, parent) {\n        if (value === \"^\") {\n          return index === 0 && !parent.negative;\n        }\n        if (value === \"-\") {\n          return true;\n        }\n        return /[\\]\\\\]/.test(value);\n      };\n      var preservesEscape = function(value, index, parent, hasXFlag) {\n        if (value === \"{\") {\n          return preservesOpeningCurlyBraceEscape(index, parent);\n        }\n        if (value === \"}\") {\n          return preservesClosingCurlyBraceEscape(index, parent);\n        }\n        if (hasXFlag && /[ #]/.test(value)) {\n          return true;\n        }\n        return /[*[()+?^$./\\\\|]/.test(value);\n      };\n      var consumeNumbers = function(startIndex, parent, rtl) {\n        var i = startIndex;\n        var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];\n        while (siblingNode && siblingNode.type === \"Char\" && siblingNode.kind === \"simple\" && !siblingNode.escaped && /\\d/.test(siblingNode.value)) {\n          rtl ? i-- : i++;\n          siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];\n        }\n        return Math.abs(startIndex - i);\n      };\n      var isSimpleChar = function(node, value) {\n        return node && node.type === \"Char\" && node.kind === \"simple\" && !node.escaped && node.value === value;\n      };\n      var preservesOpeningCurlyBraceEscape = function(index, parent) {\n        if (index == null) {\n          return false;\n        }\n        var nbFollowingNumbers = consumeNumbers(index + 1, parent);\n        var i = index + nbFollowingNumbers + 1;\n        var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];\n        if (nbFollowingNumbers) {\n          if (isSimpleChar(nextSiblingNode, \"}\")) {\n            return true;\n          }\n          if (isSimpleChar(nextSiblingNode, \",\")) {\n            nbFollowingNumbers = consumeNumbers(i + 1, parent);\n            i = i + nbFollowingNumbers + 1;\n            nextSiblingNode = i < parent.expressions.length && parent.expressions[i];\n            return isSimpleChar(nextSiblingNode, \"}\");\n          }\n        }\n        return false;\n      };\n      var preservesClosingCurlyBraceEscape = function(index, parent) {\n        if (index == null) {\n          return false;\n        }\n        var nbPrecedingNumbers = consumeNumbers(index - 1, parent, true);\n        var i = index - nbPrecedingNumbers - 1;\n        var previousSiblingNode = i >= 0 && parent.expressions[i];\n        if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, \"{\")) {\n          return true;\n        }\n        if (isSimpleChar(previousSiblingNode, \",\")) {\n          nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);\n          i = i - nbPrecedingNumbers - 1;\n          previousSiblingNode = i < parent.expressions.length && parent.expressions[i];\n          return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, \"{\");\n        }\n        return false;\n      };\n      module.exports = {\n        _hasXFlag: false,\n        init: function init(ast) {\n          this._hasXFlag = ast.flags.includes(\"x\");\n        },\n        Char: function Char(path) {\n          var node = path.node;\n          if (!node.escaped) {\n            return;\n          }\n          if (shouldUnescape(path, this._hasXFlag)) {\n            delete node.escaped;\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js\n    var require_char_class_classranges_merge_transform = __commonJS((exports, module) => {\n      var sortCharClass = function(a, b) {\n        var aValue = getSortValue(a);\n        var bValue = getSortValue(b);\n        if (aValue === bValue) {\n          if (a.type === \"ClassRange\" && b.type !== \"ClassRange\") {\n            return -1;\n          }\n          if (b.type === \"ClassRange\" && a.type !== \"ClassRange\") {\n            return 1;\n          }\n          if (a.type === \"ClassRange\" && b.type === \"ClassRange\") {\n            return getSortValue(a.to) - getSortValue(b.to);\n          }\n          if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {\n            return a.value < b.value ? -1 : 1;\n          }\n        }\n        return aValue - bValue;\n      };\n      var getSortValue = function(expression) {\n        if (expression.type === \"Char\") {\n          if (expression.value === \"-\") {\n            return Infinity;\n          }\n          if (expression.kind === \"control\") {\n            return Infinity;\n          }\n          if (expression.kind === \"meta\" && isNaN(expression.codePoint)) {\n            return -1;\n          }\n          return expression.codePoint;\n        }\n        return expression.from.codePoint;\n      };\n      var isMeta = function(expression) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return expression.type === \"Char\" && expression.kind === \"meta\" && (value ? expression.value === value : /^\\\\[dws]$/i.test(expression.value));\n      };\n      var isControl = function(expression) {\n        return expression.type === \"Char\" && expression.kind === \"control\";\n      };\n      var fitsInMetas = function(expression, metas, hasIUFlags) {\n        for (var i = 0;i < metas.length; i++) {\n          if (fitsInMeta(expression, metas[i], hasIUFlags)) {\n            return true;\n          }\n        }\n        return false;\n      };\n      var fitsInMeta = function(expression, meta, hasIUFlags) {\n        if (expression.type === \"ClassRange\") {\n          return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);\n        }\n        if (meta === \"\\\\S\" && (isMeta(expression, \"\\\\w\") || isMeta(expression, \"\\\\d\"))) {\n          return true;\n        }\n        if (meta === \"\\\\D\" && (isMeta(expression, \"\\\\W\") || isMeta(expression, \"\\\\s\"))) {\n          return true;\n        }\n        if (meta === \"\\\\w\" && isMeta(expression, \"\\\\d\")) {\n          return true;\n        }\n        if (meta === \"\\\\W\" && isMeta(expression, \"\\\\s\")) {\n          return true;\n        }\n        if (expression.type !== \"Char\" || isNaN(expression.codePoint)) {\n          return false;\n        }\n        if (meta === \"\\\\s\") {\n          return fitsInMetaS(expression);\n        }\n        if (meta === \"\\\\S\") {\n          return !fitsInMetaS(expression);\n        }\n        if (meta === \"\\\\d\") {\n          return fitsInMetaD(expression);\n        }\n        if (meta === \"\\\\D\") {\n          return !fitsInMetaD(expression);\n        }\n        if (meta === \"\\\\w\") {\n          return fitsInMetaW(expression, hasIUFlags);\n        }\n        if (meta === \"\\\\W\") {\n          return !fitsInMetaW(expression, hasIUFlags);\n        }\n        return false;\n      };\n      var fitsInMetaS = function(expression) {\n        return expression.codePoint === 9 || expression.codePoint === 10 || expression.codePoint === 11 || expression.codePoint === 12 || expression.codePoint === 13 || expression.codePoint === 32 || expression.codePoint === 160 || expression.codePoint === 5760 || expression.codePoint >= 8192 && expression.codePoint <= 8202 || expression.codePoint === 8232 || expression.codePoint === 8233 || expression.codePoint === 8239 || expression.codePoint === 8287 || expression.codePoint === 12288 || expression.codePoint === 65279;\n      };\n      var fitsInMetaD = function(expression) {\n        return expression.codePoint >= 48 && expression.codePoint <= 57;\n      };\n      var fitsInMetaW = function(expression, hasIUFlags) {\n        return fitsInMetaD(expression) || expression.codePoint >= 65 && expression.codePoint <= 90 || expression.codePoint >= 97 && expression.codePoint <= 122 || expression.value === \"_\" || hasIUFlags && (expression.codePoint === 383 || expression.codePoint === 8490);\n      };\n      var combinesWithPrecedingClassRange = function(expression, classRange) {\n        if (classRange && classRange.type === \"ClassRange\") {\n          if (fitsInClassRange(expression, classRange)) {\n            return true;\n          } else if (isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1) {\n            classRange.to = expression;\n            return true;\n          } else if (expression.type === \"ClassRange\" && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {\n            if (expression.from.codePoint < classRange.from.codePoint) {\n              classRange.from = expression.from;\n            }\n            if (expression.to.codePoint > classRange.to.codePoint) {\n              classRange.to = expression.to;\n            }\n            return true;\n          }\n        }\n        return false;\n      };\n      var combinesWithFollowingClassRange = function(expression, classRange) {\n        if (classRange && classRange.type === \"ClassRange\") {\n          if (isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1) {\n            classRange.from = expression;\n            return true;\n          }\n        }\n        return false;\n      };\n      var fitsInClassRange = function(expression, classRange) {\n        if (expression.type === \"Char\" && isNaN(expression.codePoint)) {\n          return false;\n        }\n        if (expression.type === \"ClassRange\") {\n          return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);\n        }\n        return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;\n      };\n      var charCombinesWithPrecedingChars = function(expression, index, expressions) {\n        if (!isMetaWCharOrCode(expression)) {\n          return 0;\n        }\n        var nbMergedChars = 0;\n        while (index > 0) {\n          var currentExpression = expressions[index];\n          var precedingExpresion = expressions[index - 1];\n          if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {\n            nbMergedChars++;\n            index--;\n          } else {\n            break;\n          }\n        }\n        if (nbMergedChars > 1) {\n          expressions[index] = {\n            type: \"ClassRange\",\n            from: expressions[index],\n            to: expression\n          };\n          return nbMergedChars;\n        }\n        return 0;\n      };\n      var isMetaWCharOrCode = function(expression) {\n        return expression && expression.type === \"Char\" && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === \"unicode\" || expression.kind === \"hex\" || expression.kind === \"oct\" || expression.kind === \"decimal\");\n      };\n      module.exports = {\n        _hasIUFlags: false,\n        init: function init(ast) {\n          this._hasIUFlags = ast.flags.includes(\"i\") && ast.flags.includes(\"u\");\n        },\n        CharacterClass: function CharacterClass(path) {\n          var node = path.node;\n          var expressions = node.expressions;\n          var metas = [];\n          expressions.forEach(function(expression2) {\n            if (isMeta(expression2)) {\n              metas.push(expression2.value);\n            }\n          });\n          expressions.sort(sortCharClass);\n          for (var i = 0;i < expressions.length; i++) {\n            var expression = expressions[i];\n            if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {\n              expressions.splice(i, 1);\n              i--;\n            } else {\n              var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);\n              expressions.splice(i - nbMergedChars + 1, nbMergedChars);\n              i -= nbMergedChars;\n            }\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js\n    var require_disjunction_remove_duplicates_transform = __commonJS((exports, module) => {\n      var NodePath = require_node_path();\n      var _require = require_utils();\n      var disjunctionToList = _require.disjunctionToList;\n      var listToDisjunction = _require.listToDisjunction;\n      module.exports = {\n        Disjunction: function Disjunction(path) {\n          var node = path.node;\n          var uniqueNodesMap = {};\n          var parts = disjunctionToList(node).filter(function(part) {\n            var encoded = part ? NodePath.getForNode(part).jsonEncode() : \"null\";\n            if (uniqueNodesMap.hasOwnProperty(encoded)) {\n              return false;\n            }\n            uniqueNodesMap[encoded] = part;\n            return true;\n          });\n          path.replace(listToDisjunction(parts));\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js\n    var require_group_single_chars_to_char_class = __commonJS((exports, module) => {\n      var shouldProcess = function(expression, charset) {\n        if (!expression) {\n          return false;\n        }\n        var type = expression.type;\n        if (type === \"Disjunction\") {\n          var { left, right } = expression;\n          return shouldProcess(left, charset) && shouldProcess(right, charset);\n        } else if (type === \"Char\") {\n          if (expression.kind === \"meta\" && expression.symbol === \".\") {\n            return false;\n          }\n          var value = expression.value;\n          charset.set(value, expression);\n          return true;\n        } else if (type === \"CharacterClass\" && !expression.negative) {\n          return expression.expressions.every(function(expression2) {\n            return shouldProcess(expression2, charset);\n          });\n        }\n        return false;\n      };\n      module.exports = {\n        Disjunction: function Disjunction(path) {\n          var { node, parent } = path;\n          if (!handlers[parent.type]) {\n            return;\n          }\n          var charset = new Map;\n          if (!shouldProcess(node, charset) || !charset.size) {\n            return;\n          }\n          var characterClass = {\n            type: \"CharacterClass\",\n            expressions: Array.from(charset.keys()).sort().map(function(key) {\n              return charset.get(key);\n            })\n          };\n          handlers[parent.type](path.getParent(), characterClass);\n        }\n      };\n      var handlers = {\n        RegExp: function RegExp(path, characterClass) {\n          var node = path.node;\n          node.body = characterClass;\n        },\n        Group: function Group(path, characterClass) {\n          var node = path.node;\n          if (node.capturing) {\n            node.expression = characterClass;\n          } else {\n            path.replace(characterClass);\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js\n    var require_remove_empty_group_transform = __commonJS((exports, module) => {\n      module.exports = {\n        Group: function Group(path) {\n          var { node, parent } = path;\n          var childPath = path.getChild();\n          if (node.capturing || childPath) {\n            return;\n          }\n          if (parent.type === \"Repetition\") {\n            path.getParent().replace(node);\n          } else if (parent.type !== \"RegExp\") {\n            path.remove();\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js\n    var require_ungroup_transform = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var hasAppropriateSiblings = function(path) {\n        var { parent, index } = path;\n        if (parent.type !== \"Alternative\") {\n          return true;\n        }\n        var previousNode = parent.expressions[index - 1];\n        if (previousNode == null) {\n          return true;\n        }\n        if (previousNode.type === \"Backreference\" && previousNode.kind === \"number\") {\n          return false;\n        }\n        if (previousNode.type === \"Char\" && previousNode.kind === \"decimal\") {\n          return false;\n        }\n        return true;\n      };\n      module.exports = {\n        Group: function Group(path) {\n          var { node, parent } = path;\n          var childPath = path.getChild();\n          if (node.capturing || !childPath) {\n            return;\n          }\n          if (!hasAppropriateSiblings(path)) {\n            return;\n          }\n          if (childPath.node.type === \"Disjunction\" && parent.type !== \"RegExp\") {\n            return;\n          }\n          if (parent.type === \"Repetition\" && childPath.node.type !== \"Char\" && childPath.node.type !== \"CharacterClass\") {\n            return;\n          }\n          if (childPath.node.type === \"Alternative\") {\n            var parentPath = path.getParent();\n            if (parentPath.node.type === \"Alternative\") {\n              parentPath.replace({\n                type: \"Alternative\",\n                expressions: [].concat(_toConsumableArray(parent.expressions.slice(0, path.index)), _toConsumableArray(childPath.node.expressions), _toConsumableArray(parent.expressions.slice(path.index + 1)))\n              });\n            }\n          } else {\n            path.replace(childPath.node);\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js\n    var require_combine_repeating_patterns_transform = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var combineRepeatingPatternLeft = function(alternative, child, index) {\n        var node = alternative.node;\n        var nbPossibleLengths = Math.ceil(index / 2);\n        var i = 0;\n        while (i < nbPossibleLengths) {\n          var startIndex = index - 2 * i - 1;\n          var right = undefined, left = undefined;\n          if (i === 0) {\n            right = child;\n            left = alternative.getChild(startIndex);\n          } else {\n            right = NodePath.getForNode({\n              type: \"Alternative\",\n              expressions: [].concat(_toConsumableArray(node.expressions.slice(index - i, index)), [child.node])\n            });\n            left = NodePath.getForNode({\n              type: \"Alternative\",\n              expressions: [].concat(_toConsumableArray(node.expressions.slice(startIndex, index - i)))\n            });\n          }\n          if (right.hasEqualSource(left)) {\n            for (var j = 0;j < 2 * i + 1; j++) {\n              alternative.getChild(startIndex).remove();\n            }\n            child.replace({\n              type: \"Repetition\",\n              expression: i === 0 && right.node.type !== \"Repetition\" ? right.node : {\n                type: \"Group\",\n                capturing: false,\n                expression: right.node\n              },\n              quantifier: {\n                type: \"Quantifier\",\n                kind: \"Range\",\n                from: 2,\n                to: 2,\n                greedy: true\n              }\n            });\n            return startIndex;\n          }\n          i++;\n        }\n        return index;\n      };\n      var combineWithPreviousRepetition = function(alternative, child, index) {\n        var node = alternative.node;\n        var i = 0;\n        while (i < index) {\n          var previousChild = alternative.getChild(i);\n          if (previousChild.node.type === \"Repetition\" && previousChild.node.quantifier.greedy) {\n            var left = previousChild.getChild();\n            var right = undefined;\n            if (left.node.type === \"Group\" && !left.node.capturing) {\n              left = left.getChild();\n            }\n            if (i + 1 === index) {\n              right = child;\n              if (right.node.type === \"Group\" && !right.node.capturing) {\n                right = right.getChild();\n              }\n            } else {\n              right = NodePath.getForNode({\n                type: \"Alternative\",\n                expressions: [].concat(_toConsumableArray(node.expressions.slice(i + 1, index + 1)))\n              });\n            }\n            if (left.hasEqualSource(right)) {\n              for (var j = i;j < index; j++) {\n                alternative.getChild(i + 1).remove();\n              }\n              increaseQuantifierByOne(previousChild.node.quantifier);\n              return i;\n            }\n          }\n          i++;\n        }\n        return index;\n      };\n      var combineRepetitionWithPrevious = function(alternative, child, index) {\n        var node = alternative.node;\n        if (child.node.type === \"Repetition\" && child.node.quantifier.greedy) {\n          var right = child.getChild();\n          var left = undefined;\n          if (right.node.type === \"Group\" && !right.node.capturing) {\n            right = right.getChild();\n          }\n          var rightLength = undefined;\n          if (right.node.type === \"Alternative\") {\n            rightLength = right.node.expressions.length;\n            left = NodePath.getForNode({\n              type: \"Alternative\",\n              expressions: [].concat(_toConsumableArray(node.expressions.slice(index - rightLength, index)))\n            });\n          } else {\n            rightLength = 1;\n            left = alternative.getChild(index - 1);\n            if (left.node.type === \"Group\" && !left.node.capturing) {\n              left = left.getChild();\n            }\n          }\n          if (left.hasEqualSource(right)) {\n            for (var j = index - rightLength;j < index; j++) {\n              alternative.getChild(index - rightLength).remove();\n            }\n            increaseQuantifierByOne(child.node.quantifier);\n            return index - rightLength;\n          }\n        }\n        return index;\n      };\n      var NodePath = require_node_path();\n      var _require = require_utils();\n      var increaseQuantifierByOne = _require.increaseQuantifierByOne;\n      module.exports = {\n        Alternative: function Alternative(path) {\n          var node = path.node;\n          var index = 1;\n          while (index < node.expressions.length) {\n            var child = path.getChild(index);\n            index = Math.max(1, combineRepeatingPatternLeft(path, child, index));\n            if (index >= node.expressions.length) {\n              break;\n            }\n            child = path.getChild(index);\n            index = Math.max(1, combineWithPreviousRepetition(path, child, index));\n            if (index >= node.expressions.length) {\n              break;\n            }\n            child = path.getChild(index);\n            index = Math.max(1, combineRepetitionWithPrevious(path, child, index));\n            index++;\n          }\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/transforms/index.js\n    var require_transforms2 = __commonJS((exports, module) => {\n      module.exports = new Map([\n        [\"charSurrogatePairToSingleUnicode\", require_char_surrogate_pair_to_single_unicode_transform()],\n        [\"charCodeToSimpleChar\", require_char_code_to_simple_char_transform()],\n        [\"charCaseInsensitiveLowerCaseTransform\", require_char_case_insensitive_lowercase_transform()],\n        [\"charClassRemoveDuplicates\", require_char_class_remove_duplicates_transform()],\n        [\"quantifiersMerge\", require_quantifiers_merge_transform()],\n        [\"quantifierRangeToSymbol\", require_quantifier_range_to_symbol_transform()],\n        [\"charClassClassrangesToChars\", require_char_class_classranges_to_chars_transform()],\n        [\"charClassToMeta\", require_char_class_to_meta_transform()],\n        [\"charClassToSingleChar\", require_char_class_to_single_char_transform()],\n        [\"charEscapeUnescape\", require_char_escape_unescape_transform()],\n        [\"charClassClassrangesMerge\", require_char_class_classranges_merge_transform()],\n        [\"disjunctionRemoveDuplicates\", require_disjunction_remove_duplicates_transform()],\n        [\"groupSingleCharsToCharClass\", require_group_single_chars_to_char_class()],\n        [\"removeEmptyGroup\", require_remove_empty_group_transform()],\n        [\"ungroup\", require_ungroup_transform()],\n        [\"combineRepeatingPatterns\", require_combine_repeating_patterns_transform()]\n      ]);\n    });\n\n    // node_modules/regexp-tree/dist/optimizer/index.js\n    var require_optimizer = __commonJS((exports, module) => {\n      var clone = require_clone();\n      var parser = require_parser();\n      var transform = require_transform();\n      var optimizationTransforms = require_transforms2();\n      module.exports = {\n        optimize: function optimize(regexp) {\n          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$whitelist = _ref.whitelist, whitelist = _ref$whitelist === undefined ? [] : _ref$whitelist, _ref$blacklist = _ref.blacklist, blacklist = _ref$blacklist === undefined ? [] : _ref$blacklist;\n          var transformsRaw = whitelist.length > 0 ? whitelist : Array.from(optimizationTransforms.keys());\n          var transformToApply = transformsRaw.filter(function(transform2) {\n            return !blacklist.includes(transform2);\n          });\n          var ast = regexp;\n          if (regexp instanceof RegExp) {\n            regexp = \"\" + regexp;\n          }\n          if (typeof regexp === \"string\") {\n            ast = parser.parse(regexp);\n          }\n          var result = new transform.TransformResult(ast);\n          var prevResultString = undefined;\n          do {\n            prevResultString = result.toString();\n            ast = clone(result.getAST());\n            transformToApply.forEach(function(transformName) {\n              if (!optimizationTransforms.has(transformName)) {\n                throw new Error(\"Unknown optimization-transform: \" + transformName + \". Available transforms are: \" + Array.from(optimizationTransforms.keys()).join(\", \"));\n              }\n              var transformer = optimizationTransforms.get(transformName);\n              var newResult = transform.transform(ast, transformer);\n              if (newResult.toString() !== result.toString()) {\n                if (newResult.toString().length <= result.toString().length) {\n                  result = newResult;\n                } else {\n                  ast = clone(result.getAST());\n                }\n              }\n            });\n          } while (result.toString() !== prevResultString);\n          return result;\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js\n    var require_special_symbols = __commonJS((exports, module) => {\n      var EPSILON = \"\\u03B5\";\n      var EPSILON_CLOSURE = EPSILON + \"*\";\n      module.exports = {\n        EPSILON,\n        EPSILON_CLOSURE\n      };\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js\n    var require_nfa = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var _slicedToArray = function() {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n          try {\n            for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n              if (i && _arr.length === i)\n                break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"])\n                _i[\"return\"]();\n            } finally {\n              if (_d)\n                throw _e;\n            }\n          }\n          return _arr;\n        }\n        return function(arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var _require = require_special_symbols();\n      var EPSILON = _require.EPSILON;\n      var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;\n      var NFA = function() {\n        function NFA2(inState, outState) {\n          _classCallCheck(this, NFA2);\n          this.in = inState;\n          this.out = outState;\n        }\n        _createClass(NFA2, [{\n          key: \"matches\",\n          value: function matches(string) {\n            return this.in.matches(string);\n          }\n        }, {\n          key: \"getAlphabet\",\n          value: function getAlphabet() {\n            if (!this._alphabet) {\n              this._alphabet = new Set;\n              var table = this.getTransitionTable();\n              for (var state in table) {\n                var transitions = table[state];\n                for (var symbol in transitions) {\n                  if (symbol !== EPSILON_CLOSURE) {\n                    this._alphabet.add(symbol);\n                  }\n                }\n              }\n            }\n            return this._alphabet;\n          }\n        }, {\n          key: \"getAcceptingStates\",\n          value: function getAcceptingStates() {\n            if (!this._acceptingStates) {\n              this.getTransitionTable();\n            }\n            return this._acceptingStates;\n          }\n        }, {\n          key: \"getAcceptingStateNumbers\",\n          value: function getAcceptingStateNumbers() {\n            if (!this._acceptingStateNumbers) {\n              this._acceptingStateNumbers = new Set;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n              try {\n                for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var acceptingState = _step.value;\n                  this._acceptingStateNumbers.add(acceptingState.number);\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n            return this._acceptingStateNumbers;\n          }\n        }, {\n          key: \"getTransitionTable\",\n          value: function getTransitionTable() {\n            var _this = this;\n            if (!this._transitionTable) {\n              this._transitionTable = {};\n              this._acceptingStates = new Set;\n              var visited = new Set;\n              var symbols = new Set;\n              var visitState = function visitState(state) {\n                if (visited.has(state)) {\n                  return;\n                }\n                visited.add(state);\n                state.number = visited.size;\n                _this._transitionTable[state.number] = {};\n                if (state.accepting) {\n                  _this._acceptingStates.add(state);\n                }\n                var transitions = state.getTransitions();\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n                try {\n                  for (var _iterator2 = transitions[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _ref = _step2.value;\n                    var _ref2 = _slicedToArray(_ref, 2);\n                    var symbol = _ref2[0];\n                    var symbolTransitions = _ref2[1];\n                    var combinedState = [];\n                    symbols.add(symbol);\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n                    try {\n                      for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var nextState = _step3.value;\n                        visitState(nextState);\n                        combinedState.push(nextState.number);\n                      }\n                    } catch (err) {\n                      _didIteratorError3 = true;\n                      _iteratorError3 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                          _iterator3.return();\n                        }\n                      } finally {\n                        if (_didIteratorError3) {\n                          throw _iteratorError3;\n                        }\n                      }\n                    }\n                    _this._transitionTable[state.number][symbol] = combinedState;\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                      _iterator2.return();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n              };\n              visitState(this.in);\n              visited.forEach(function(state) {\n                delete _this._transitionTable[state.number][EPSILON];\n                _this._transitionTable[state.number][EPSILON_CLOSURE] = [].concat(_toConsumableArray(state.getEpsilonClosure())).map(function(s) {\n                  return s.number;\n                });\n              });\n            }\n            return this._transitionTable;\n          }\n        }]);\n        return NFA2;\n      }();\n      module.exports = NFA;\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js\n    var require_dfa_minimizer = __commonJS((exports, module) => {\n      var _toArray = function(arr) {\n        return Array.isArray(arr) ? arr : Array.from(arr);\n      };\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var minimize = function(dfa) {\n        var table = dfa.getTransitionTable();\n        var allStates = Object.keys(table);\n        var alphabet = dfa.getAlphabet();\n        var accepting = dfa.getAcceptingStateNumbers();\n        currentTransitionMap = {};\n        var nonAccepting = new Set;\n        allStates.forEach(function(state) {\n          state = Number(state);\n          var isAccepting = accepting.has(state);\n          if (isAccepting) {\n            currentTransitionMap[state] = accepting;\n          } else {\n            nonAccepting.add(state);\n            currentTransitionMap[state] = nonAccepting;\n          }\n        });\n        var all = [\n          [nonAccepting, accepting].filter(function(set2) {\n            return set2.size > 0;\n          })\n        ];\n        var current = undefined;\n        var previous = undefined;\n        current = all[all.length - 1];\n        previous = all[all.length - 2];\n        var _loop = function _loop() {\n          var newTransitionMap = {};\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n          try {\n            for (var _iterator3 = current[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var _set = _step3.value;\n              var handledStates = {};\n              var _set2 = _toArray(_set), first = _set2[0], rest = _set2.slice(1);\n              handledStates[first] = new Set([first]);\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n              try {\n                restSets:\n                  for (var _iterator4 = rest[Symbol.iterator](), _step4;!(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var state = _step4.value;\n                    var _iteratorNormalCompletion5 = true;\n                    var _didIteratorError5 = false;\n                    var _iteratorError5 = undefined;\n                    try {\n                      for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5;!(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                        var handledState = _step5.value;\n                        if (areEquivalent(state, handledState, table, alphabet)) {\n                          handledStates[handledState].add(state);\n                          handledStates[state] = handledStates[handledState];\n                          continue restSets;\n                        }\n                      }\n                    } catch (err) {\n                      _didIteratorError5 = true;\n                      _iteratorError5 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                          _iterator5.return();\n                        }\n                      } finally {\n                        if (_didIteratorError5) {\n                          throw _iteratorError5;\n                        }\n                      }\n                    }\n                    handledStates[state] = new Set([state]);\n                  }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n              Object.assign(newTransitionMap, handledStates);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n          currentTransitionMap = newTransitionMap;\n          var newSets = new Set(Object.keys(newTransitionMap).map(function(state2) {\n            return newTransitionMap[state2];\n          }));\n          all.push([].concat(_toConsumableArray(newSets)));\n          current = all[all.length - 1];\n          previous = all[all.length - 2];\n        };\n        while (!sameRow(current, previous)) {\n          _loop();\n        }\n        var remaped = new Map;\n        var idx = 1;\n        current.forEach(function(set2) {\n          return remaped.set(set2, idx++);\n        });\n        var minimizedTable = {};\n        var minimizedAcceptingStates = new Set;\n        var updateAcceptingStates = function updateAcceptingStates(set2, idx2) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n          try {\n            for (var _iterator = set2[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var state = _step.value;\n              if (accepting.has(state)) {\n                minimizedAcceptingStates.add(idx2);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        };\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _ref = _step2.value;\n            var _ref2 = _slicedToArray(_ref, 2);\n            var set = _ref2[0];\n            var _idx = _ref2[1];\n            minimizedTable[_idx] = {};\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n            try {\n              for (var _iterator6 = alphabet[Symbol.iterator](), _step6;!(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var symbol = _step6.value;\n                updateAcceptingStates(set, _idx);\n                var originalTransition = undefined;\n                var _iteratorNormalCompletion7 = true;\n                var _didIteratorError7 = false;\n                var _iteratorError7 = undefined;\n                try {\n                  for (var _iterator7 = set[Symbol.iterator](), _step7;!(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var originalState = _step7.value;\n                    originalTransition = table[originalState][symbol];\n                    if (originalTransition) {\n                      break;\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError7 = true;\n                  _iteratorError7 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                      _iterator7.return();\n                    }\n                  } finally {\n                    if (_didIteratorError7) {\n                      throw _iteratorError7;\n                    }\n                  }\n                }\n                if (originalTransition) {\n                  minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);\n                }\n              }\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                  _iterator6.return();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n        dfa.setTransitionTable(minimizedTable);\n        dfa.setAcceptingStateNumbers(minimizedAcceptingStates);\n        return dfa;\n      };\n      var sameRow = function(r1, r2) {\n        if (!r2) {\n          return false;\n        }\n        if (r1.length !== r2.length) {\n          return false;\n        }\n        for (var i = 0;i < r1.length; i++) {\n          var s1 = r1[i];\n          var s2 = r2[i];\n          if (s1.size !== s2.size) {\n            return false;\n          }\n          if ([].concat(_toConsumableArray(s1)).sort().join(\",\") !== [].concat(_toConsumableArray(s2)).sort().join(\",\")) {\n            return false;\n          }\n        }\n        return true;\n      };\n      var areEquivalent = function(s1, s2, table, alphabet) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n        try {\n          for (var _iterator8 = alphabet[Symbol.iterator](), _step8;!(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var symbol = _step8.value;\n            if (!goToSameSet(s1, s2, table, symbol)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n        return true;\n      };\n      var goToSameSet = function(s1, s2, table, symbol) {\n        if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {\n          return false;\n        }\n        var originalTransitionS1 = table[s1][symbol];\n        var originalTransitionS2 = table[s2][symbol];\n        if (!originalTransitionS1 && !originalTransitionS2) {\n          return true;\n        }\n        return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);\n      };\n      var _slicedToArray = function() {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n          try {\n            for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n              if (i && _arr.length === i)\n                break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"])\n                _i[\"return\"]();\n            } finally {\n              if (_d)\n                throw _e;\n            }\n          }\n          return _arr;\n        }\n        return function(arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n      var currentTransitionMap = null;\n      module.exports = {\n        minimize\n      };\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js\n    var require_dfa = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var DFAMinimizer = require_dfa_minimizer();\n      var _require = require_special_symbols();\n      var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;\n      var DFA = function() {\n        function DFA2(nfa) {\n          _classCallCheck(this, DFA2);\n          this._nfa = nfa;\n        }\n        _createClass(DFA2, [{\n          key: \"minimize\",\n          value: function minimize() {\n            this.getTransitionTable();\n            this._originalAcceptingStateNumbers = this._acceptingStateNumbers;\n            this._originalTransitionTable = this._transitionTable;\n            DFAMinimizer.minimize(this);\n          }\n        }, {\n          key: \"getAlphabet\",\n          value: function getAlphabet() {\n            return this._nfa.getAlphabet();\n          }\n        }, {\n          key: \"getAcceptingStateNumbers\",\n          value: function getAcceptingStateNumbers() {\n            if (!this._acceptingStateNumbers) {\n              this.getTransitionTable();\n            }\n            return this._acceptingStateNumbers;\n          }\n        }, {\n          key: \"getOriginaAcceptingStateNumbers\",\n          value: function getOriginaAcceptingStateNumbers() {\n            if (!this._originalAcceptingStateNumbers) {\n              this.getTransitionTable();\n            }\n            return this._originalAcceptingStateNumbers;\n          }\n        }, {\n          key: \"setTransitionTable\",\n          value: function setTransitionTable(table) {\n            this._transitionTable = table;\n          }\n        }, {\n          key: \"setAcceptingStateNumbers\",\n          value: function setAcceptingStateNumbers(stateNumbers) {\n            this._acceptingStateNumbers = stateNumbers;\n          }\n        }, {\n          key: \"getTransitionTable\",\n          value: function getTransitionTable() {\n            var _this = this;\n            if (this._transitionTable) {\n              return this._transitionTable;\n            }\n            var nfaTable = this._nfa.getTransitionTable();\n            var nfaStates = Object.keys(nfaTable);\n            this._acceptingStateNumbers = new Set;\n            var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];\n            var worklist = [startState];\n            var alphabet = this.getAlphabet();\n            var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();\n            var dfaTable = {};\n            var updateAcceptingStates = function updateAcceptingStates(states2) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n              try {\n                for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var nfaAcceptingState = _step.value;\n                  if (states2.indexOf(nfaAcceptingState) !== -1) {\n                    _this._acceptingStateNumbers.add(states2.join(\",\"));\n                    break;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            };\n            while (worklist.length > 0) {\n              var states = worklist.shift();\n              var dfaStateLabel = states.join(\",\");\n              dfaTable[dfaStateLabel] = {};\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n              try {\n                for (var _iterator2 = alphabet[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  var symbol = _step2.value;\n                  var onSymbol = [];\n                  updateAcceptingStates(states);\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n                  try {\n                    for (var _iterator3 = states[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      var state = _step3.value;\n                      var nfaStatesOnSymbol = nfaTable[state][symbol];\n                      if (!nfaStatesOnSymbol) {\n                        continue;\n                      }\n                      var _iteratorNormalCompletion4 = true;\n                      var _didIteratorError4 = false;\n                      var _iteratorError4 = undefined;\n                      try {\n                        for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4;!(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                          var nfaStateOnSymbol = _step4.value;\n                          if (!nfaTable[nfaStateOnSymbol]) {\n                            continue;\n                          }\n                          onSymbol.push.apply(onSymbol, _toConsumableArray(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));\n                        }\n                      } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                      } finally {\n                        try {\n                          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                          }\n                        } finally {\n                          if (_didIteratorError4) {\n                            throw _iteratorError4;\n                          }\n                        }\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n                  var dfaStatesOnSymbolSet = new Set(onSymbol);\n                  var dfaStatesOnSymbol = [].concat(_toConsumableArray(dfaStatesOnSymbolSet));\n                  if (dfaStatesOnSymbol.length > 0) {\n                    var dfaOnSymbolStr = dfaStatesOnSymbol.join(\",\");\n                    dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;\n                    if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {\n                      worklist.unshift(dfaStatesOnSymbol);\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            }\n            return this._transitionTable = this._remapStateNumbers(dfaTable);\n          }\n        }, {\n          key: \"_remapStateNumbers\",\n          value: function _remapStateNumbers(calculatedDFATable) {\n            var newStatesMap = {};\n            this._originalTransitionTable = calculatedDFATable;\n            var transitionTable = {};\n            Object.keys(calculatedDFATable).forEach(function(originalNumber2, newNumber) {\n              newStatesMap[originalNumber2] = newNumber + 1;\n            });\n            for (var originalNumber in calculatedDFATable) {\n              var originalRow = calculatedDFATable[originalNumber];\n              var row = {};\n              for (var symbol in originalRow) {\n                row[symbol] = newStatesMap[originalRow[symbol]];\n              }\n              transitionTable[newStatesMap[originalNumber]] = row;\n            }\n            this._originalAcceptingStateNumbers = this._acceptingStateNumbers;\n            this._acceptingStateNumbers = new Set;\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n            try {\n              for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5;!(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var _originalNumber = _step5.value;\n                this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n            return transitionTable;\n          }\n        }, {\n          key: \"getOriginalTransitionTable\",\n          value: function getOriginalTransitionTable() {\n            if (!this._originalTransitionTable) {\n              this.getTransitionTable();\n            }\n            return this._originalTransitionTable;\n          }\n        }, {\n          key: \"matches\",\n          value: function matches(string) {\n            var state = 1;\n            var i = 0;\n            var table = this.getTransitionTable();\n            while (string[i]) {\n              state = table[state][string[i++]];\n              if (!state) {\n                return false;\n              }\n            }\n            if (!this.getAcceptingStateNumbers().has(state)) {\n              return false;\n            }\n            return true;\n          }\n        }]);\n        return DFA2;\n      }();\n      module.exports = DFA;\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js\n    var require_state = __commonJS((exports, module) => {\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var State = function() {\n        function State2() {\n          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$accepting = _ref.accepting, accepting = _ref$accepting === undefined ? false : _ref$accepting;\n          _classCallCheck(this, State2);\n          this._transitions = new Map;\n          this.accepting = accepting;\n        }\n        _createClass(State2, [{\n          key: \"getTransitions\",\n          value: function getTransitions() {\n            return this._transitions;\n          }\n        }, {\n          key: \"addTransition\",\n          value: function addTransition(symbol, toState) {\n            this.getTransitionsOnSymbol(symbol).add(toState);\n            return this;\n          }\n        }, {\n          key: \"getTransitionsOnSymbol\",\n          value: function getTransitionsOnSymbol(symbol) {\n            var transitions = this._transitions.get(symbol);\n            if (!transitions) {\n              transitions = new Set;\n              this._transitions.set(symbol, transitions);\n            }\n            return transitions;\n          }\n        }]);\n        return State2;\n      }();\n      module.exports = State;\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js\n    var require_nfa_state = __commonJS((exports, module) => {\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var _possibleConstructorReturn = function(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      };\n      var _inherits = function(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n        if (superClass)\n          Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      };\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var State = require_state();\n      var _require = require_special_symbols();\n      var EPSILON = _require.EPSILON;\n      var NFAState = function(_State) {\n        _inherits(NFAState2, _State);\n        function NFAState2() {\n          _classCallCheck(this, NFAState2);\n          return _possibleConstructorReturn(this, (NFAState2.__proto__ || Object.getPrototypeOf(NFAState2)).apply(this, arguments));\n        }\n        _createClass(NFAState2, [{\n          key: \"matches\",\n          value: function matches(string) {\n            var visited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set;\n            if (visited.has(this)) {\n              return false;\n            }\n            visited.add(this);\n            if (string.length === 0) {\n              if (this.accepting) {\n                return true;\n              }\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n              try {\n                for (var _iterator = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var nextState = _step.value;\n                  if (nextState.matches(\"\", visited)) {\n                    return true;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n              return false;\n            }\n            var symbol = string[0];\n            var rest = string.slice(1);\n            var symbolTransitions = this.getTransitionsOnSymbol(symbol);\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n              for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var _nextState = _step2.value;\n                if (_nextState.matches(rest)) {\n                  return true;\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n              for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var _nextState2 = _step3.value;\n                if (_nextState2.matches(string, visited)) {\n                  return true;\n                }\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n            return false;\n          }\n        }, {\n          key: \"getEpsilonClosure\",\n          value: function getEpsilonClosure() {\n            var _this2 = this;\n            if (!this._epsilonClosure) {\n              (function() {\n                var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON);\n                var closure = _this2._epsilonClosure = new Set;\n                closure.add(_this2);\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n                try {\n                  for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4;!(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var nextState = _step4.value;\n                    if (!closure.has(nextState)) {\n                      closure.add(nextState);\n                      var nextClosure = nextState.getEpsilonClosure();\n                      nextClosure.forEach(function(state) {\n                        return closure.add(state);\n                      });\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError4 = true;\n                  _iteratorError4 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                      _iterator4.return();\n                    }\n                  } finally {\n                    if (_didIteratorError4) {\n                      throw _iteratorError4;\n                    }\n                  }\n                }\n              })();\n            }\n            return this._epsilonClosure;\n          }\n        }]);\n        return NFAState2;\n      }(State);\n      module.exports = NFAState;\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js\n    var require_builders = __commonJS((exports, module) => {\n      var char = function(c) {\n        var inState = new NFAState;\n        var outState = new NFAState({\n          accepting: true\n        });\n        return new NFA(inState.addTransition(c, outState), outState);\n      };\n      var e = function() {\n        return char(EPSILON);\n      };\n      var altPair = function(first, second) {\n        first.out.accepting = false;\n        second.out.accepting = true;\n        first.out.addTransition(EPSILON, second.in);\n        return new NFA(first.in, second.out);\n      };\n      var alt = function(first) {\n        for (var _len = arguments.length, fragments = Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {\n          fragments[_key - 1] = arguments[_key];\n        }\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = fragments[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var fragment = _step.value;\n            first = altPair(first, fragment);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        return first;\n      };\n      var orPair = function(first, second) {\n        var inState = new NFAState;\n        var outState = new NFAState;\n        inState.addTransition(EPSILON, first.in);\n        inState.addTransition(EPSILON, second.in);\n        outState.accepting = true;\n        first.out.accepting = false;\n        second.out.accepting = false;\n        first.out.addTransition(EPSILON, outState);\n        second.out.addTransition(EPSILON, outState);\n        return new NFA(inState, outState);\n      };\n      var or = function(first) {\n        for (var _len2 = arguments.length, fragments = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {\n          fragments[_key2 - 1] = arguments[_key2];\n        }\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = fragments[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var fragment = _step2.value;\n            first = orPair(first, fragment);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n        return first;\n      };\n      var repExplicit = function(fragment) {\n        var inState = new NFAState;\n        var outState = new NFAState({\n          accepting: true\n        });\n        inState.addTransition(EPSILON, fragment.in);\n        inState.addTransition(EPSILON, outState);\n        fragment.out.accepting = false;\n        fragment.out.addTransition(EPSILON, outState);\n        outState.addTransition(EPSILON, fragment.in);\n        return new NFA(inState, outState);\n      };\n      var rep = function(fragment) {\n        fragment.in.addTransition(EPSILON, fragment.out);\n        fragment.out.addTransition(EPSILON, fragment.in);\n        return fragment;\n      };\n      var plusRep = function(fragment) {\n        fragment.out.addTransition(EPSILON, fragment.in);\n        return fragment;\n      };\n      var questionRep = function(fragment) {\n        fragment.in.addTransition(EPSILON, fragment.out);\n        return fragment;\n      };\n      var NFA = require_nfa();\n      var NFAState = require_nfa_state();\n      var _require = require_special_symbols();\n      var EPSILON = _require.EPSILON;\n      module.exports = {\n        alt,\n        char,\n        e,\n        or,\n        rep,\n        repExplicit,\n        plusRep,\n        questionRep\n      };\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js\n    var require_nfa_from_regexp = __commonJS((exports, module) => {\n      var _toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      };\n      var gen = function(node) {\n        if (node && !generator[node.type]) {\n          throw new Error(node.type + \" is not supported in NFA/DFA interpreter.\");\n        }\n        return node ? generator[node.type](node) : \"\";\n      };\n      var parser = require_parser();\n      var _require = require_builders();\n      var alt = _require.alt;\n      var char = _require.char;\n      var or = _require.or;\n      var rep = _require.rep;\n      var plusRep = _require.plusRep;\n      var questionRep = _require.questionRep;\n      var generator = {\n        RegExp: function RegExp(node) {\n          if (node.flags !== \"\") {\n            throw new Error(\"NFA/DFA: Flags are not supported yet.\");\n          }\n          return gen(node.body);\n        },\n        Alternative: function Alternative(node) {\n          var fragments = (node.expressions || []).map(gen);\n          return alt.apply(undefined, _toConsumableArray(fragments));\n        },\n        Disjunction: function Disjunction(node) {\n          return or(gen(node.left), gen(node.right));\n        },\n        Repetition: function Repetition(node) {\n          switch (node.quantifier.kind) {\n            case \"*\":\n              return rep(gen(node.expression));\n            case \"+\":\n              return plusRep(gen(node.expression));\n            case \"?\":\n              return questionRep(gen(node.expression));\n            default:\n              throw new Error(\"Unknown repeatition: \" + node.quantifier.kind + \".\");\n          }\n        },\n        Char: function Char(node) {\n          if (node.kind !== \"simple\") {\n            throw new Error(\"NFA/DFA: Only simple chars are supported yet.\");\n          }\n          return char(node.value);\n        },\n        Group: function Group(node) {\n          return gen(node.expression);\n        }\n      };\n      module.exports = {\n        build: function build(regexp) {\n          var ast = regexp;\n          if (regexp instanceof RegExp) {\n            regexp = \"\" + regexp;\n          }\n          if (typeof regexp === \"string\") {\n            ast = parser.parse(regexp, {\n              captureLocations: true\n            });\n          }\n          return gen(ast);\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js\n    var require_finite_automaton = __commonJS((exports, module) => {\n      var NFA = require_nfa();\n      var DFA = require_dfa();\n      var nfaFromRegExp = require_nfa_from_regexp();\n      var builders = require_builders();\n      module.exports = {\n        NFA,\n        DFA,\n        builders,\n        toNFA: function toNFA(regexp) {\n          return nfaFromRegExp.build(regexp);\n        },\n        toDFA: function toDFA(regexp) {\n          return new DFA(this.toNFA(regexp));\n        },\n        test: function test(regexp, string) {\n          return this.toDFA(regexp).matches(string);\n        }\n      };\n    });\n\n    // node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js\n    var require_runtime = __commonJS((exports, module) => {\n      var _classCallCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      };\n      var _createClass = function() {\n        function defineProperties(target, props) {\n          for (var i = 0;i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n              descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n        return function(Constructor, protoProps, staticProps) {\n          if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n          if (staticProps)\n            defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n      var RegExpTree = function() {\n        function RegExpTree2(re, _ref) {\n          var { flags, groups, source } = _ref;\n          _classCallCheck(this, RegExpTree2);\n          this._re = re;\n          this._groups = groups;\n          this.flags = flags;\n          this.source = source || re.source;\n          this.dotAll = flags.includes(\"s\");\n          this.global = re.global;\n          this.ignoreCase = re.ignoreCase;\n          this.multiline = re.multiline;\n          this.sticky = re.sticky;\n          this.unicode = re.unicode;\n        }\n        _createClass(RegExpTree2, [{\n          key: \"test\",\n          value: function test(string) {\n            return this._re.test(string);\n          }\n        }, {\n          key: \"compile\",\n          value: function compile(string) {\n            return this._re.compile(string);\n          }\n        }, {\n          key: \"toString\",\n          value: function toString() {\n            if (!this._toStringResult) {\n              this._toStringResult = \"/\" + this.source + \"/\" + this.flags;\n            }\n            return this._toStringResult;\n          }\n        }, {\n          key: \"exec\",\n          value: function exec(string) {\n            var result = this._re.exec(string);\n            if (!this._groups || !result) {\n              return result;\n            }\n            result.groups = {};\n            for (var group in this._groups) {\n              var groupNumber = this._groups[group];\n              result.groups[group] = result[groupNumber];\n            }\n            return result;\n          }\n        }]);\n        return RegExpTree2;\n      }();\n      module.exports = {\n        RegExpTree\n      };\n    });\n\n    // node_modules/regexp-tree/dist/regexp-tree.js\n    var require_regexp_tree2 = __commonJS((exports, module) => {\n      var compatTranspiler = require_compat_transpiler();\n      var generator = require_generator();\n      var optimizer = require_optimizer();\n      var parser = require_parser();\n      var _transform = require_transform();\n      var _traverse = require_traverse();\n      var fa = require_finite_automaton();\n      var _require = require_runtime();\n      var RegExpTree = _require.RegExpTree;\n      var regexpTree = {\n        parser,\n        fa,\n        TransformResult: _transform.TransformResult,\n        parse: function parse(regexp, options) {\n          return parser.parse(\"\" + regexp, options);\n        },\n        traverse: function traverse(ast, handlers, options) {\n          return _traverse.traverse(ast, handlers, options);\n        },\n        transform: function transform(regexp, handlers) {\n          return _transform.transform(regexp, handlers);\n        },\n        generate: function generate(ast) {\n          return generator.generate(ast);\n        },\n        toRegExp: function toRegExp(regexp) {\n          var compat = this.compatTranspile(regexp);\n          return new RegExp(compat.getSource(), compat.getFlags());\n        },\n        optimize: function optimize(regexp, whitelist) {\n          var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, blacklist = _ref.blacklist;\n          return optimizer.optimize(regexp, { whitelist, blacklist });\n        },\n        compatTranspile: function compatTranspile(regexp, whitelist) {\n          return compatTranspiler.transform(regexp, whitelist);\n        },\n        exec: function exec(re, string) {\n          if (typeof re === \"string\") {\n            var compat = this.compatTranspile(re);\n            var extra = compat.getExtra();\n            if (extra.namedCapturingGroups) {\n              re = new RegExpTree(compat.toRegExp(), {\n                flags: compat.getFlags(),\n                source: compat.getSource(),\n                groups: extra.namedCapturingGroups\n              });\n            } else {\n              re = compat.toRegExp();\n            }\n          }\n          return re.exec(string);\n        }\n      };\n      module.exports = regexpTree;\n    });\n\n    // src/enumerateMatches.ts\n    var import_regexp_tree = __toESM(require_regexp_tree2(), 1);\n\n    // src/utils.ts\n    function* getCombinations(length, elementsGen) {\n      const { value, done } = elementsGen.next();\n      if (done) {\n        return [];\n      }\n      const indexes = Array(length).fill(0);\n      const elements = [value];\n      while (true) {\n        yield indexes.map((i) => elements[i]);\n        const { value: value2, done: done2 } = elementsGen.next();\n        if (!done2) {\n          elements.push(value2);\n        }\n        for (let i = length - 1;; i--) {\n          if (i < 0) {\n            return elements;\n          }\n          indexes[i]++;\n          if (indexes[i] === elements.length) {\n            indexes[i] = 0;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    var getNResults = (gen, n = Infinity) => {\n      let i = 0;\n      let hasWork = true;\n      const results = [];\n      while (i < n && hasWork) {\n        const { value, done } = gen.next();\n        if (!done)\n          results.push(value);\n        hasWork = !done;\n        i++;\n      }\n      return results;\n    };\n    var getRange = (min, max) => Array(max - min + 1).fill(0).map((_, i) => min + i);\n    var getCharRange = (from, to, negative = false) => {\n      if (negative) {\n        return asciiRange.filter((codePoint) => codePoint < from || codePoint > to).map((codePoint) => String.fromCodePoint(codePoint));\n      }\n      return getRange(from, to).map((codePoint) => String.fromCodePoint(codePoint));\n    };\n    var asciiRange = getRange(32, 126);\n    var Generator = {\n      map: (f, g) => function* () {\n        for (const x of g) {\n          yield f(x);\n        }\n      }(),\n      forEach: (f, g) => function* () {\n        for (const x of g) {\n          f(x);\n          yield x;\n        }\n      }(),\n      pipe: (fs, g) => function* () {\n        const [f, ...rest] = fs;\n        for (const x of g) {\n          const seed = f(x);\n          yield rest.reduce((acc, f2) => f2(acc), seed);\n        }\n      }(),\n      flatten: (gen) => {\n        return Generator.map((arr) => arr.flat(), gen);\n      },\n      join: (gen, separator = \"\") => Generator.map((arr) => arr.join(separator), gen),\n      log: (gen) => Generator.map((arr) => {\n        console.log(\"log\", arr);\n        return arr;\n      }, gen),\n      concat: function* (gens) {\n        for (const gen of gens) {\n          for (const x of gen) {\n            yield x;\n          }\n        }\n      },\n      fromArray: (output) => {\n        return function* () {\n          for (const element of output) {\n            yield element;\n          }\n        }();\n      },\n      repeat: function* (gen, node, from, to = Infinity) {\n        if (from === 0) {\n          yield { value: \"\", node, children: [] };\n          from++;\n        }\n        let elements = undefined;\n        for (let curFrom = from;curFrom <= to; curFrom++) {\n          const source = elements ? Generator.fromArray(elements) : gen;\n          const combinationsGen = getCombinations(curFrom, source);\n          while (true) {\n            const { value, done } = combinationsGen.next();\n            if (done) {\n              elements = value;\n              break;\n            }\n            yield {\n              value: value.map((output) => output.value).join(\"\"),\n              node,\n              children: Array.from(new Set(value.flatMap((output) => output.children)))\n            };\n          }\n        }\n      }\n    };\n    var getGroupId = (groupNumber) => `\\$__GROUP${groupNumber}__\\$`;\n    var getGeneratorOutputFromBranchNode = (node, source) => Generator.map((result) => ({\n      value: result.value,\n      node,\n      children: [result]\n    }), source);\n    var getGeneratorOutputFromLeafNode = (node, source) => Generator.map((result) => ({\n      value: result,\n      node,\n      children: []\n    }), source);\n\n    // src/enumerateMatches.ts\n    var getGeneratorFromNode = function(node, context = { groups: {}, backreferences: {} }, negative = false) {\n      if (!node) {\n        return Generator.fromArray([]);\n      }\n      return generators[node.type](node, context, negative);\n    };\n    function* combineOrderedSources(sources) {\n      let sourceIndex = 0;\n      const sourcesAndOutput = sources.map((source) => {\n        const { value } = source.next();\n        return { source, output: [value], index: 0 };\n      });\n      while (true) {\n        const outputs = sourcesAndOutput.map((s) => s.output[s.index]);\n        yield outputs.flat();\n        let current = sourcesAndOutput[sourceIndex];\n        const askForAnotherPermutation = sourcesAndOutput.every((s) => s.index === s.output.length - 1);\n        current.index++;\n        if (askForAnotherPermutation) {\n          let { value, done } = current.source.next();\n          if (done) {\n            while (true) {\n              sourceIndex++;\n              current = sourcesAndOutput[sourceIndex];\n              if (!current) {\n                return;\n              }\n              const { value: nextValue, done: nextDone } = current.source.next();\n              if (!nextDone) {\n                value = nextValue;\n                break;\n              }\n            }\n          }\n          current.output.push(value);\n          current.index = current.output.length - 1;\n          if (sourceIndex > 0) {\n            sourcesAndOutput.slice(0, sourceIndex).forEach((s) => s.index = 0);\n            sourceIndex = 0;\n          }\n        }\n        const isBeyondLastIndex = current.index > current.output.length - 1;\n        if (isBeyondLastIndex) {\n          current.index = 0;\n          let nextIndex = sourceIndex + 1;\n          while (true) {\n            const maybeNextSource = sourcesAndOutput[nextIndex];\n            if (maybeNextSource.index < maybeNextSource.output.length - 1) {\n              maybeNextSource.index++;\n              break;\n            }\n            maybeNextSource.index = 0;\n            nextIndex++;\n          }\n        }\n      }\n    }\n    var generateMatches = (expr) => Generator.map((result) => result.value, getGeneratorFromNode(import_regexp_tree.parse(expr, { allowGroupNameDuplicates: false })));\n    var generateMatchesViz = (node) => getGeneratorFromNode(node);\n    var enumerateMatches = (expr, limit = Infinity) => getNResults(generateMatches(expr), limit);\n    var generators = {\n      Char: (node, _, negative = false) => {\n        const { from, to } = (() => {\n          switch (node.kind) {\n            case \"meta\":\n              return getRangeFromMetaChar(node);\n            default:\n              return { from: node.codePoint, to: node.codePoint };\n          }\n        })();\n        const source = Generator.fromArray(getCharRange(from, to));\n        return getGeneratorOutputFromLeafNode(node, source);\n      },\n      Disjunction: (node, context) => {\n        const left = getGeneratorFromNode(node.left, context);\n        const right = getGeneratorFromNode(node.right, context);\n        const source = Generator.concat([left, right].filter(Boolean));\n        return getGeneratorOutputFromBranchNode(node, source);\n      },\n      RegExp: (node, context) => {\n        const source = Generator.pipe([addBackreferencesFromGroups(context), stripEmptyBackreferences(context)], getGeneratorFromNode(node.body, context));\n        return getGeneratorOutputFromBranchNode(node, source);\n      },\n      Alternative: (node, context) => {\n        const sources = combineOrderedSources(node.expressions.map((node2) => getGeneratorFromNode(node2, context)));\n        return Generator.map((results) => ({\n          value: results.map((_) => _.value).join(\"\"),\n          children: results,\n          node\n        }), sources);\n      },\n      Assertion: (node) => {\n        const source = Generator.fromArray([\"\"]);\n        return getGeneratorOutputFromLeafNode(node, source);\n      },\n      CharacterClass: (node, context) => {\n        const source = Generator.concat(node.expressions.map((expr) => getGeneratorFromNode(expr, context, node.negative)));\n        return getGeneratorOutputFromBranchNode(node, source);\n      },\n      ClassRange: (node, _, negative = false) => {\n        const source = Generator.fromArray(getCharRange(node.from.codePoint, node.to.codePoint, negative));\n        return getGeneratorOutputFromLeafNode(node, source);\n      },\n      Backreference: (node, context) => {\n        const source = Generator.forEach((result) => {\n          if (context.groups[node.number.toString()]) {\n            context.backreferences[node.number.toString()] = result;\n          }\n        }, Generator.fromArray([getGroupId(node.number.toString())]));\n        return getGeneratorOutputFromLeafNode(node, source);\n      },\n      Group: (node, context) => {\n        const generator = getGeneratorFromNode(node.expression, context);\n        if (!node.capturing) {\n          return getGeneratorOutputFromBranchNode(node, generator);\n        }\n        const source = Generator.forEach((result) => {\n          context.groups[node.number.toString()] = result.value;\n        }, generator);\n        return getGeneratorOutputFromBranchNode(node, source);\n      },\n      Repetition: (node, context) => {\n        const { from, to } = (() => {\n          switch (node.quantifier.kind) {\n            case \"Range\":\n              return { from: node.quantifier.from, to: node.quantifier.to };\n            case \"+\":\n              return { from: 1, to: Infinity };\n            case \"*\":\n              return { from: 0, to: Infinity };\n            case \"?\":\n              return { from: 0, to: 1 };\n          }\n        })();\n        return Generator.repeat(getGeneratorFromNode(node.expression, context), node, from, to);\n      },\n      Quantifier: (node, _) => noopIter(node)\n    };\n    var noopIter = (node) => {\n      console.log(`No generator for ${node.type}`);\n      return Generator.fromArray([]);\n    };\n    var addBackreferencesFromGroups = (context) => (result) => ({\n      node: result.node,\n      children: result.children,\n      value: Object.entries(context.groups).reduce((acc, [groupNumber, groupValue]) => context.backreferences[groupNumber] ? acc.replaceAll(getGroupId(groupNumber), groupValue) : acc, result.value)\n    });\n    var stripEmptyBackreferences = (context) => (result) => ({\n      node: result.node,\n      children: result.children,\n      value: Object.entries(context.groups).reduce((acc, [groupNumber]) => acc.replaceAll(getGroupId(groupNumber), \"\"), result.value)\n    });\n    var getRangeFromMetaChar = (node) => {\n      switch (node.value) {\n        case \".\":\n          return { from: 32, to: 126 };\n        default:\n          return { from: node.codePoint, to: node.codePoint };\n      }\n    };\n\n    window.parse = import_regexp_tree.parse;\n    window.generateMatches = generateMatches;\n    window.enumerateMatches = enumerateMatches;\n    window.generateMatchesViz = generateMatchesViz;\n\n  // Render code\n  window.createRegexGraph = (regex, mountEl, allowEdit = false) => {\n    function generateId() {\n      var firstPart = (Math.random() * 46656) | 0;\n      var secondPart = (Math.random() * 46656) | 0;\n      firstPart = (\"000\" + firstPart.toString(36)).slice(-3);\n      secondPart = (\"000\" + secondPart.toString(36)).slice(-3);\n      return firstPart + secondPart;\n    }\n\n    const renderNode = (node) => nodeToHTML[node.type](node);\n\n    const getNodeAndChildHTML = (node, content, description) => {\n      // Tag nodes with UIDs as we render them so we can reference them when traversing our output\n      const uid = generateId();\n      node.uid = uid;\n      return `<li> <span id=\"${uid}\" class=\"node-description\">${description ? description : node.type}</span> ${content ? `<ul>${content}</ul>` : ''}</li>`\n    };\n\n    const addEl = (tagName, node, { attrs = {}, innerHTML } = {}, prepend = false) => {\n      const el = document.createElement(tagName);\n      if (innerHTML) {\n        el.innerHTML = innerHTML;\n      }\n      Object.entries(attrs).forEach(([attr, val]) => {\n        el.setAttribute(attr, val);\n      })\n      prepend ? node.prepend(el) : node.appendChild(el);\n      return el;\n    }\n\n    const nodeToHTML = {\n      Char: (node) => getNodeAndChildHTML(node, undefined, `${node.kind === 'meta' ? 'Meta char' : 'Char'}: '${node.value}'`),\n      Disjunction: (node, context) => getNodeAndChildHTML(node, `${renderNode(node.left)}${renderNode(node.right)}`),\n      RegExp: (node) => getNodeAndChildHTML(node, renderNode(node.body)),\n      Alternative: node => getNodeAndChildHTML(node, node.expressions.map(renderNode).join(\"\")),\n      Assertion: (node) => getNodeAndChildHTML(node, undefined, `Assertion: ${node.kind}`),\n      CharacterClass: (node) => getNodeAndChildHTML(node, node.expressions.map(renderNode).join(\"\")),\n      ClassRange: (node) => getNodeAndChildHTML(node, undefined, `ClassRange: ${node.from.value}-${node.to.value}`),\n      Backreference: (node) => getNodeAndChildHTML(node, `Backreference: group ${node.number}`),\n      Group: (node, context) => getNodeAndChildHTML(node, renderNode(node.expression)),\n      Repetition: (node, context) => {\n        const { from, to } = (() => {\n          switch (node.quantifier.kind) {\n            case \"Range\":\n              return { from: node.quantifier.from, to: node.quantifier.to };\n            case \"+\":\n              return { from: 1, to: Infinity };\n            case \"*\":\n              return { from: 0, to: Infinity };\n            case \"?\":\n              return { from: 0, to: 1 };\n          }\n        })();\n\n        return getNodeAndChildHTML(node, renderNode(node.expression), `Quantifier: ${from}, ${to}`)\n      },\n      // Quantifier: (node, _) => noopIter(node),\n    };\n\n    const graphEl = addEl('div', mountEl, { attrs: { class: 'regex--container' }})\n\n    let input;\n    if (allowEdit) {\n      const inputContainer = addEl('div', graphEl, { attrs: { class: 'regex--input-container' }})\n      input = addEl('input', inputContainer, { attrs: {value: regex}});\n      input.addEventListener(\"input\", e => applyRegex(e.target.value));\n    }\n    const transport = addEl('div', graphEl, { attrs: { class: 'regex--transport' }});\n    const outputContainer = addEl('div', graphEl, { attrs: { class: 'regex--output-container' }});\n    const output = addEl('div', outputContainer, { attrs: { class: 'regex--output' }});\n    const outputExpand = addEl('div', outputContainer, { attrs: { class: 'arrow arrow-down' }});\n    const button = addEl('button', transport, { innerHTML: 'Next value'});\n    const resetBtn = addEl('button', transport, { innerHTML: 'Reset'});\n    const treeContainer = addEl('div', graphEl, { attrs: { class: 'tree--container' }})\n    const tree = addEl('ul', treeContainer, { attrs: { class: 'tree' }});\n\n    let generator = null;\n\n    const applyRegex = (regex) => {\n      try {\n        output.innerHTML = \"\";\n        button.disabled = false;\n        const ast = parse(`/${regex}/`);\n        generator = generateMatchesViz(ast);\n        const html = renderNode(ast);\n        tree.innerHTML = html;\n        getNewIteration();\n      } catch(e) {\n        tree.innerHTML = `Error: ${e.message}`;\n      }\n    }\n\n    const resetNodes = () =>\n      graphEl.querySelectorAll('li > .node-description').forEach(node => {\n        node.setAttribute(\"style\", \"\");\n        node.querySelectorAll(\".node-content\").forEach(child => node.removeChild(child));\n      });\n\n    const getNewIteration = () => {\n      const { value, done } = generator.next();\n\n      if (value) {\n        resetNodes();\n        applySelectionToDom(value);\n        addEl('div', output, { innerHTML: value.value }, true);\n        if (output.children.length > 1) {\n          outputExpand.classList.add(\"arrow__visible\");\n        } else {\n          outputExpand.classList.remove(\"arrow__visible\");\n        }\n      }\n\n      if (done) {\n        button.disabled = true;\n      }\n    }\n\n    const applySelectionToDom = output => {\n      const domNode = document.getElementById(output.node.uid);\n      domNode.setAttribute(\"style\", \"background-color: #b6caf1;\");\n\n      if (!output.value) {\n        return;\n      }\n\n      const content = document.createElement('span');\n      content.className = \"node-content\";\n      content.innerText = output.value;\n      domNode.appendChild(content);\n\n      output.children.forEach(applySelectionToDom);\n    }\n\n    button.addEventListener(\"click\", getNewIteration);\n    resetBtn.addEventListener(\"click\", () => applyRegex(allowEdit ? input.value : regex));\n\n    outputContainer.addEventListener(\"click\", () => {\n      output.classList.toggle(\"regex--output__open\");\n      outputExpand.classList.toggle(\"arrow-down\");\n      outputExpand.classList.toggle(\"arrow-up\");\n    });\n\n    applyRegex(regex);\n  }\n\n  document.querySelectorAll(\"[data-regex]\").forEach(el => {\n    createRegexGraph(el.getAttribute('data-regex'), el, el.getAttribute('data-allow-edit'))\n  });\n\n  const scriptEl = document.getElementById('page-script');\n  scriptEl.setAttribute('data-has-run', true);\n</script>\n<style>\n  input + button {\n    margin-left: 5px;\n  }\n\n  button + button {\n    margin-left: 5px;\n  }\n\n  [data-regex] {\n    position: relative;\n    width: 100vw;\n    /* Hack center: the internal column width is 54em. */\n    left: calc((-100vw + 54rem) / 2);\n    padding: 5px;\n  }\n\n  [data-regex] .tree {\n    display: block;\n    max-width: 100%;\n    margin-top: 5px;\n    overflow-y: scroll;\n  }\n\n  .regex--container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    width: 100%;\n  }\n\n  .regex--container input {\n    margin-bottom: 5px;\n  }\n\n  .regex--transport {\n    margin-bottom: 20px;\n  }\n\n  .regex--output {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    font-family: monospace;\n    height: 1rem;\n    overflow: hidden;\n  }\n\n  .regex--output.regex--output__open {\n    height: auto;\n  }\n\n  .regex--output-container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    cursor: pointer;\n  }\n\n  .regex--input-container {\n    font-family: monospace;\n  }\n\n  .regex--input-container::before,\n  .regex--input-container::after {\n    content: '/';\n    padding: 3px;\n  }\n\n  .tree--container {\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    width: 100%;\n  }\n\n  .arrow {\n    margin: 5px 0;\n    width: 0;\n    height: 0;\n    display: none;\n    visibility: hidden;\n  }\n\n  .arrow__visible {\n    display: block;\n    visibility: visible;\n  }\n\n  .arrow-down {\n    border-left: 10px solid transparent;\n    border-right: 10px solid transparent;\n    border-top: 10px solid #333;\n  }\n\n  .arrow-up {\n    border-left: 10px solid transparent;\n    border-right: 10px solid transparent;\n    border-bottom: 10px solid #333;\n  }\n\n  /*https://www.cssscript.com/clean-tree-diagram/*/\n  .tree,\n  .tree ul,\n  .tree li {\n    font-family: monospace;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    position: relative;\n  }\n\n  .tree {\n    margin: 0 0 1em;\n    text-align: center;\n  }\n\n  .tree,\n  .tree ul {\n    display: table;\n  }\n\n  .tree ul {\n    width: 100%;\n  }\n\n  .tree li {\n    display: table-cell;\n    padding: .5em 0;\n    vertical-align: top;\n  }\n\n  .tree li:before {\n    outline: solid 0.5px #666;\n    content: \"\";\n    left: 0;\n    position: absolute;\n    right: 0;\n    top: -1px;\n  }\n\n  .tree li:first-child:before {\n    left: 50%;\n  }\n\n  .tree li:last-child:before {\n    right: 50%;\n  }\n\n  .tree code,\n  .tree li > span {\n    background-color: #ddd;\n    border-radius: .2em;\n    display: inline-block;\n    margin: 0 .2em .5em;\n    padding: .2em .5em;\n    position: relative;\n  }\n\n  .node-content {\n    background-color: white;\n    margin-left: 5px;\n    padding: 1px 5px;\n  }\n\n  .tree ul:before,\n  .tree code:before,\n  .tree li > span:before {\n    outline: solid 0.5px #666;\n    content: \"\";\n    height: .5em;\n    left: 50%;\n    position: absolute;\n  }\n\n  .tree ul:before {\n    top: -.5em;\n  }\n\n  .tree code:before,\n  .tree li > span:before {\n    top: -.55em;\n  }\n\n  .tree>li {\n    margin-top: 0;\n  }\n\n  .tree>li:before,\n  .tree>li:after,\n  .tree>li>code:before,\n  .tree>li>.span:before {\n    outline: none;\n  }\n</style>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><sub>Minus the fifty or so PhDs specialising in natural language processing.</sub><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><sub><a href=\"https://groups.google.com/g/comp.lang.python/c/-cnACi-RnCY/m/NlJs5ZNc0YUJ?hl=en#:~:text=%22Some%20people%2C%20when%20confronted%20with%20a%20problem%2C%20think%20%27I%20know%2C%20I%27ll%20use%0Aregular%20expressions.%27%20Now%20they%20have%20two%20problems.%22\">Oldie but goodie.</a></sub><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"Writing a program to generate every string a regular expression will match","date":"January 11, 2024","description":"Like, _all_ of them"}}},"pageContext":{"slug":"/enumerate-matches/","previous":{"fields":{"slug":"/fear-and-problem-solving/"},"frontmatter":{"title":"Fear and good problem solving are mutually exclusive"}},"next":{"fields":{"slug":"/structured-search-ui-1/"},"frontmatter":{"title":"Structured search queries for web UIs, part 1: the dream"}}}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}