{"componentChunkName":"component---src-templates-blog-post-js","path":"/structured-search-ui-1/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"991e7a8c-1942-537d-8447-861a5f965a88","excerpt":"There’s a UI pattern for search that I’ve seen implemented in a few places. In line with the convention at the Guardian, I’m going to call that pattern ‘chips…","html":"<p>There’s a UI pattern for search that I’ve seen implemented in a few places. In line with the convention at the Guardian, I’m going to call that pattern ‘chips’ — a way of adding field-specific search terms to search queries as you type, with typeahead to aid discoverability.</p>\n<p>This sounds like a lovely thing to have at an organisation that catalogues tens of thousands of images and publishes around three hundred pieces a day — in short, an organisation awash with content of every sort to discover.</p>\n<p>But! Every implementation of a chip-based (or chip-ish) search interface that I am aware of, either at the Guardian, or elsewhere, falls a bit short. By looking at a few examples, let’s build up a feature list for the sort of thing we’d <em>like</em> to have.</p>\n<p>Before we begin: lots of credit here to <a href=\"https://github.com/paperboyo\">paperboyo</a>, a product manager at the Guardian whose chip-related thoughts inspire a lot of the below 🍟</p>\n<h2>All that and a bag of chips <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></h2>\n<p>Here are chips in the Guardian (and now the BBC’s) open source image management tool, <a href=\"https://github.com/guardian/grid\"><strong>the Grid</strong></a>:</p>\n<p><img src=\"/7156a26efef7a4fed80113fdf72faa43/grid-chips.gif\" alt=\"grid-chips\"></p>\n<p>This is a neat feature. The tool’s comprehensive search indicies are discoverable from the keyboard, as you’re writing the search query. There a few drawbacks to the Grid’s implementation, though. Chips can only be added at the front of the search. They’re added <em>from</em> the text input, but they’re not a part of its value, and so you cannot navigate back to them with the caret to edit or remove them. Because of this, the way the caret moves between chips and the search input is unpredictable, and sometimes buggy.</p>\n<p>A similar pattern is used in <strong>AWS EC2 instance search</strong> (and elsewhere in the AWS dashboard), and although you cannot navigate between chips with the caret, it <em>is</em> possible to navigate to them with the keyboard via the tab key, making keyboard-only input possible.</p>\n<p><img src=\"/32909dd93c58802d42c9d4458c438b92/aws-chips.gif\" alt=\"aws-chips\"></p>\n<p><a href=\"https://github.com/guardian/giant\"><strong>Giant</strong></a>, the Guardian’s open-source document ingestion and search platform, goes further. Alongside correct caret behaviour (but not selection behaviour — each chip is its own input, and selection cannot cut across chips or search terms), the chips are inline with the query, an affordance which implies that their order might be important.</p>\n<p><img src=\"/e878e2b4bebe415e87156670e95ee87e/giant-chips.gif\" alt=\"giant-chips\"></p>\n<p>In fact, order <em>is</em> an important feature! Giant supports binary operators and groups (e.g. <code class=\"language-text\">this AND (that OR those)</code>) for both general search terms and chip fields. But there’s nothing to signify that this is possible, or that it’s working when you have used it, something syntax highlighting might make clearer.</p>\n<p>It’s worth comparing these UIs to the query languages in tools like <a href=\"https://www.elastic.co/kibana\"><strong>Kibana</strong></a> (which is powered by Lucene, or another query language similar to Lucene, KQL, which has a few features that are useful for Elasticsearch.) Here’s Kibana’s Discover mode in action:</p>\n<p><img src=\"/2d2c4827321b25ba6c51e97373fd416e/elk-chips.gif\" alt=\"elk-chips\"></p>\n<p>A text query language offers the ultimate in editability. As a single document, editing and copy-and-pasting values just works.</p>\n<p>Interestingly (ironically?), discoverability in this input is limited: I cannot discover an index (Elasticsearch would call it a field) without beginning to type, and so browsing indices via the query prompt is impossible. I also cannot discover a subset of values for an index once I have specified it — where, for example, typing <code class=\"language-text\">stage:</code> might offer <code class=\"language-text\">CODE|PROD|TEST</code>. This is possible in the menu on the right hand side on the Discover page, but it’d be nice to do it within the input itself for the purposes of our specification.</p>\n<p>But there’s no syntax highlighting, and if you get something wrong, the failure mode is a binary ‘search failed’, repeated across the <code class=\"language-text\">n</code> shards you were searching — despite there being a query grammar! A missed opportunity.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\n                text-align: center;\n                color: #b1afaf;\n                font-size: 0.75em;\n              \">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4333a4092ed4ec96f1cfa7fb6d9a2f49/5c5b6/elk-fail.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.65625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAqUlEQVR42p2QywrCMBBF8+nio9DHqqDf5NJvaGzeKWqrYJvkmkbElYs6cDgwcC/DkMO+QpatkOdr5MUmuYiuqh3KyMeJcvuTOVPXBcjj3sMYDSE4WHsGpQ06a7F0vPfJREoTyxSUMuBcom1jMRPQ2iZY3FnbQWmDvh/gnMc0uS/jGP2Em8YEmVtDCFg+70xwNwzyiCs/wl9OIDxeJ5X+HynBGY3vaiAYxQsb0GfwzNzn8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"But — why did they fail? :(((\"\n        title=\"\"\n        src=\"/static/4333a4092ed4ec96f1cfa7fb6d9a2f49/2bef9/elk-fail.png\"\n        srcset=\"/static/4333a4092ed4ec96f1cfa7fb6d9a2f49/6f3f2/elk-fail.png 256w,\n/static/4333a4092ed4ec96f1cfa7fb6d9a2f49/01e7c/elk-fail.png 512w,\n/static/4333a4092ed4ec96f1cfa7fb6d9a2f49/2bef9/elk-fail.png 1024w,\n/static/4333a4092ed4ec96f1cfa7fb6d9a2f49/5c5b6/elk-fail.png 1265w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>But — why did they fail? :(((</p></figcaption>\n  </figure></p>\n<p><strong>Github’s</strong> search comes the closest to ticking all the boxes we’ve alluded to above, with more comprehensive autocomplete — although its syntax precludes browsing search terms, as in Kibana. It even has syntax highlighting! Nice:</p>\n<p><img src=\"/b6f4981995404e0c2af47b2137a3aec9/github-chips.gif\" alt=\"github-chips\"></p>\n<p>Error reporting is also present, but you must hit search to discover that you’ve made a mistake:</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\n                text-align: center;\n                color: #b1afaf;\n                font-size: 0.75em;\n              \">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/175b12ee8c63e121aeafd2748ab9d0c9/0ddab/github-error.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 12.109375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAUUlEQVR42oXMTQqAIBAGUI+RYo41NajRf1H3v9iXtAqCWrztU1IZHHPCPnXYxpRFLH24rUNE4BKNK9CS/iReg6yGEiacOYvsEGr7It78Zs/wAuKAOCXOTNFzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"It&#39;d be nice to see this as we typed.\"\n        title=\"\"\n        src=\"/static/175b12ee8c63e121aeafd2748ab9d0c9/2bef9/github-error.png\"\n        srcset=\"/static/175b12ee8c63e121aeafd2748ab9d0c9/6f3f2/github-error.png 256w,\n/static/175b12ee8c63e121aeafd2748ab9d0c9/01e7c/github-error.png 512w,\n/static/175b12ee8c63e121aeafd2748ab9d0c9/2bef9/github-error.png 1024w,\n/static/175b12ee8c63e121aeafd2748ab9d0c9/71c1d/github-error.png 1536w,\n/static/175b12ee8c63e121aeafd2748ab9d0c9/a878e/github-error.png 2048w,\n/static/175b12ee8c63e121aeafd2748ab9d0c9/0ddab/github-error.png 2220w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>It’d be nice to see this as we typed.</p></figcaption>\n  </figure></p>\n<p>Finally, loathe as I am to <a href=\"./its-not-rubbish\">call anything rubbish</a>, a (dis)honourable mention to Gmail’s search input, which offers a similarly powerful query language, and then hides its affordances behind some odd UI choices. Binary operators and field-specific search are both present, with keys and values separated by <code class=\"language-text\">:</code>, but the user must … <a href=\"https://support.google.com/mail/answer/7190?hl=en&#x26;co=GENIE.Platform%3DAndroid\">google, I guess?</a> to discover what’s possible – I can’t see a link to the documentation anywhere in the UI.</p>\n<p><img src=\"/f977b7c1cded2e92042da30ff9be1bcd/gmail-chips.gif\" alt=\"gmail-chips\"></p>\n<p>Note also the additional filter UI. What if those filters added to the query, revealing both the fields available and their syntax? This feels like it misses a point of discovery for users new to the syntax — but there may be good reasons to use two modes of input here, and I’d be interested to see what Google’s telemetry reveals about usage patterns. We’ll return to those thoughts later in this series, when we’re implementing our UI.</p>\n<h2>When the chips are down</h2>\n<p>So chips are out there — and they’re a bit janky, or they’re not as expressive or fully-featured as we’d like them to be. But we’ve got a decent feature list for what chips <em>could</em> be, right there:</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Grid</th>\n<th>EC2</th>\n<th>Giant</th>\n<th>Kibana</th>\n<th>Github</th>\n<th>Gmail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🔍 Discoverability</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n<td>⚖️</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>⌨️ Keyboard-only input</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>📄 Query as single document</td>\n<td>❌</td>\n<td>❌</td>\n<td>⚖️</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>💻 Binary operators and groups</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>🧳 Portability (copy and paste)</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>✨ Syntax highlighting</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>🚨 Real-time error reporting</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<p>How hard can it be to make a UI component that gives us all of the above? There’s only one way to find out! We’ll need three things:</p>\n<ol>\n<li>A query language that lets us express key value pairs, binary expressions, grouping, etc., with discoverability in mind.</li>\n<li>A parser for that language, to provide underlying support for syntax highlighting and error reporting, and to open the door for consumers to interpret the language into their own query DSLs.</li>\n<li>A UI that can use the output of the parser to power the features we list above!</li>\n</ol>\n<p>The query language comes first, and so we’ll tackle that in the <a href=\"/structured-search-ui-2\">next post.</a></p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">This will probably get worse.<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"Structured search queries for web UIs, part 1: the dream","date":"September 30, 2024","description":"The state of the art for structured search, and how we might do better"}}},"pageContext":{"slug":"/structured-search-ui-1/","previous":{"fields":{"slug":"/enumerate-matches/"},"frontmatter":{"title":"Writing a program to generate every string a regular expression will match"}},"next":{"fields":{"slug":"/structured-search-ui-2/"},"frontmatter":{"title":"Structured search queries for web UIs, part 2: the grammar"}}}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}