{"componentChunkName":"component---src-templates-blog-post-js","path":"/structured-search-ui-2/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"0ffbf947-1bbd-5d18-ade0-c3c6701c4f58","excerpt":"This is what we promised to do in part 1: A query language that lets us express key value pairs, binary expressions, grouping, etc., with discoverability in…","html":"<p>This is what we promised to do in part 1:</p>\n<blockquote>\n<p>A query language that lets us express key value pairs, binary expressions, grouping, etc., with discoverability in mind.</p>\n</blockquote>\n<p>But … how does one write a query language? Where do we even <em>begin?</em></p>\n<p>Well, a while back I had the good fortune to stumble across <em><a href=\"https://craftinginterpreters.com/\">Crafting Interpreters</a></em> by Bob Nystrom, which is a brilliant introduction to the world of grammars, parsers and interpreters.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> It gave me a good enough understanding of the moving parts to hack out something that worked.</p>\n<h2>A query language like grammar used to make</h2>\n<p>But — why write <em>another</em> query language? Surely something like <a href=\"https://lucene.apache.org/core/2_9_4/queryparsersyntax.html\">Lucene syntax</a> or <a href=\"https://www.elastic.co/guide/en/kibana/current/kuery-query.html\">KQL</a> will do for our purposes?</p>\n<p>The problem with Lucene is discoverability, which we’d like for both the key and value part of our chips. Imagine we’re trying to discover which structured search fields are available — for example, the values logged in the namespace <code class=\"language-text\">lambdaStats</code> when we’re grepping logs ingested via <a href=\"https://github.com/guardian/cloudwatch-logs-management\">cloudwatch-log-management.</a> Lucene (and KQL) would have us type, for example, <code class=\"language-text\">lambdaStats.memorySizeMax</code> for the key portion, but there’s no way of distinguishing between a query for the string <code class=\"language-text\">lambdaStats.lambdaVersion</code> and the key-value pair <code class=\"language-text\">lambdaStats.lambdaVersion:&lt;version></code> until you type the <code class=\"language-text\">:</code> — and that ambiguity prevents a UI from confidently presenting a typeahead to the user until it’s too late.</p>\n<p>One solution, borrowed from the Grid and Giant chip implementations, is to add a leading <code class=\"language-text\">+</code> to our chip grammar: <code class=\"language-text\">+lambdaStats.lambdaVersion:&lt;version></code>. This allows us to present typeahead suggestions as early as possible. The cost is an extra character in the query, and any associated time/clarity/usability penalty. That feels trivial to me for now, so let’s take this approach and see how we fare.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>The rest of the query language will be heavily inspired by Lucene, for now ignoring some of the more domain-specific parts (fuzzy or proximity searches, ranges etc.) to sidestep complexity that isn’t chip- or binary- related. We’ll build up a grammar using a simple notation similar to <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\">BNF</a>, again borrowed from Crafting Interpreters — <a href=\"https://craftinginterpreters.com/representing-code.html\">here’s the chapter</a> if you’d like to understand how grammars might be represented in more detail. Example queries in our language might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pets                           // Simple string search\n\"The pet I'll never forget\"    // Quoted strings for reserved characters and whitespace\npets AND (cats OR dogs)        // Binary expressions\n+tag:pets                      // Searching for specific fields\n+tag:pets AND (cats OR dogs)   // Combinations of the above</code></pre></div>\n<p>The first thing we can be sure of is that a query in our language is a list of expressions. We can write that as the rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> expr+</code></pre></div>\n<p>As in regular expressions, the postfix <code class=\"language-text\">+</code> denotes one-or-more of the previous symbol. In plain English, this rule states, “a <code class=\"language-text\">query</code> symbol is made up of one or more <code class=\"language-text\">expr</code> symbols.”</p>\n<p>There are three sorts of <code class=\"language-text\">expr</code>: a plain <code class=\"language-text\">str</code> (unquoted and quoted, the latter to permit characters that would otherwise be reserved), a <code class=\"language-text\">chip</code> (<code class=\"language-text\">+key:value</code>), and a <code class=\"language-text\">group</code> (parentheses around an <code class=\"language-text\">expr</code>.) Following the convention of borrowing from regular expressions, we can use the pipe character to denote an “or” relationship, and express that as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">expr              -> str | group | chip</code></pre></div>\n<p>Hold on, though — all of the members of <code class=\"language-text\">expr</code> can be combined with binary expressions. So our rule for binary expressions comes first, where a binary can be a single expression, or two expressions joined with an operator:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> binary+\nbinary            -> expr ('AND' | 'OR' | 'NOT' expr)*\nexpr              -> str | group | chip</code></pre></div>\n<p>The postfix <code class=\"language-text\">*</code> denotes zero-or-more of the previous symbol, and the brackets group a collection of symbols. With this rule, <code class=\"language-text\">str</code>, <code class=\"language-text\">str AND group</code>, <code class=\"language-text\">str AND (group OR chip)</code> etc. are all valid.</p>\n<p>How do we unpack <code class=\"language-text\">str | group | chip</code>? Well, <code class=\"language-text\">str</code> is what we call a “terminal” — a symbol that represents a token. Tokens form the alphabet that makes up a grammar. So there’s no need to define <code class=\"language-text\">str</code> in our notation.</p>\n<p>Groups are simple to define — they’re any possible binary, wrapped in parenthesis:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">group             -> '(' binary ')'</code></pre></div>\n<p>where the open and close brackets here are also terminal symbols, this time representing the literal characters <code class=\"language-text\">(</code> and <code class=\"language-text\">)</code>.</p>\n<p>Finally, the <code class=\"language-text\">chip</code> needs contain a key and a value:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chip              -> '+' str ':' str</code></pre></div>\n<p>Which leaves us with a simple grammar:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> binary+\nbinary            -> expr ('AND' | 'OR' | 'NOT' expr)*\nexpr              -> str | group | chip\ngroup             -> '(' binary ')'\nchip              -> '+' str ':' str</code></pre></div>\n<p>That’s it! We might find that this grammar needs a few tweaks for useability purposes when we come to implement our UI, but the above is a great place to start.</p>\n<h2>Grammar in action</h2>\n<p>To test the grammar, we can “play” it — beginning from the top, expand our symbols until we’re left with a set of tokens. For example, if we start with <code class=\"language-text\">query</code>, always expand the leftmost symbol first, and make a few arbitrary choices, we can produce something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query\nbinary+\nexpr 'AND' expr\nstr 'AND' expr\nstr 'AND' group\nstr 'AND' (binary)\nstr 'AND' (expr 'OR' expr)\nstr 'AND' (chip 'OR' expr)\nstr 'AND' ('+' str ':' str 'OR' str)</code></pre></div>\n<p>which, were we to fill in the strings, might look like <code class=\"language-text\">pets AND (+tag:cats OR feline)</code>, a valid sentence in this grammar.</p>\n<p>Of course, this grammar isn’t doing any work for us — yet. We’ll need to parse it into a machine-readable form. In the next post we’ll write a program that does just that, using two techniques: <em>scanning</em>, to produce the tokens that comprise our grammar, and <em>parsing</em>, to apply the grammar to those tokens, and give us a useful structure (or an error message!) as a result.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">Bob Nystrom is a serial language designer, pedagogical genius, and S-rank <a href=\"https://x.com/munificentbob?lang=en\">twitter/mastodon</a> follow. I’ll lean heavily on what I learned from <em>Crafting Interpreters</em> for the parsing/interpreting parts of this series, and if you’d like to learn more on these topics, or indeed write your very own programming language, I can’t recommend that book highly enough.<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">There’s another cost here — although our grammar might look a lot like Lucene, using <code class=\"language-text\">+</code> to start our chips clashes with <a href=\"https://lucene.apache.org/core/2_9_4/queryparsersyntax.html#:~:text=The%20%22%2B%22%20or%20required%20operator%20requires%20that%20the%20term%20after%20the%20%22%2B%22%20symbol%20exist%20somewhere%20in%20a%20the%20field%20of%20a%20single%20document.\">Lucene’s ‘must’ operator</a>. So, were we to want to have our query language be a superset of Lucene’s, we’d need to have some other character for our typeahead.<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"Structured search queries for web UIs, part 2: the grammar","date":"October 06, 2024","description":"In which we write the grammar for the query language that will power our fancy UI"}}},"pageContext":{"slug":"/structured-search-ui-2/","previous":{"fields":{"slug":"/structured-search-ui-1/"},"frontmatter":{"title":"Structured search queries for web UIs, part 1: the dream"}},"next":null}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}