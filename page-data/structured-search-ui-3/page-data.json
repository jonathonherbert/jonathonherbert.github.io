{"componentChunkName":"component---src-templates-blog-post-js","path":"/structured-search-ui-3/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"86d628ab-2f04-5f59-81d6-c4a7a47df3c6","excerpt":"We finished part 2 by writing a grammar that described our query language, CQL. Now it’s time to write the code we need to parse it — to resolve CQL expressions…","html":"<p>We finished <a href=\"./structured-search-part-2\">part 2</a> by writing a grammar that described our query language, CQL. Now it’s time to write the code we need to parse it — to resolve CQL expressions into the structure and the symbols we described in our grammar, or throw an error trying.</p>\n<p>There are two parts to this process:</p>\n<ul>\n<li><strong>Scanning</strong> takes an input from a larger alphabet (in our case, the character set provided by utf-8), and produces a list of <em>tokens</em> comprised of the smaller alphabet of symbols specified in our grammar.</li>\n<li><strong>Parsing</strong> takes these tokens, and produces a abstract syntax tree — a tree that reflects the syntax of the statement, allowing us to reason about the input query’s validity, and eventually enabling us to interpret it into other query languages, should we wish.</li>\n</ul>\n<h2>Scanning</h2>\n<div data-scanner>why not +edit:me?</div>\n<p>Of the two, going from utf-8 to the CQL lexicon is the easier task. That’s because for most programming languages, and certainly for CQL, their lexical grammar is a <a href=\"https://en.wikipedia.org/wiki/Regular_language\">regular grammar</a> — the sort of grammar that can be encoded by a regular expression.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> This means the output of our scanner is a list of tokens created in the same order as they are consumed from our input — we don’t have to worry about the more complicated tree structure that’s necessary for <a href=\"https://en.wikipedia.org/wiki/Context-free_grammar\">context-free grammars</a> like CQL.</p>\n<p>This means we can describe the scanning process as a loop that continually ingests our input, and a switch statement that inspects the next few characters, consumes them, and (optionally) outputs a token. What data should a <code class=\"language-text\">Token</code> contain? Well, we’ll need:</p>\n<ul>\n<li>A pair of numbers to define where the token begins and ends.</li>\n<li>Something to represent the token’s type. Because we know all of these types upfront, this can be an enumeration.</li>\n<li>A string value to capture the token “lexeme” — the range of the string that maps to the token, in its entirety.</li>\n<li>Optionally, a string value to capture the token “literal” – the token value, if it’s needed. For example, tokens of type <code class=\"language-text\">string</code> must have a literal value that contains their content, but tokens like <code class=\"language-text\">OR</code> or <code class=\"language-text\">AND</code> do not; they are entirely represented by their token types.</li>\n</ul>\n<p>Writing in Typescript, <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> here’s some code to enumerate our token types, and define our data type:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> TokenType <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Single-character tokens.</span>\n  <span class=\"token constant\">LEFT_BRACKET</span><span class=\"token operator\">:</span> <span class=\"token string\">\"LEFT_BRACKET\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">RIGHT_BRACKET</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RIGHT_BRACKET\"</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Literals.</span>\n  <span class=\"token constant\">STRING</span><span class=\"token operator\">:</span> <span class=\"token string\">\"STRING\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">CHIP_KEY</span><span class=\"token operator\">:</span> <span class=\"token string\">\"CHIP_KEY\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">CHIP_VALUE</span><span class=\"token operator\">:</span> <span class=\"token string\">\"CHIP_VALUE\"</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Keywords.</span>\n  <span class=\"token constant\">AND</span><span class=\"token operator\">:</span> <span class=\"token string\">\"AND\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">OR</span><span class=\"token operator\">:</span> <span class=\"token string\">\"OR\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">EOF</span><span class=\"token operator\">:</span> <span class=\"token string\">\"EOF\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// This tells Typescript to make this object read-only, and narrow its literal type.</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Token</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> start<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">public</span> end<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n    <span class=\"token keyword\">public</span> tokenType<span class=\"token operator\">:</span> TokenType<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">public</span> lexeme<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">public</span> literal<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Writing a scanner is then fairly straightforward. First, we’ll introduce our <code class=\"language-text\">Scanner</code> class, which encapsulates the mutable state we need to keep track of the beginning of the current lexeme, and how far we’ve scanned forward.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Scanner</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> tokens<span class=\"token operator\">:</span> Token<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> current <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span> query<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> scanTokens <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Token<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// We are at the beginning of the next lexeme.</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">scanToken</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tokens<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> scanToken <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">advance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">\"+\"</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addKey</span><span class=\"token punctuation\">(</span>TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">CHIP_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">\":\"</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">\"(\"</span><span class=\"token operator\">:</span>\n        <span class=\"token comment\">// etc.</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">advance</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> previous <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">[</span>previous<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">advance()</code> passes back the current character, which we can then inspect to decide which sort of token we’d like to construct. Because our query language is very small, there aren’t too many options! We can then continue to scan through the string until our token is complete, and add it to our array. Here’s an example for <code class=\"language-text\">addKey()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">addKey</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">advance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">-</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addToken</span><span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addToken</span><span class=\"token punctuation\">(</span>TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">CHIP_KEY</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">peek</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>offset<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span>\n      <span class=\"token operator\">?</span> <span class=\"token string\">\"\\u0000\"</span>\n      <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">isAtEnd</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>offset<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">+</span> offset <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">addToken</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tokenType<span class=\"token operator\">:</span> TokenType<span class=\"token punctuation\">,</span> literal<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> text <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tokens <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tokens<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Token</span><span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">,</span> literal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>… or, in plain English, “scan forward until we hit a <code class=\"language-text\">:</code> character, whitespace, or the end of the string. Then add a <code class=\"language-text\">CHIP_KEY</code> token, optionally adding its literal value if it exists.”</p>\n<p>This is largely straightforward, so we won’t go through every token here, but there are a few wrinkles worth mentioning. The first is that, in some cases, we do not know what token we have until we are  mid-way through a scan. This is the case when we are dealing with unquoted strings and boolean operators – if our token starts with <code class=\"language-text\">OR</code>, we’ve no way of knowing whether we’re looking at the keyword <code class=\"language-text\">OR</code> or the unquoted string <code class=\"language-text\">ORTHOGONAL</code> until we encounter whitespace. In this case, we’re after a <a href=\"https://en.wiktionary.org/wiki/maximal_munch\">maximal munch</a>, matching the longest possible section of our input before declaring the token type:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">addIdentifierOrUnquotedString</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isLetterOrDigit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">advance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">const</span> text <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> maybeReservedWord <span class=\"token operator\">=</span>\n      Token<span class=\"token punctuation\">.</span>reservedWordMap<span class=\"token punctuation\">[</span>text <span class=\"token keyword\">as</span> <span class=\"token keyword\">keyof</span> <span class=\"token keyword\">typeof</span> Token<span class=\"token punctuation\">.</span>reservedWordMap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> maybeReservedWord\n      <span class=\"token operator\">?</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addToken</span><span class=\"token punctuation\">(</span>maybeReservedWord<span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addUnquotedString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The second thing to note: it’s possible for our input to contain lexical errors. For example, a quoted string must end in a closing double quote. If we run out of input before we encounter one, we should throw an error:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">addString</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'\"'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">advance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unterminated string at end of file\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">advance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addToken</span><span class=\"token punctuation\">(</span>\n      TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>program<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">error</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// For now, we'll just log errors. Production code would</span>\n    <span class=\"token comment\">// care where this error occurred, and provide the caller</span>\n    <span class=\"token comment\">// with a means of discovering what went wrong.</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Error: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>message<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Incidentally, quoted strings give us a good illustration of the difference between a lexeme and a literal. Note that the literal, which is the data that the token represents, does not include the quotes:</p>\n<div data-scanner>unquoted \"quoted\"</div>\n<p>Here’s the <a href=\"https://github.com/guardian/cql/blob/f89645f4d8079198e0a8d648f37c1d1810b71354/prosemirror-client/src/lang/scanner.ts\">code</a> if you’d like to see the entire implementation as it stands in the CQL project.</p>\n<p>And that’s the scanner done! From a string input, we’ve now got a tool that can produce an ordered list of tokens. This is enough to power some of the features of our yet-to-be-implemented UI — syntax highlighting, for one — but to ensure our query is correctly formed, report errors, and power our typeahead, we’ll need to transform these tokens into a data structure that represents our CQL grammar. In the next post, we’ll write a parser that does just that.</p>\n<style>\n\n.scanner-container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    width: 100%;\n}\n\n.result-container {\n        display: flex;\n    align-items: center;\n    flex-direction: column;\n    width: 100%;\n}\n\n.result-container > div {\n    max-width: 100%;\n    margin-top: 5px;\n    overflow-y: scroll;\n    margin-bottom: 0;\n    padding-bottom: 9rem;\n}\n\n.CqlDebug__json {\n  display: flex;\n}\n\n.CqlDebug__json > div {\n  display: flex;\n  flex-direction: column;\n}\n\n.CqlDebug__mapping {\n  display: flex;\n  flex-direction: column;\n}\n\n.CqlDebug__queryDiagramToken,\n.CqlDebug__queryDiagramNode {\n  margin-bottom: 6rem;\n}\n\n.CqlDebug__queryDiagramNode > .CqlDebug__queryDiagramLabel {\n  padding-top: 0rem;\n}\n\n.CqlDebug__queryDiagramNode > .CqlDebug__queryDiagramLabel div + div {\n  padding-top: 1rem;\n}\n\n.Cql__Debug > div {\n  flex-grow: 1;\n}\n.CqlDebug__queryDiagram {\n  display: flex;\n  white-space: pre;\n  font-family: monospace;\n}\n\n.CqlDebug__queryDiagramLabel {\n  padding-top: 2rem;\n  padding-right: 1rem;\n  display: flex;\n  flex-direction: column;\n}\n\n.CqlDebug__queryDiagramContent {\n  display: flex;\n}\n\n.CqlDebug__queryBox {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-grow: 0;\n  width: 25px;\n  padding: 1rem 0;\n}\n\n.CqlDebug__queryBox--offset > .CqlDebug__originalChar {\n  position: relative;\n  left: 50%;\n  top: -2rem;\n}\n\n.CqlDebug__queryBox--offset > .CqlDebug__queryChar {\n  position: relative;\n  left: -50%;\n}\n\n.CqlDebug__queryBox > div {\n  width: 1em;\n  height: 1rem;\n}\n\n.CqlDebug__originalChar {\n  background-color: rgb(49, 78, 55);\n}\n\n.CqlDebug__queryChar {\n  background-color: #a8e6b5;\n}\n\n.CqlDebug__queryChar + .CqlDebug__queryChar {\n  margin-top: 3px;\n}\n\n.CqlDebug__queryCharAlt {\n  background-color: #f7bbff;\n}\n\n.CqlDebug__nodeChar {\n  background-color: rgb(130, 82, 82);\n  position: absolute;\n  bottom: 1rem;\n  left: -50%;\n}\n\n.CqlDebug__nodeLabel,\n.CqlDebug__tokenLabel {\n  position: absolute;\n  top: 5rem;\n  width: 1em;\n  transform: rotate(90deg);\n}\n\n.CqlDebug__nodeLabel {\n  left: 50%;\n}\n\n.CqlDebug__nodeDiagram {\n  display: flex;\n}\n\n.CqlSandbox {\n  margin-top: 30px;\n}\n\n.CqlSandbox__query-results {\n  display: flex;\n}\n\n.CqlSandbox__query-results > div {\n  flex-grow: 1;\n}\n</style>\n<script id=\"page-script\" type=\"module\">\n    \"use strict\";\n    var _a;\n    const TokenType = {\n        // Single-character tokens.\n        PLUS: \"PLUS\",\n        COLON: \"COLON\",\n        AT: \"AT\",\n        LEFT_BRACKET: \"LEFT_BRACKET\",\n        RIGHT_BRACKET: \"RIGHT_BRACKET\",\n        // Literals.\n        STRING: \"STRING\",\n        NUMBER: \"NUMBER\",\n        QUERY_OUTPUT_MODIFIER_KEY: \"QUERY_OUTPUT_MODIFIER_KEY\",\n        CHIP_KEY: \"CHIP_KEY\",\n        CHIP_VALUE: \"CHIP_VALUE\",\n        // Keywords.\n        AND: \"AND\",\n        OR: \"OR\",\n        EOF: \"EOF\",\n    };\n    class Token {\n        constructor(tokenType, lexeme, literal, start, end) {\n            this.tokenType = tokenType;\n            this.lexeme = lexeme;\n            this.literal = literal;\n            this.start = start;\n            this.end = end;\n        }\n        toString() {\n            return `${this.tokenType} ${this.lexeme} ${this.literal} ${this.start}-${this.end}`;\n        }\n    }\n    _a = Token;\n    Token.reservedWordMap = {\n        AND: TokenType.AND,\n        OR: TokenType.OR,\n    };\n    Token.reservedWordStrs = Object.keys(_a.reservedWordMap);\n    const whitespaceR = /\\s/;\n    const isWhitespace = (str) => whitespaceR.test(str);\n    const letterOrDigitR = /[0-9A-z]/;\n    const isLetterOrDigit = (str) => letterOrDigitR.test(str);\n    class Scanner {\n        constructor(program) {\n            this.program = program;\n            this.tokens = [];\n            this.start = 0;\n            this.current = 0;\n            this.line = 1;\n            this.scanTokens = () => {\n                while (!this.isAtEnd()) {\n                    // We are at the beginning of the next lexeme.\n                    this.start = this.current;\n                    this.scanToken();\n                }\n                return this.tokens.concat(new Token(TokenType.EOF, \"\", undefined, this.current, this.current));\n            };\n            this.isAtEnd = (offset = 0) => this.current + offset === this.program.length;\n            this.scanToken = () => {\n                switch (this.advance()) {\n                    case \"+\":\n                        this.addKey(TokenType.CHIP_KEY);\n                        return;\n                    case \":\":\n                        this.addValue();\n                        return;\n                    case \"(\":\n                        this.addToken(TokenType.LEFT_BRACKET);\n                        return;\n                    case \")\":\n                        this.addToken(TokenType.RIGHT_BRACKET);\n                        return;\n                    case \" \":\n                        return;\n                    case \"\\r\":\n                    case \"\\t\":\n                    case '\"':\n                        this.addString();\n                        return;\n                    default:\n                        this.addIdentifierOrUnquotedString();\n                        return;\n                }\n            };\n            this.addKey = (tokenType) => {\n                while (this.peek() != \":\" && !isWhitespace(this.peek()) && !this.isAtEnd())\n                    this.advance();\n                if (this.current - this.start == 1)\n                    this.addToken(tokenType);\n                else {\n                    const key = this.program.substring(this.start + 1, this.current);\n                    this.addToken(tokenType, key);\n                }\n            };\n            this.addValue = () => {\n                while (!isWhitespace(this.peek()) && !this.isAtEnd())\n                    this.advance();\n                if (this.current - this.start == 1) {\n                    this.addToken(TokenType.CHIP_VALUE);\n                }\n                else {\n                    const value = this.program.substring(this.start + 1, this.current);\n                    this.addToken(TokenType.CHIP_VALUE, value);\n                }\n            };\n            this.addIdentifierOrUnquotedString = () => {\n                while (isLetterOrDigit(this.peek())) {\n                    this.advance();\n                }\n                const text = this.program.substring(this.start, this.current);\n                const maybeReservedWord = Token.reservedWordMap[text];\n                return maybeReservedWord\n                    ? this.addToken(maybeReservedWord)\n                    : this.addUnquotedString();\n            };\n            this.addUnquotedString = () => {\n                while (\n                // Consume whitespace up until the last whitespace char\n                (!isWhitespace(this.peek()) ||\n                    isWhitespace(this.peek(1)) ||\n                    this.isAtEnd(1)) &&\n                    this.peek() != \")\" &&\n                    !this.isAtEnd()) {\n                    this.advance();\n                }\n                this.addToken(TokenType.STRING, this.program.substring(this.start, this.current));\n            };\n            this.addString = () => {\n                while (this.peek() != '\"' && !this.isAtEnd()) {\n                    this.advance();\n                }\n                if (this.isAtEnd()) {\n                    this.error(this.line, \"Unterminated string at end of file\");\n                }\n                else {\n                    this.advance();\n                }\n                this.addToken(TokenType.STRING, this.program.substring(this.start + 1, this.current - 1));\n            };\n            this.addToken = (tokenType, literal) => {\n                const text = this.program.substring(this.start, this.current);\n                this.tokens = this.tokens.concat(new Token(tokenType, text, literal, this.start, this.current - 1));\n            };\n            this.advance = () => {\n                const previous = this.current;\n                this.current = this.current + 1;\n                return this.program[previous];\n            };\n            this.peek = (offset = 0) => this.program[this.current + offset] === undefined\n                ? \"\\u0000\"\n                : this.program[this.current + offset];\n            this.error = (line, message) => this.report(line, \"\", message);\n            this.report = (line, where, message) => {\n                console.log(`[line ${line}] Error${where}: ${message}`);\n            };\n        }\n    }\n\n    const getDebugTokenHTML = (tokens) => {\n        let html = `\n        <div class=\"CqlDebug__queryDiagram CqlDebug__queryDiagramToken\">\n        <div class=\"CqlDebug__queryDiagramLabel\">\n            <div>Lexeme</div>\n            <div>Literal</div>\n        </div>\n        <div class=\"CqlDebug__queryDiagramContent\">`;\n        tokens.forEach((token, index) => {\n            var _b, _c;\n            html += `${Array(Math.max(1, token.lexeme.length))\n                .fill(undefined)\n                .map((_, index) => {\n                var _b, _c;\n                const lexemeChar = token.lexeme[index];\n                const literalOffset = ((_b = token.literal) === null || _b === void 0 ? void 0 : _b.length) === token.lexeme.length ? 0 : 1;\n                const literalChar = (_c = token.literal) === null || _c === void 0 ? void 0 : _c[index - literalOffset];\n                return `\n            <div class=\"CqlDebug__queryBox\">\n            <div class=\"CqlDebug__queryIndex\">${token.start + index}</div>\n            ${lexemeChar !== undefined\n                    ? `<div class=\"CqlDebug__queryChar\">${lexemeChar}</div>`\n                    : \"\"}\n                ${literalChar !== undefined\n                    ? `<div class=\"CqlDebug__queryChar CqlDebug__queryCharAlt\">${literalChar}</div>`\n                    : \"\"}\n            ${index === 0\n                    ? `<div class=\"CqlDebug__tokenLabel\">${token.tokenType}</div>`\n                    : \"\"}\n            </div>`;\n            })\n                .join(\"\")}\n        ${((_b = tokens[index + 1]) === null || _b === void 0 ? void 0 : _b.start) > token.end + 1 && ((_c = tokens[index + 1]) === null || _c === void 0 ? void 0 : _c.tokenType) !== \"EOF\" && token.tokenType !== \"EOF\"\n                ? `<div class=\"CqlDebug__queryBox\"><div class=\"CqlDebug__queryIndex\">${token.end + 1}</div></div>`\n                : \"\"}`;\n        });\n        html += \"</div></div>\";\n        return html;\n    }\n\n    // Userland\n\n    const createScanner = (el, initialQuery) => {\n        el.innerHTML = \"\";\n        el.classList.add(\"scanner-container\")\n        const input = document.createElement(\"input\");\n        input.value = initialQuery;\n        el.appendChild(input);\n        const resultContainer = document.createElement(\"div\");\n        resultContainer.classList.add(\"result-container\");\n        el.appendChild(resultContainer);\n\n        const applyScan = value => {\n            const scanner = new Scanner(value);\n            const tokens = scanner.scanTokens();\n            resultContainer.innerHTML = getDebugTokenHTML(tokens);\n        }\n\n        input.addEventListener(\"input\", e => {\n            const value = e.target.value;\n            applyScan(value);\n        })\n\n        applyScan(initialQuery);\n    }\n\n    document.querySelectorAll(\"[data-scanner]\").forEach(el => {\n        createScanner(el, el.innerText)\n    });\n</script>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">Strictly, a regular expression that does not include <a href=\"https://en.wikipedia.org/wiki/Regular_expression#Patterns_for_non-regular_languages\">non-regular features</a>, like backreferences.<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">I originally wrote the language server for CQL in Scala (<a href=\"https://github.com/guardian/cql/tree/scala/src/main/scala\">code</a>), and rewrote it in Typescript once it became clear that introducing a network call for language features … didn’t serve the product well!  More on that in a future post.<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">There are lots of ways to write a scanner, including leaning more heavily on regular expressions, and consuming the input in a more functional style, but I thought writing straightforward, imperative code would be best for a wide audience to read.<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"Structured search queries for web UIs, part 3: scanning","date":"October 24, 2024","description":"Let's teach our computer to CQL"}}},"pageContext":{"slug":"/structured-search-ui-3/","previous":{"fields":{"slug":"/structured-search-ui-2/"},"frontmatter":{"title":"Structured search queries for web UIs, part 2: the grammar"}},"next":{"fields":{"slug":"/structured-search-ui-4/"},"frontmatter":{"title":"Structured search queries for web UIs, part 4: parsing"}}}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}