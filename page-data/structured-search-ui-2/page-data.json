{"componentChunkName":"component---src-templates-blog-post-js","path":"/structured-search-ui-2/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"0ffbf947-1bbd-5d18-ade0-c3c6701c4f58","excerpt":"This is what we promised to do in part 1: A query language that lets us express key value pairs, binary expressions, grouping, etc., with discoverability in‚Ä¶","html":"<p>This is what we promised to do in part 1:</p>\n<blockquote>\n<p>A query language that lets us express key value pairs, binary expressions, grouping, etc., with discoverability in mind.</p>\n</blockquote>\n<p>But ‚Ä¶ how does one write a query language? Where do we even <em>begin?</em></p>\n<p>Well, a while back I had the good fortune to stumble across <em><a href=\"https://craftinginterpreters.com/\">Crafting Interpreters</a></em> by Bob Nystrom, which is a brilliant introduction to the world of grammars, parsers and interpreters.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> It gave me a good enough understanding of the moving parts to hack out something that worked.</p>\n<h2>A query language like grammar used to make</h2>\n<p>But ‚Äî why write <em>another</em> query language? Surely something like <a href=\"https://lucene.apache.org/core/2_9_4/queryparsersyntax.html\">Lucene syntax</a> or <a href=\"https://www.elastic.co/guide/en/kibana/current/kuery-query.html\">KQL</a> will do for our purposes?</p>\n<p>The problem with Lucene is discoverability, which we‚Äôd like for both the key and value part of our chips. Imagine we‚Äôre trying to discover which structured search fields are available¬†‚Äî for example, the values logged in the namespace <code class=\"language-text\">lambdaStats</code> when we‚Äôre grepping logs ingested via <a href=\"https://github.com/guardian/cloudwatch-logs-management\">cloudwatch-log-management.</a> Lucene (and KQL) would have us type, for example, <code class=\"language-text\">lambdaStats.memorySizeMax</code> for the key portion, but there‚Äôs no way of distinguishing between a query for the string <code class=\"language-text\">lambdaStats.lambdaVersion</code> and the key-value pair <code class=\"language-text\">lambdaStats.lambdaVersion:&lt;version></code> until you type the <code class=\"language-text\">:</code> ‚Äî and that ambiguity prevents a UI from confidently presenting a typeahead to the user until it‚Äôs too late.</p>\n<p>One solution, borrowed from the Grid and Giant chip implementations, is to add a leading <code class=\"language-text\">+</code> to our chip grammar: <code class=\"language-text\">+lambdaStats.lambdaVersion:&lt;version></code>. We can then present typeahead suggestions for keys as soon as we see <code class=\"language-text\">+</code>, and values once we see a following <code class=\"language-text\">:</code>. The cost is an extra character in the query, and any associated time/clarity/usability penalty. That feels trivial to me for now, so let‚Äôs take this approach and see how we fare.<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>The rest of the query language will be heavily inspired by Lucene, for now ignoring some of the more domain-specific parts (fuzzy or proximity searches, ranges etc.) to sidestep complexity that isn‚Äôt chip- or binary- related. We‚Äôll build up a grammar using a simple notation similar to <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\">BNF</a>, again borrowed from Crafting Interpreters ‚Äî <a href=\"https://craftinginterpreters.com/representing-code.html\">here‚Äôs the chapter</a> if you‚Äôd like to understand how grammars might be represented in more detail. Example queries in our language might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pets                           // Simple string search\n\"The pet I'll never forget\"    // Quoted strings for reserved characters and whitespace\npets AND (cats OR dogs)        // Binary expressions\n+tag:pets                      // Searching for specific fields\n+tag:pets AND (cats OR dogs)   // Combinations of the above</code></pre></div>\n<p>All that‚Äôs left to do is give it a cheeky name. For now, I‚Äôve taken to calling it chips query language üçü, or CQL for short.<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<h2>A grammar for CQL</h2>\n<p>The first thing we can be sure of is that a query in our language is a list of expressions. We can write that as the rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> expr+</code></pre></div>\n<p>As in regular expressions, the postfix <code class=\"language-text\">+</code> denotes one-or-more of the previous symbol. In plain English, this rule states, ‚Äúa <code class=\"language-text\">query</code> symbol is made up of one or more <code class=\"language-text\">expr</code> symbols.‚Äù</p>\n<p>There are three sorts of <code class=\"language-text\">expr</code>: a plain <code class=\"language-text\">str</code> (unquoted and quoted, the latter to permit characters that would otherwise be reserved), a <code class=\"language-text\">chip</code> (<code class=\"language-text\">+key:value</code>), and a <code class=\"language-text\">group</code> (parentheses around an <code class=\"language-text\">expr</code>.) Following the convention of borrowing from regular expressions, we can use the pipe character to denote an ‚Äúor‚Äù relationship, and express that as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">expr              -> str | group | chip</code></pre></div>\n<p>Hold on, though ‚Äî all of the members of <code class=\"language-text\">expr</code> can be combined with binary expressions. So our rule for binary expressions comes first, where a binary can be a single expression, or an expression and another binary, optionally joined with an operator:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> binary+\nbinary            -> expr (('AND' | 'OR')? binary)*\nexpr              -> str | group | chip</code></pre></div>\n<p>There‚Äôs some new symbols to add to our notation here. The postfix <code class=\"language-text\">*</code> denotes zero-or-more of the previous symbol. The brackets group a collection of symbols. Finally, the postfix <code class=\"language-text\">?</code> denotes that the preceding rule is optional.</p>\n<p>With this rule, <code class=\"language-text\">str</code>, <code class=\"language-text\">str AND group</code>, <code class=\"language-text\">str AND (group OR chip)</code>, and <code class=\"language-text\">str str str</code> etc. are all valid. As with Lucene, when there‚Äôs no explicit operator between expressions, we default to <code class=\"language-text\">OR</code> ‚Äî so <code class=\"language-text\">str str</code> is interpreted as <code class=\"language-text\">str OR str</code>.</p>\n<p>For our next line, how do we unpack <code class=\"language-text\">str | group | chip</code>? Well, <code class=\"language-text\">str</code> is what we call a ‚Äúterminal‚Äù ‚Äî a symbol that represents a token. Tokens form the alphabet that makes up a grammar. So there‚Äôs no need to define <code class=\"language-text\">str</code> in our notation.</p>\n<p>Groups are simple to define ‚Äî they‚Äôre any possible binary, wrapped in parenthesis:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">group             -> '(' binary ')'</code></pre></div>\n<p>where the open and close brackets here are also terminal symbols, this time representing the literal characters <code class=\"language-text\">(</code> and <code class=\"language-text\">)</code>.</p>\n<p>Finally, the <code class=\"language-text\">chip</code> needs contain a key and a value, where both chip_key and chip_value are tokens, and chip_value is optional, to permit parsing our grammar when our query is not yet fully-formed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">chip              -> chip_key chip_value?</code></pre></div>\n<p>Which leaves us with a simple grammar:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> binary+\nbinary            -> expr ('AND' | 'OR' expr)*\nexpr              -> str | group | chip\ngroup             -> '(' binary ')'\nchip              -> chip_key chip_value?</code></pre></div>\n<p>That‚Äôs it! We might find that this grammar needs a few tweaks for useability purposes when we come to implement our UI, but the above is a great place to start.</p>\n<h2>Grammar in action</h2>\n<p>To test the grammar, we can ‚Äúplay‚Äù it ‚Äî beginning from the top, expand our symbols until we‚Äôre left with a set of tokens. For example, if we start with <code class=\"language-text\">query</code>, always expand the leftmost symbol first, and make a few arbitrary choices, we can produce something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query\nbinary+\nexpr 'AND' expr\nstr 'AND' expr\nstr 'AND' group\nstr 'AND' (binary)\nstr 'AND' (expr 'OR' expr)\nstr 'AND' (chip 'OR' expr)\nstr 'AND' ('+' str ':' str 'OR' str)</code></pre></div>\n<p>which, were we to fill in the strings, might look like <code class=\"language-text\">pets AND (+tag:cats OR feline)</code>, a valid sentence in this grammar.</p>\n<p>Of course, this grammar isn‚Äôt doing any work for us ‚Äî yet. We‚Äôll need to parse it into a machine-readable form. In the next post we‚Äôll write a program that does just that, using two techniques: <em>scanning</em>, to produce the tokens that comprise our grammar, and <em>parsing</em>, to apply the grammar to those tokens, and give us a useful structure (or an error message!) as a result.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">Bob Nystrom is a serial language designer, pedagogical genius, and S-rank <a href=\"https://x.com/munificentbob?lang=en\">twitter/mastodon</a> follow. I‚Äôll lean heavily on what I learned from <em>Crafting Interpreters</em> for the parsing/interpreting parts of this series, and if you‚Äôd like to learn more on these topics, or indeed write your very own programming language, I can‚Äôt recommend that book highly enough.<a href=\"#fnref-1\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-2\">There‚Äôs another cost here ‚Äî although our grammar might look a lot like Lucene, using <code class=\"language-text\">+</code> to start our chips clashes with <a href=\"https://lucene.apache.org/core/2_9_4/queryparsersyntax.html#:~:text=The%20%22%2B%22%20or%20required%20operator%20requires%20that%20the%20term%20after%20the%20%22%2B%22%20symbol%20exist%20somewhere%20in%20a%20the%20field%20of%20a%20single%20document.\">Lucene‚Äôs ‚Äòmust‚Äô operator</a>. So, were we to want to have our query language be a superset of Lucene‚Äôs, we‚Äôd need to have some other character for our typeahead.<a href=\"#fnref-2\" class=\"footnote-backref\">‚Ü©</a></li>\n<li id=\"fn-3\">Hm, there are a fair few things <a href=\"https://en.wikipedia.org/wiki/CQL\">already called CQL</a>. Don‚Äôt worry, we can rename it when it gets big.<a href=\"#fnref-3\" class=\"footnote-backref\">‚Ü©</a></li>\n</ol>\n</div>","frontmatter":{"title":"Structured search queries for web UIs, part 2: the grammar","date":"October 06, 2024","description":"In which we write the query language that will power our fancy UI"}}},"pageContext":{"slug":"/structured-search-ui-2/","previous":{"fields":{"slug":"/structured-search-ui-1/"},"frontmatter":{"title":"Structured search queries for web UIs, part 1: the dream"}},"next":{"fields":{"slug":"/structured-search-ui-3/"},"frontmatter":{"title":"Structured search queries for web UIs, part 3: scanning"}}}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}