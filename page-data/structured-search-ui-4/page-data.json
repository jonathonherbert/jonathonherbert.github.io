{"componentChunkName":"component---src-templates-blog-post-js","path":"/structured-search-ui-4/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"4daa88be-6196-5c16-b8de-cb69ded3fcc3","excerpt":"In part 3, we implemented a scanner that could turn a CQL query string into a list of tokens. In this post, we’ll write a parser that accepts that list of…","html":"<p>In <a href=\"./structured-search-part-3\">part 3</a>, we implemented a scanner that could turn a CQL query string into a list of tokens. In this post, we’ll write a parser that accepts that list of tokens, and outputs a a data structure that represents the query as it’s structured by the syntax of our grammar. Here’s a visualisation of what that tree looks like, so we have a sense of what we’re building before we begin:</p>\n<div data-parser>why not (+edit:me AND see)</div>\n<p>Of course, there are many ways for a query to be incorrect, and so it’s also the parser’s job to give a sensible error message when our list of tokens doesn’t make sense:</p>\n<div data-parser>( whoops!</div>\n<p>The above data structure is called an <em>Abstract Syntax Tree</em>, or <em>AST</em>, and it’s worth defining that term before we begin. “Syntax” is a word to describe the rules that describe the correct arrangement of symbols (represented in this case by tokens) in a language. So a syntax tree is a tree that represents the syntactic structure of some text according to a given grammar. In this case, the tree is “Abstract” because it will gloss over many details of the syntax in favour of representing its structure. This will become clearer as we examine the structure the parser creates.</p>\n<p>It might be that parsing a grammar like CQL is old hat to you — in which case, you’d be forgiven for skipping this post, and moving straight on to part 5 (when it’s written.)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> If not, let us begin …</p>\n<h2>The (recursive) descent 🕳️</h2>\n<p>There are many ways to write a parser, but I’m only qualified to write one sort at the time of writing: a recursive descent parser. Luckily, I’m reliably informed that recursive descent is <a href=\"https://craftinginterpreters.com/parsing-expressions.html#:~:text=use%20recursive%20descent.-,It%20rocks.,-Recursive%20descent%20is\">great.</a> Specifically, recursive descent parsers tend to be:</p>\n<ul>\n<li>Fast.</li>\n<li>Great at giving comprehensible error messages, if they’re written with that in mind.</li>\n<li>Easy to write.</li>\n</ul>\n<p>In the context of this post, the latter point is important. If you’re new to this subject and the idea of writing a parser is as daunting as spelunking into <a href=\"https://en.wikipedia.org/wiki/The_Descent\">an actual cave</a>, don’t worry. We’ll spelunk together, and I suspect you’ll be pleasantly surprised at how straightforward this part of the task is.</p>\n<p>Recursive descent parsers are easy to write because their different parts correspond to the structure of the grammar we’ve already written. Bob Nystrom has a neat summary of this mapping in Crafting Interpreters that I’ll reproduce with minor modifications here:<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<table>\n<thead>\n<tr>\n<th>Grammar notation</th>\n<th>Code representation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Terminal</td>\n<td>Code to match and consume a token</td>\n</tr>\n<tr>\n<td>Nonterminal</td>\n<td>Call to that rule’s function</td>\n</tr>\n<tr>\n<td>|</td>\n<td>Conditional or pattern match (in Typescript, an <code class=\"language-text\">if</code> or <code class=\"language-text\">switch</code> statement)</td>\n</tr>\n<tr>\n<td>* or +</td>\n<td>Loop (e.g. <code class=\"language-text\">while</code>, <code class=\"language-text\">for</code>, or recursion)</td>\n</tr>\n<tr>\n<td>?</td>\n<td>Conditional (<code class=\"language-text\">if</code> statement)</td>\n</tr>\n</tbody>\n</table>\n<p>As we parse a given CQL expression, we’re going to use these rules as we <em>descend</em> through the grammar, working through our rules <em>recursively</em> until we’ve consumed all our tokens (or thrown an error trying to do it.) And that’s why it’s called recursive descent! As a reminder, our grammar looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> binary?\nbinary            -> expr (('AND' | 'OR')? binary)*\nexpr              -> str | group | chip\ngroup             -> '(' binary ')'\nchip              -> chip_key chip_value?</code></pre></div>\n<p>We’ll start with the scaffolding — writing a class (again, in Typescript) to hold our logic and state.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Keep track of the current token.</span>\n  <span class=\"token keyword\">private</span> current<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span> tokens<span class=\"token operator\">:</span> Token<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Query <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ???</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You can see that we’ve a constructor that gives us our list of tokens, and a <code class=\"language-text\">parse</code> method that returns a <code class=\"language-text\">Query</code> to its caller: the first nonterminal in our grammar. <code class=\"language-text\">Query</code>’s first property will be a discriminator field, <code class=\"language-text\">type</code>, to allow us to identify it. Another field will hold its optional content, <code class=\"language-text\">Binary</code>, which we’ll come to define shortly:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Query</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> type <span class=\"token operator\">=</span> <span class=\"token string\">\"Query\"</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> content<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Binary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Back in our class, our nonterminal <code class=\"language-text\">Query</code> maps to a call to that rule’s function, so we’ll update our method:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Query <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Query <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>A <code class=\"language-text\">query</code> nonterminal is nice and simple: it can contain a single <code class=\"language-text\">Binary</code> — or be completely empty!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">query             -> binary?</code></pre></div>\n<p>If our statement is completely empty, the next token we parse will be an <code class=\"language-text\">EOF</code>. We’ll check to see if we should stop parsing and return an empty <code class=\"language-text\">Query</code> object, or continue working through our grammar by descending into our next nonterminal. We know that will be a <code class=\"language-text\">Binary</code>, so our next method will be <code class=\"language-text\">binary()</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Query <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> content <span class=\"token operator\">=</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>tokenType <span class=\"token operator\">===</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">EOF</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">binary</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Query</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Token <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tokens<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In <code class=\"language-text\">binary()</code>, things start to get more interesting. First, we’ll need to define our <code class=\"language-text\">Binary</code> type. Let’s have a look at the grammar rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">binary            -> expr (('AND' | 'OR')? binary)</code></pre></div>\n<p>We’ll need to store the left hand side of the binary expression, and, optionally, the operator and binary of its right hand side, too:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Binary</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> type <span class=\"token operator\">=</span> <span class=\"token string\">\"Binary\"</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> left<span class=\"token operator\">:</span> Expr<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> right<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      operator<span class=\"token operator\">:</span> <span class=\"token string\">\"OR\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"AND\"</span>\n      binary<span class=\"token operator\">:</span> Binary\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Writing our <code class=\"language-text\">binary()</code> method in the <code class=\"language-text\">Parser</code> class, we can express <code class=\"language-text\">expr (('AND' | 'OR')? binary)</code> clearly in the code, too.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> <span class=\"token function\">binary</span><span class=\"token punctuation\">(</span>isNested<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Binary <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">expr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">const</span> tokenType <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>tokenType\n\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If we have an explicit binary operator, use it …</span>\n      <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">OR</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">AND</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Binary</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n          operator<span class=\"token operator\">:</span> tokenType<span class=\"token punctuation\">,</span>\n          binary<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">binary</span><span class=\"token punctuation\">(</span>isNested<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">EOF</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Binary</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// ... or default to OR.</span>\n      <span class=\"token keyword\">default</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Binary</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n          operator<span class=\"token operator\">:</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">OR</span><span class=\"token punctuation\">,</span>\n          binary<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">binary</span><span class=\"token punctuation\">(</span>isNested<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Hopefully the logic here is clear enough — we acquire our binary’s left hand side with the yet-to-be-defined <code class=\"language-text\">this.expr()</code>. We then optionally fill out its right hand side with either an explicit binary operator (<code class=\"language-text\">AND|OR</code>) or another expression — unless we’ve come to the end of our list of tokens.</p>\n<p>But woah! We’re also calling four important methods here, <code class=\"language-text\">consume</code>, <code class=\"language-text\">check</code>, <code class=\"language-text\">isAtEnd</code> and <code class=\"language-text\">advance</code>, that we’ve yet to introduce. Here’s what they look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> consume <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tokenType<span class=\"token operator\">:</span> TokenType<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Token <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">check</span><span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">advance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Unexpected token of type </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>tokenType<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">check</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tokenType<span class=\"token operator\">:</span> TokenType<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>tokenType <span class=\"token operator\">===</span> tokenType\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">advance</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> currentToken <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tokens<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n      <span class=\"token keyword\">return</span> currentToken\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">previous</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">isAtEnd</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?.</span>tokenType <span class=\"token operator\">===</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">EOF</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">error</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">ParseError</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ParseError</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Error</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">public</span> position<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">public</span> message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>These methods are here because parsing our binary nonterminal has introduced us to our first terminals — <code class=\"language-text\">AND</code> and <code class=\"language-text\">OR</code>. When we encounter terminals, we must <code class=\"language-text\">consume</code> the tokens that represent them to move our parser to the next token, or throw an error indicating that we found something we did not expect. When reporting an error, we can use the start position of the token we were due to consume to indicate where something went wrong, and <code class=\"language-text\">ParseError</code> extends the JavaScript <code class=\"language-text\">Error</code> class to store both.</p>\n<p>Finally, <code class=\"language-text\">check</code> checks that the passed token matches the current token — and that we’re not at the end of our list of tokens, via <code class=\"language-text\">isAtEnd</code>. And <code class=\"language-text\">advance</code> moves us on one once we’re ready.</p>\n<p>If these look familiar to the methods we wrote for our scanner in the previous post, that’s a good spot! Our scanner was parsing a list of characters into a lexical grammar. Our parser parses a list of tokens into a context-free grammar. Both tasks involve inspecting a list of symbols, and parsing them until there aren’t any more, or we encounter an error in the grammar. Which leads us to a slight digression, because …</p>\n<h2>Good parsers love bad input</h2>\n<p>A lot of the time, the query we’re parsing is going to be incorrect — and not necessarily because its author has done something wrong. Most often, it will be because the statement is incomplete. For example, imagine typing <code class=\"language-text\">+tag:type/interactive (Greta OR Climate)</code>. We’re going to see:</p>\n<ul>\n<li><code class=\"language-text\">+</code> — a chip with an empty key</li>\n<li><code class=\"language-text\">+tag</code> — a chip with no value token at all</li>\n<li><code class=\"language-text\">+tag:</code> — a chip with an empty value</li>\n<li><code class=\"language-text\">+tag:type/interactive (</code> — a group missing a closing bracket</li>\n<li><code class=\"language-text\">+tag:type/interactive (Greta OR</code> — a binary expression with an operator, but no right-hand expression</li>\n</ul>\n<p>If our parser will be spending most of its time failing to parse its input, it will need to provide error messages that our users can understand. Many modern languages work hard to make their error messaging as comprehensible as possible — Rust<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup> and Elm<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> are two great examples — because the effect on the user experience is so profound.</p>\n<p>Consider some error messages for the expressions above. I’ve written them in the first person, a bit like Elm might, because I think it’s <em>charming.</em></p>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>Expression</th>\n<th>Error</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code class=\"language-text\">+</code></td>\n<td>I expected a field name after the <code class=\"language-text\">+</code>, e.g. <code class=\"language-text\">+tag</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code class=\"language-text\">+tag</code>, <code class=\"language-text\">+tag:</code></td>\n<td>I expected a colon and a field value after <code class=\"language-text\">+tag</code>, e.g. <code class=\"language-text\">+tag:value</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code class=\"language-text\">+tag:type/interactive (</code></td>\n<td>Groups can’t be empty. Add an expression after <code class=\"language-text\">(</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code class=\"language-text\">+tag:type/interactive (Greta OR</code></td>\n<td>I expected an expression after <code class=\"language-text\">OR</code></td>\n</tr>\n</tbody>\n</table>\n<p>We haven’t written the code for chips and groups yet, but we can definitely improve the error handling for case #4 in our binary parser above. Let’s add a check to see if we’re at the end of our list of tokens, and throw an error if there’s nothing after the operator:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// within binary() …</span>\n<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">OR</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">AND</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I expected an expression after \\`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>tokenType<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Binary</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      operator<span class=\"token operator\">:</span> tokenType<span class=\"token punctuation\">,</span>\n      binary<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">binary</span><span class=\"token punctuation\">(</span>isNested<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ... etc</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div data-parser>+tag:type/interactive (Greta OR</div>\n<p>Nice. Now that our <code class=\"language-text\">binary()</code> method has had a spruce, <code class=\"language-text\">Expr</code> is next, implementing the rule <code class=\"language-text\">str | group | chip</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Expr</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> type <span class=\"token operator\">=</span> <span class=\"token string\">\"Expr\"</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> content<span class=\"token operator\">:</span> Str <span class=\"token operator\">|</span> Group <span class=\"token operator\">|</span> Chip<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> <span class=\"token function\">expr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Expr <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> tokenType <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>tokenType\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>tokenType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">LEFT_BRACKET</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Expr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Expr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">case</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">CHIP_KEY</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Expr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">chip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">unexpectedTokenError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function-variable function\">unexpectedTokenError</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I didn't expect to find a '</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>lexeme<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">' </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">previous</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"here.\"</span> <span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">after '</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">previous</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?.</span>lexeme<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">'</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>A fairly straightforward switch statement, common in expressing <code class=\"language-text\">|</code> relations in rules, and an error if we don’t find what we expect. That error message can appear when we encounter a binary operator or right parenthesis instead of an expression: we take care to ensure the message makes sense for start tokens, too.</p>\n<div data-parser>) whoops!</div>\n<p>We’re almost there! In <code class=\"language-text\">group()</code>, writing the rule <code class=\"language-text\">'(' binary ')'</code> is also straightforward:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Group</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> type <span class=\"token operator\">=</span> <span class=\"token string\">\"Group\"</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> content<span class=\"token operator\">:</span> Binary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> <span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Group <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>\n      TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">LEFT_BRACKET</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"Groups must start with a left bracket\"</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">const</span> binary <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">binary</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>\n      TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">RIGHT_BRACKET</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"Groups must end with a right bracket\"</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Group</span><span class=\"token punctuation\">(</span>binary<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This also marks the first recursion in our recursive descent — the call to binary sends us back up our list of rules, to descend again.</p>\n<p>To ensure that we’re handling case #3 in our list of error messages above, we can check to make sure there’s a right bracket after we’re done consuming the content of our group, throwing an error if we encounter something unexpected:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> <span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Group <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">LEFT_BRACKET</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Groups must start with a left bracket\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAtEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>tokenType <span class=\"token operator\">===</span> TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">RIGHT_BRACKET</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Groups can't be empty. Add an expression after `(`\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// ...etc</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">str()</code> is a terminal, so we can simply consume the token and move on:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CqlStr</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> type <span class=\"token operator\">=</span> <span class=\"token string\">\"CqlStr\"</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> token<span class=\"token operator\">:</span> Token<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> <span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Str <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> token <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"I expected a string here\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Str</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Finally, <code class=\"language-text\">chip()</code> consumes up to two terminals representing the chip key and value, completing our last rule, <code class=\"language-text\">chip -> chip_key chip_value?</code>. We can add checks to handle errors #1 and #2 above:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Chip</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> type <span class=\"token operator\">=</span> <span class=\"token string\">\"Chip\"</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> key<span class=\"token operator\">:</span> Token<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> value<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Token\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">private</span> <span class=\"token function\">chip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Chip <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// We check to see if there's a literal after we consume this token,</span>\n    <span class=\"token comment\">// so there's no need for an error message here</span>\n    <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">CHIP_KEY</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>key<span class=\"token punctuation\">.</span>literal <span class=\"token operator\">||</span> key<span class=\"token punctuation\">.</span>literal <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"I expected the name of a field to search with after the `+`, e.g. `+tag`\"</span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">const</span> maybeValue <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">consume</span><span class=\"token punctuation\">(</span>\n      TokenType<span class=\"token punctuation\">.</span><span class=\"token constant\">CHIP_VALUE</span><span class=\"token punctuation\">,</span>\n      <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I expected a colon and a field value after \\`+</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token punctuation\">.</span>literal<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\`, e.g. \\`+</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token punctuation\">.</span>literal<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">:value\\`</span><span class=\"token template-punctuation string\">`</span></span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Chip</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> maybeValue<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div data-parser>+</div>\n<div data-parser>+tag</div>\n<div data-parser>+tag:type/interactive</div>\n<p>That’s the end of our grammar. We’ve just implemented a recursive descent parser for our query language, CQL! It’ll parse a valid CQL statement into an AST that represents its underlying structure, and handle common errors by emitting messages that — hopefully! — our users will understand.</p>\n<p>The parser running in this post uses the code above, and I’ve left a few rough edges for the sake of brevity that you might find as you’re playing with queries. Take a look at the code in the <a href=\"https://github.com/guardian/cql/blob/main/client/src/lang/parser.ts\">CQL project</a> to see what a (slightly) more complete implementation might look like.</p>\n<p>The next step will be creating a UI powered by this parser to help implement our big list of features in <a href=\"/structured-search-ui-1/\">Part 1</a>. We’ll cover that in Part 5.</p>\n<style>\n  .parser-container {\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  .parser-container input {\n    width: 400px;\n    max-width: 100vw;\n    margin-bottom: 10px;\n  }\n\n  .parser-container input,\n  .error-container {\n    margin-bottom: 10px;\n  }\n\n  .error-container {\n    color: red;\n  }\n\n  .tree--container {\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    width: 100%;\n  }\n\n  .tree {\n    display: block;\n    max-width: 100%;\n    margin-top: 5px;\n    overflow-y: scroll;\n  }\n\n  /*https://www.cssscript.com/clean-tree-diagram/*/\n  .tree,\n  .tree ul,\n  .tree li {\n    font-family: monospace;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    position: relative;\n  }\n\n  .tree {\n    margin: 0 0 1em;\n    text-align: center;\n    white-space: initial;\n  }\n\n  .tree,\n  .tree ul {\n    display: table;\n  }\n\n  .tree ul {\n    width: 100%;\n  }\n\n  .tree li {\n    display: table-cell;\n    padding-top: .5rem;\n    vertical-align: top;\n  }\n\n  .tree li:before {\n    outline: solid 0.5px #666;\n    content: \"\";\n    left: 0;\n    position: absolute;\n    right: 0;\n    top: 1px;\n  }\n\n  .tree li:first-child:before {\n    left: 50%;\n  }\n\n  .tree li:last-child:before {\n    right: 50%;\n  }\n\n  .tree code,\n  .tree li > span {\n    background-color: #b4cfdc;\n    border-radius: .2em;\n    display: inline-block;\n    margin: 0 .2em .5em;\n    padding: .2em .5em;\n    position: relative;\n  }\n\n  .node-content {\n    background-color: white;\n    margin-left: 5px;\n    padding: 1px 5px;\n  }\n\n  .node-pos {\n    line-break:normal;\n    padding: 0 4px;\n  }\n\n  .tree ul:before,\n  .tree code:before,\n  .tree li > span:before {\n    outline: solid 0.5px #666;\n    content: \"\";\n    height: .5em;\n    left: 50%;\n    position: absolute;\n  }\n\n  .tree ul:before {\n    top: -.5em;\n  }\n\n  .tree code:before,\n  .tree li > span:before {\n    top: -.55em;\n  }\n\n  .tree>li {\n    margin-top: 0;\n  }\n\n  .tree>li:before,\n  .tree>li:after,\n  .tree>li>code:before,\n  .tree>li>.span:before {\n    outline: none;\n  }\n</style>\n<script id=\"page-script\" type=\"module\">\n \"use strict\";\nvar _a;\nconst debug = false;\nconst TokenType = {\n    // Single-character tokens.\n    LEFT_BRACKET: \"LEFT_BRACKET\",\n    RIGHT_BRACKET: \"RIGHT_BRACKET\",\n    // Literals.\n    STRING: \"STRING\",\n    CHIP_KEY: \"CHIP_KEY\",\n    CHIP_VALUE: \"CHIP_VALUE\",\n    // Keywords.\n    AND: \"AND\",\n    OR: \"OR\",\n    EOF: \"EOF\",\n};\nclass Token {\n    constructor(tokenType, lexeme, literal, start, end) {\n        this.tokenType = tokenType;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.start = start;\n        this.end = end;\n    }\n    toString() {\n        return `${this.tokenType} ${this.lexeme} ${this.literal} ${this.start}-${this.end}`;\n    }\n}\n_a = Token;\nToken.reservedWordMap = {\n    AND: TokenType.AND,\n    OR: TokenType.OR,\n};\nToken.reservedWordStrs = Object.keys(_a.reservedWordMap);\nclass ParseError extends Error {\n    constructor(position, message) {\n        super(message);\n        this.position = position;\n        this.message = message;\n    }\n}\nclass Query {\n    constructor(content) {\n        this.content = content;\n        this.type = \"Query\";\n    }\n}\nclass Binary {\n    constructor(left, right) {\n        this.left = left;\n        this.right = right;\n        this.type = \"Binary\";\n    }\n}\nclass Expr {\n    constructor(content) {\n        this.content = content;\n        this.type = \"Expr\";\n    }\n}\nclass Group {\n    constructor(content) {\n        this.content = content;\n        this.type = \"Group\";\n    }\n}\nclass Str {\n    constructor(token) {\n        var _b;\n        this.token = token;\n        this.type = \"Str\";\n        this.searchExpr = (_b = token.literal) !== null && _b !== void 0 ? _b : \"\";\n    }\n}\nclass Chip {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.type = \"Chip\";\n    }\n}\nclass Parser {\n    constructor(tokens) {\n        this.tokens = tokens;\n        // Keep track of the current token.\n        this.current = 0;\n        this.unexpectedTokenError = () => {\n            var _b;\n            throw this.error(`I didn't expect to find a '${this.peek().lexeme}' ${!this.previous() ? \"here.\" : `after '${(_b = this.previous()) === null || _b === void 0 ? void 0 : _b.lexeme}'`}`);\n        };\n        this.consume = (tokenType, message = \"\") => {\n            if (this.check(tokenType)) {\n                return this.advance();\n            }\n            else {\n                throw this.error(message);\n            }\n        };\n        this.check = (tokenType) => {\n            if (this.isAtEnd()) {\n                return false;\n            }\n            else {\n                return this.peek().tokenType === tokenType;\n            }\n        };\n        this.advance = () => {\n            if (!this.isAtEnd()) {\n                const currentToken = this.tokens[this.current];\n                this.current = this.current + 1;\n                return currentToken;\n            }\n            else {\n                return this.previous();\n            }\n        };\n        this.previous = () => this.tokens[this.current - 1];\n        this.isAtEnd = () => { var _b; return ((_b = this.peek()) === null || _b === void 0 ? void 0 : _b.tokenType) === TokenType.EOF; };\n        this.error = (message) => new ParseError(this.peek().start, message);\n    }\n    parse() {\n        return this.query();\n    }\n    query() {\n        const content = this.peek().tokenType === TokenType.EOF ? undefined : this.binary();\n        return new Query(content);\n    }\n    binary() {\n        this.debug(\"binary\");\n        const left = this.expr();\n        const tokenType = this.peek().tokenType;\n        switch (tokenType) {\n            // If we have an explicit binary operator, use it ...\n            case TokenType.OR:\n            case TokenType.AND: {\n                this.consume(tokenType);\n                if (this.isAtEnd()) {\n                    throw this.error(`I expected an expression after \\`${tokenType}\\``);\n                }\n                return new Binary(left, {\n                    operator: tokenType,\n                    binary: this.binary(),\n                });\n            }\n            case TokenType.RIGHT_BRACKET:\n            case TokenType.EOF: {\n                return new Binary(left);\n            }\n            // ... or default to OR.\n            default: {\n                return new Binary(left, {\n                    operator: TokenType.OR,\n                    binary: this.binary(),\n                });\n            }\n        }\n    }\n    expr() {\n        this.debug(\"expr\");\n        const tokenType = this.peek().tokenType;\n        switch (tokenType) {\n            case TokenType.LEFT_BRACKET:\n                return new Expr(this.group());\n            case TokenType.STRING:\n                return new Expr(this.str());\n            case TokenType.CHIP_KEY:\n                return new Expr(this.chip());\n            default:\n                throw this.unexpectedTokenError();\n        }\n    }\n    group() {\n        this.debug(\"group\");\n        this.consume(TokenType.LEFT_BRACKET, \"Groups must start with a left bracket\");\n        if (this.isAtEnd() || this.peek().tokenType === TokenType.RIGHT_BRACKET) {\n            throw this.error(\"Groups can't be empty. Put a search term between the brackets!\");\n        }\n        const binary = this.binary();\n        this.consume(TokenType.RIGHT_BRACKET, \"Groups must end with a right bracket\");\n        return new Group(binary);\n    }\n    str() {\n        this.debug(\"str\");\n        const token = this.consume(TokenType.STRING, \"Expected a string\");\n        return new Str(token);\n    }\n    chip() {\n        this.debug(\"chip\");\n        const key = this.consume(TokenType.CHIP_KEY, \"I expected a field name after the `+`, e.g. `+tag`\");\n        if (!key.literal || key.literal === \"\") {\n            throw this.error(\"I expected the name of a field to search with after the `+`, e.g. `+tag`\");\n        }\n        const maybeValue = this.consume(TokenType.CHIP_VALUE,  `I expected a colon and a field value after \\`+${key.literal}\\`, e.g. \\`+${key.literal}:value\\``);\n        return new Chip(key, maybeValue);\n    }\n    peek() {\n        return this.tokens[this.current];\n    }\n    debug(location) {\n        if (debug) {\n            console.log(location, this.peek().tokenType);\n        }\n    }\n}\nconst whitespaceR = /\\s/;\nconst isWhitespace = (str) => whitespaceR.test(str);\nconst letterOrDigitR = /[0-9A-z]/;\nconst isLetterOrDigit = (str) => letterOrDigitR.test(str);\nclass Scanner {\n    constructor(program) {\n        this.program = program;\n        this.tokens = [];\n        this.start = 0;\n        this.current = 0;\n        this.line = 1;\n        this.scanTokens = () => {\n            while (!this.isAtEnd()) {\n                // We are at the beginning of the next lexeme.\n                this.start = this.current;\n                this.scanToken();\n            }\n            return this.tokens.concat(new Token(TokenType.EOF, \"\", undefined, this.current, this.current));\n        };\n        this.scanToken = () => {\n            switch (this.advance()) {\n                case \"+\":\n                    this.addKey(TokenType.CHIP_KEY);\n                    return;\n                case \":\":\n                    this.addValue();\n                    return;\n                case \"(\":\n                    this.addToken(TokenType.LEFT_BRACKET);\n                    return;\n                case \")\":\n                    this.addToken(TokenType.RIGHT_BRACKET);\n                    return;\n                case \" \":\n                    return;\n                case \"\\r\":\n                case \"\\t\":\n                case '\"':\n                    this.addString();\n                    return;\n                default:\n                    this.addIdentifierOrUnquotedString();\n                    return;\n            }\n        };\n        this.addKey = (tokenType) => {\n            while (this.peek() != \":\" && !isWhitespace(this.peek()) && !this.isAtEnd())\n                this.advance();\n            if (this.current - this.start === 1)\n                this.addToken(tokenType);\n            else {\n                const key = this.program.substring(this.start + 1, this.current);\n                this.addToken(tokenType, key);\n            }\n        };\n        this.addValue = () => {\n            while (!isWhitespace(this.peek()) && !this.isAtEnd())\n                this.advance();\n            if (this.current - this.start == 1) {\n                this.addToken(TokenType.CHIP_VALUE);\n            }\n            else {\n                const value = this.program.substring(this.start + 1, this.current);\n                this.addToken(TokenType.CHIP_VALUE, value);\n            }\n        };\n        this.addIdentifierOrUnquotedString = () => {\n            while (isLetterOrDigit(this.peek())) {\n                this.advance();\n            }\n            const text = this.program.substring(this.start, this.current);\n            const maybeReservedWord = Token.reservedWordMap[text];\n            return maybeReservedWord\n                ? this.addToken(maybeReservedWord)\n                : this.addUnquotedString();\n        };\n        this.addUnquotedString = () => {\n            while (\n            // Consume whitespace up until the last whitespace char\n            (!isWhitespace(this.peek()) ||\n                isWhitespace(this.peek(1)) ||\n                this.isAtEnd(1)) &&\n                this.peek() != \")\" &&\n                !this.isAtEnd()) {\n                this.advance();\n            }\n            this.addToken(TokenType.STRING, this.program.substring(this.start, this.current));\n        };\n        this.addString = () => {\n            while (this.peek() != '\"' && !this.isAtEnd()) {\n                this.advance();\n            }\n            if (this.isAtEnd()) {\n                this.error(this.line, \"Unterminated string at end of file\");\n            }\n            else {\n                this.advance();\n            }\n            this.addToken(TokenType.STRING, this.program.substring(this.start + 1, this.current - 1));\n        };\n        this.addToken = (tokenType, literal) => {\n            const text = this.program.substring(this.start, this.current);\n            this.tokens = this.tokens.concat(new Token(tokenType, text, literal, this.start, this.current - 1));\n        };\n        this.advance = () => {\n            const previous = this.current;\n            this.current = this.current + 1;\n            return this.program[previous];\n        };\n        this.peek = (offset = 0) => this.program[this.current + offset] === undefined\n            ? \"\\u0000\"\n            : this.program[this.current + offset];\n        this.isAtEnd = (offset = 0) => this.current + offset === this.program.length;\n        this.error = (line, message) => this.report(line, \"\", message);\n        this.report = (line, where, message) => {\n            console.log(`[line ${line}] Error${where}: ${message}`);\n        };\n    }\n}\n\n    const getDebugTokenHTML = (tokens) => {\n        let html = `\n        <div class=\"CqlDebug__queryDiagram CqlDebug__queryDiagramToken\">\n        <div class=\"CqlDebug__queryDiagramLabel\">\n            <div>Lexeme</div>\n            <div>Literal</div>\n        </div>\n        <div class=\"CqlDebug__queryDiagramContent\">`;\n        tokens.forEach((token, index) => {\n            var _b, _c;\n            html += `${Array(Math.max(1, token.lexeme.length))\n                .fill(undefined)\n                .map((_, index) => {\n                var _b, _c;\n                const lexemeChar = token.lexeme[index];\n                const literalOffset = ((_b = token.literal) === null || _b === void 0 ? void 0 : _b.length) === token.lexeme.length ? 0 : 1;\n                const literalChar = (_c = token.literal) === null || _c === void 0 ? void 0 : _c[index - literalOffset];\n                return `\n            <div class=\"CqlDebug__queryBox\">\n            <div class=\"CqlDebug__queryIndex\">${token.start + index}</div>\n            ${lexemeChar !== undefined\n                    ? `<div class=\"CqlDebug__queryChar\">${lexemeChar}</div>`\n                    : \"\"}\n                ${literalChar !== undefined\n                    ? `<div class=\"CqlDebug__queryChar CqlDebug__queryCharAlt\">${literalChar}</div>`\n                    : \"\"}\n            ${index === 0\n                    ? `<div class=\"CqlDebug__tokenLabel\">${token.tokenType}</div>`\n                    : \"\"}\n            </div>`;\n            })\n                .join(\"\")}\n        ${((_b = tokens[index + 1]) === null || _b === void 0 ? void 0 : _b.start) > token.end + 1 && ((_c = tokens[index + 1]) === null || _c === void 0 ? void 0 : _c.tokenType) !== \"EOF\" && token.tokenType !== \"EOF\"\n                ? `<div class=\"CqlDebug__queryBox\"><div class=\"CqlDebug__queryIndex\">${token.end + 1}</div></div>`\n                : \"\"}`;\n        });\n        html += \"</div></div>\";\n        return html;\n    }\n\nconst getDebugASTHTML = (query) => {\n    return `<div class=\"tree--container\">\n    ${getQueryHTML(query)}\n  </div>`;\n};\nconst getQueryHTML = (query) => {\n    const queryHTML = query.content ? `\n    <ul>\n      <li>${getBinaryHTML(query.content)}</li>\n    </ul>` : \"\"\n    return `<ul class=\"tree\">\n    <li>\n      ${getNodeHTML(query)}\n      ${queryHTML}\n    </li>\n  </ul>`;\n};\nconst getExprHTML = (query) => {\n    const { content }  = query;\n    const html = (() => {\n        switch (content.type) {\n            case \"Binary\":\n                return getBinaryHTML(content);\n            case \"Chip\":\n                return getChipHTML(content);\n            case \"Group\":\n                return getGroupHTML(content);\n            case \"Str\":\n                return getStrHTML(content);\n            default:\n                console.error(`No HTML representation for ${content.type}`)\n        }\n    })();\n    return `\n    <ul>\n      <li>\n        <span>${getNodeHTML(query)}</span>\n        ${html}\n      </li>\n    </ul>`;\n};\nconst getBinaryHTML = (query) => {\n    const maybeRight = query.right;\n    const leftHTML = getExprHTML(query.left)\n    const binaryContent = maybeRight ? `\n     <ul>\n        <li>${leftHTML}</li>\n        <li>${getBinaryHTML(maybeRight.binary)}</li>\n      </ul>\n  ` : leftHTML;\n    return `\n    <ul>\n      <li>\n        <span>\n          ${getNodeHTML(query)}\n          ${maybeRight ? `<span class=\"node-content\">${maybeRight.operator}</span>` : ``}\n        </span>\n        ${binaryContent}\n      </li>\n    </ul>\n  `;\n};\nconst getChipHTML = (chip) => {\n    return `\n    <ul>\n      <li>\n        <span>${getNodeHTML(chip)}</span>\n        <ul>\n          <li>${getTokenHTML(chip.key)}</li>\n          ${chip.value ? `<li>${getTokenHTML(chip.value)}</li>` : \"\"}\n        </ul>\n    </ul>\n  `;\n};\nconst getTokenHTML = (token) => {\n    return `\n    <span>${token.tokenType}\n    <span class=\"node-content\">${token.literal}</span>\n      <span class=\"node-pos\">${token.start}‑${token.end}</span>\n    </span>\n  `;\n};\nconst getGroupHTML = (group) => {\n    return `\n    <ul>\n      <li>\n        ${getNodeHTML(group)}\n        ${getBinaryHTML(group.content)}\n      </li>\n    </ul>\n  `;\n};\nconst getStrHTML = (str) => {\n  return `\n    <ul>\n      <li>\n        <span>\n          ${getNodeHTML(str)}\n          <span class=\"node-content\">${str.searchExpr}</span>\n          <span class=\"node-pos\">${str.token.start}‑${str.token.end}</span>\n        </span>\n      </li>\n    </ul>\n  `;\n};\nconst getNodeHTML = (node) => `<span class=\"node-description\">${node.type}</span>`;\n\n\n    // Userland\n\n    const createParser = (el, initialQuery) => {\n        el.innerHTML = \"\";\n        el.classList.add(\"parser-container\")\n        const input = document.createElement(\"input\");\n        input.value = initialQuery;\n        el.appendChild(input);\n        const resultContainer = document.createElement(\"div\");\n        resultContainer.classList.add(\"result-container\");\n        el.appendChild(resultContainer);\n\n        const applyScan = value => {\n            const scanner = new Scanner(value);\n            const tokens = scanner.scanTokens();\n            const parser = new Parser(tokens);\n            try {\n              const ast = parser.parse();\n              console.log(ast)\n              resultContainer.innerHTML = getDebugASTHTML(ast);\n            } catch(e) {\n              resultContainer.innerHTML = `<div class=\"error-container\">Error at position ${e.position}: ${e.message}</div>`\n            }\n        }\n\n        input.addEventListener(\"input\", e => {\n            const value = e.target.value;\n            applyScan(value);\n        })\n\n        applyScan(initialQuery);\n    }\n\n    document.querySelectorAll(\"[data-parser]\").forEach(el => {\n        createParser(el, el.innerText)\n    });\n</script>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">But better still: read it anyway, and let me know what isn’t right!<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://craftinginterpreters.com/parsing-expressions.html#:~:text=The%20body%20of%20the%20rule%20translates%20to%20code%20roughly%20like%3A\">Crafting interpreters — parsing expressions.</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">Here’s a <a href=\"https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html\">Rust blogpost</a> that discusses their approach.<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">… and a <a href=\"https://elm-lang.org/news/compiler-errors-for-humans\">post by the creator of Elm</a> on Elm’s approach to error handling.<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","frontmatter":{"title":"Structured search queries for web UIs, part 4: parsing","date":"January 25, 2025","description":"Grammar (parsin') time"}}},"pageContext":{"slug":"/structured-search-ui-4/","previous":{"fields":{"slug":"/structured-search-ui-3/"},"frontmatter":{"title":"Structured search queries for web UIs, part 3: scanning"}},"next":{"fields":{"slug":"/structured-search-ui-5/"},"frontmatter":{"title":"Structured search queries for web UIs, part 5: the interface"}}}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}