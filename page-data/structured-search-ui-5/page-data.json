{"componentChunkName":"component---src-templates-blog-post-js","path":"/structured-search-ui-5/","result":{"data":{"site":{"siteMetadata":{"title":"jsh"}},"markdownRemark":{"id":"2dc1bfa8-e642-5c6a-9a86-68254edb3c4a","excerpt":"With our parser for CQL complete in part 4, it‚Äôs time to implement our UI. In part 1, we had an ambitious list of features for our search component‚Ä¶","html":"<p>With our parser for CQL complete in <a href=\"/structured-search-ui-4\">part 4</a>, it‚Äôs time to implement our UI. In <a href=\"/structured-search-ui-1\">part 1</a>, we had an ambitious list of features for our search component:</p>\n<ul>\n<li>üîç Discoverability</li>\n<li>‚å®Ô∏è Keyboard-only input</li>\n<li>üìÑ Query as single document</li>\n<li>üíª Binary operators and groups</li>\n<li>üß≥ Portability (copy and paste)</li>\n<li>‚ú® Syntax highlighting</li>\n<li>üö® Real-time error reporting</li>\n</ul>\n<p>In this post, we‚Äôll lay the foundations for a UI component that will eventually be powerful enough to express all of them.</p>\n<p>When I set out to build the view, I wanted something that wasn‚Äôt tied to particular product. Although our search grammar seems quite specific, we can imagine serving a subset, or superset, of its features for different use cases. For example:</p>\n<ul>\n<li>The Guardian‚Äôs digital asset management system, The Grid, supports key-value pairs, but no boolean operators or groups.</li>\n<li>The Guardian‚Äôs Content API supports all of those things in most cases, but does not permit key-value pairs within groups.</li>\n<li>Kibana supports all of those things, and more, via KQL or Lucene.</li>\n</ul>\n<p>So it feels like it should be possible to configure our parser to enable or disable features, or to swap it for another parser that supports more features, or another query language altogether. Each product will also have different requirements for its typeahead, too ‚Äî some keys and values may be known ahead of time, some will need to be discovered asynchronously as a product of their context, and the way that this happens is likely to differ from product to product.</p>\n<p>In short, the component view, parser and typeahead are best kept loosely coupled with clear interfaces, and composed together into a component, like so:</p>\n<p><svg id=\"mermaid-0\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"flowchart\" style=\"max-width: 471.296875px;\" viewBox=\"0 0.3281402587890625 471.296875 185.3975830078125\" role=\"graphics-document document\" aria-roledescription=\"flowchart-v2\"><style>#mermaid-0{font-family:arial,sans-serif;font-size:16px;fill:#000000;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-0 .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-0 .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-0 .error-icon{fill:#552222;}#mermaid-0 .error-text{fill:#552222;stroke:#552222;}#mermaid-0 .edge-thickness-normal{stroke-width:1px;}#mermaid-0 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-0 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-0 .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-0 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-0 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-0 .marker{fill:#666;stroke:#666;}#mermaid-0 .marker.cross{stroke:#666;}#mermaid-0 svg{font-family:arial,sans-serif;font-size:16px;}#mermaid-0 p{margin:0;}#mermaid-0 .label{font-family:arial,sans-serif;color:#000000;}#mermaid-0 .cluster-label text{fill:#333;}#mermaid-0 .cluster-label span{color:#333;}#mermaid-0 .cluster-label span p{background-color:transparent;}#mermaid-0 .label text,#mermaid-0 span{fill:#000000;color:#000000;}#mermaid-0 .node rect,#mermaid-0 .node circle,#mermaid-0 .node ellipse,#mermaid-0 .node polygon,#mermaid-0 .node path{fill:#eee;stroke:#999;stroke-width:1px;}#mermaid-0 .rough-node .label text,#mermaid-0 .node .label text,#mermaid-0 .image-shape .label,#mermaid-0 .icon-shape .label{text-anchor:middle;}#mermaid-0 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-0 .rough-node .label,#mermaid-0 .node .label,#mermaid-0 .image-shape .label,#mermaid-0 .icon-shape .label{text-align:center;}#mermaid-0 .node.clickable{cursor:pointer;}#mermaid-0 .root .anchor path{fill:#666!important;stroke-width:0;stroke:#666;}#mermaid-0 .arrowheadPath{fill:#333333;}#mermaid-0 .edgePath .path{stroke:#666;stroke-width:2.0px;}#mermaid-0 .flowchart-link{stroke:#666;fill:none;}#mermaid-0 .edgeLabel{background-color:white;text-align:center;}#mermaid-0 .edgeLabel p{background-color:white;}#mermaid-0 .edgeLabel rect{opacity:0.5;background-color:white;fill:white;}#mermaid-0 .labelBkg{background-color:rgba(255, 255, 255, 0.5);}#mermaid-0 .cluster rect{fill:hsl(0, 0%, 98.9215686275%);stroke:#707070;stroke-width:1px;}#mermaid-0 .cluster text{fill:#333;}#mermaid-0 .cluster span{color:#333;}#mermaid-0 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:arial,sans-serif;font-size:12px;background:hsl(-160, 0%, 93.3333333333%);border:1px solid #707070;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-0 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#000000;}#mermaid-0 rect.text{fill:none;stroke-width:0;}#mermaid-0 .icon-shape,#mermaid-0 .image-shape{background-color:white;text-align:center;}#mermaid-0 .icon-shape p,#mermaid-0 .image-shape p{background-color:white;padding:2px;}#mermaid-0 .icon-shape rect,#mermaid-0 .image-shape rect{opacity:0.5;background-color:white;fill:white;}#mermaid-0 .label-icon{display:inline-block;height:1em;overflow:visible;vertical-align:-0.125em;}#mermaid-0 .node .label-icon path{fill:currentColor;stroke:revert;stroke-width:revert;}#mermaid-0 .node rect{fill:#fff;stroke:#ddd;stroke-width:2px;stroke-linejoin:round;}#mermaid-0 path.edge-thickness-normal{stroke:#ddd;stroke-width:2px;}#mermaid-0 .marker{stroke:#bbb!important;fill:#bbb!important;stroke-width:3px!important;}#mermaid-0 *{font-family:'Lora',sans-serif;}#mermaid-0 :root{--mermaid-font-family:arial,sans-serif;}</style><g><marker id=\"mermaid-0_flowchart-v2-pointEnd\" class=\"marker flowchart-v2\" viewBox=\"0 0 10 10\" refX=\"5\" refY=\"5\" markerUnits=\"userSpaceOnUse\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\"><path d=\"M 0 0 L 10 5 L 0 10 z\" class=\"arrowMarkerPath\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></path></marker><marker id=\"mermaid-0_flowchart-v2-pointStart\" class=\"marker flowchart-v2\" viewBox=\"0 0 10 10\" refX=\"4.5\" refY=\"5\" markerUnits=\"userSpaceOnUse\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\"><path d=\"M 0 5 L 10 10 L 10 0 z\" class=\"arrowMarkerPath\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></path></marker><marker id=\"mermaid-0_flowchart-v2-circleEnd\" class=\"marker flowchart-v2\" viewBox=\"0 0 10 10\" refX=\"11\" refY=\"5\" markerUnits=\"userSpaceOnUse\" markerWidth=\"11\" markerHeight=\"11\" orient=\"auto\"><circle cx=\"5\" cy=\"5\" r=\"5\" class=\"arrowMarkerPath\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></circle></marker><marker id=\"mermaid-0_flowchart-v2-circleStart\" class=\"marker flowchart-v2\" viewBox=\"0 0 10 10\" refX=\"-1\" refY=\"5\" markerUnits=\"userSpaceOnUse\" markerWidth=\"11\" markerHeight=\"11\" orient=\"auto\"><circle cx=\"5\" cy=\"5\" r=\"5\" class=\"arrowMarkerPath\" style=\"stroke-width: 1; stroke-dasharray: 1, 0;\"></circle></marker><marker id=\"mermaid-0_flowchart-v2-crossEnd\" class=\"marker cross flowchart-v2\" viewBox=\"0 0 11 11\" refX=\"12\" refY=\"5.2\" markerUnits=\"userSpaceOnUse\" markerWidth=\"11\" markerHeight=\"11\" orient=\"auto\"><path d=\"M 1,1 l 9,9 M 10,1 l -9,9\" class=\"arrowMarkerPath\" style=\"stroke-width: 2; stroke-dasharray: 1, 0;\"></path></marker><marker id=\"mermaid-0_flowchart-v2-crossStart\" class=\"marker cross flowchart-v2\" viewBox=\"0 0 11 11\" refX=\"-1\" refY=\"5.2\" markerUnits=\"userSpaceOnUse\" markerWidth=\"11\" markerHeight=\"11\" orient=\"auto\"><path d=\"M 1,1 l 9,9 M 10,1 l -9,9\" class=\"arrowMarkerPath\" style=\"stroke-width: 2; stroke-dasharray: 1, 0;\"></path></marker><g class=\"root\"><g class=\"clusters\"></g><g class=\"edgePaths\"><path d=\"M340.141,50.905L318.993,54.421C297.846,57.937,255.552,64.968,216.59,70.964C177.628,76.959,141.998,81.919,124.183,84.399L106.368,86.878\" id=\"L_LS_UI_0\" class=\"edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link\" style=\";\" data-edge=\"true\" data-et=\"edge\" data-id=\"L_LS_UI_0\" data-points=\"W3sieCI6MzQwLjE0MDYyNSwieSI6NTAuOTA1MDUyNjA0MjM0MzE0fSx7IngiOjIxMy4yNTc4MTI1LCJ5Ijo3Mn0seyJ4IjoxMDIuNDA2MjUsInkiOjg3LjQyOTY4NzExMzgzNTJ9XQ==\" marker-end=\"url(#mermaid-0_flowchart-v2-pointEnd)\"></path><path d=\"M102.406,71.9L120.882,63.25C139.357,54.6,176.307,37.3,215.268,31.148C254.229,24.995,295.199,29.99,315.685,32.488L336.17,34.986\" id=\"L_UI_LS_0\" class=\"edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link\" style=\";\" data-edge=\"true\" data-et=\"edge\" data-id=\"L_UI_LS_0\" data-points=\"W3sieCI6MTAyLjQwNjI1LCJ5Ijo3MS44OTk4NTY2NTU2Mjc1fSx7IngiOjIxMy4yNTc4MTI1LCJ5IjoyMH0seyJ4IjozNDAuMTQwNjI1LCJ5IjozNS40Njk2MjgwOTAyMjgxN31d\" marker-end=\"url(#mermaid-0_flowchart-v2-pointEnd)\"></path><path d=\"M324.109,154.485L305.634,156.737C287.159,158.99,250.208,163.495,213.862,157.38C177.515,151.265,141.772,134.531,123.9,126.164L106.029,117.796\" id=\"L_TH_UI_0\" class=\"edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link\" style=\";\" data-edge=\"true\" data-et=\"edge\" data-id=\"L_TH_UI_0\" data-points=\"W3sieCI6MzI0LjEwOTM3NSwieSI6MTU0LjQ4NDkxMTQ2MDM2Mjh9LHsieCI6MjEzLjI1NzgxMjUsInkiOjE2OH0seyJ4IjoxMDIuNDA2MjUsInkiOjExNi4xMDAxNDMzNDQzNzI1fV0=\" marker-end=\"url(#mermaid-0_flowchart-v2-pointEnd)\"></path><path d=\"M102.406,100.57L120.882,103.142C139.357,105.714,176.307,110.857,212.6,116.391C248.893,121.925,284.528,127.849,302.346,130.811L320.164,133.774\" id=\"L_UI_TH_0\" class=\"edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link\" style=\";\" data-edge=\"true\" data-et=\"edge\" data-id=\"L_UI_TH_0\" data-points=\"W3sieCI6MTAyLjQwNjI1LCJ5IjoxMDAuNTcwMzEyODg2MTY0OH0seyJ4IjoyMTMuMjU3ODEyNSwieSI6MTE2fSx7IngiOjMyNC4xMDkzNzUsInkiOjEzNC40Mjk2NjYxOTA0MTQzNH1d\" marker-end=\"url(#mermaid-0_flowchart-v2-pointEnd)\"></path></g><g class=\"edgeLabels\"><g class=\"edgeLabel\" transform=\"translate(221.49681, 70.63022)\"><g class=\"label\" data-id=\"L_LS_UI_0\" transform=\"translate(-33.5, -12)\"><foreignObject width=\"67\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" class=\"labelBkg\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"edgeLabel\"><p>CQL AST</p></span></div></foreignObject></g></g><g class=\"edgeLabel\" transform=\"translate(215.94926, 20.32814)\"><g class=\"label\" data-id=\"L_UI_LS_0\" transform=\"translate(-40.1640625, -12)\"><foreignObject width=\"80.328125\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" class=\"labelBkg\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"edgeLabel\"><p>CQL Query</p></span></div></foreignObject></g></g><g class=\"edgeLabel\" transform=\"translate(208.40025, 165.72573)\"><g class=\"label\" data-id=\"L_TH_UI_0\" transform=\"translate(-85.8515625, -12)\"><foreignObject width=\"171.703125\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" class=\"labelBkg\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"edgeLabel\"><p>Typeahead Suggestions</p></span></div></foreignObject></g></g><g class=\"edgeLabel\" transform=\"translate(213.2578125, 116)\"><g class=\"label\" data-id=\"L_UI_TH_0\" transform=\"translate(-33.5, -12)\"><foreignObject width=\"67\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" class=\"labelBkg\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"edgeLabel\"><p>CQL AST</p></span></div></foreignObject></g></g></g><g class=\"nodes\"><g class=\"node default\" id=\"flowchart-UI-0\" transform=\"translate(55.203125, 94)\"><rect class=\"basic label-container\" style=\"\" x=\"-47.203125\" y=\"-27\" width=\"94.40625\" height=\"54\"></rect><g class=\"label\" style=\"\" transform=\"translate(-17.203125, -12)\"><rect></rect><foreignObject width=\"34.40625\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"nodeLabel\"><p>View</p></span></div></foreignObject></g></g><g class=\"node default\" id=\"flowchart-LS-1\" transform=\"translate(393.703125, 42)\"><rect class=\"basic label-container\" style=\"\" x=\"-53.5625\" y=\"-27\" width=\"107.125\" height=\"54\"></rect><g class=\"label\" style=\"\" transform=\"translate(-23.5625, -12)\"><rect></rect><foreignObject width=\"47.125\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"nodeLabel\"><p>Parser</p></span></div></foreignObject></g></g><g class=\"node default\" id=\"flowchart-TH-5\" transform=\"translate(393.703125, 146)\"><rect class=\"basic label-container\" style=\"\" x=\"-69.59375\" y=\"-27\" width=\"139.1875\" height=\"54\"></rect><g class=\"label\" style=\"\" transform=\"translate(-39.59375, -12)\"><rect></rect><foreignObject width=\"79.1875\" height=\"24\"><div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;\"><span class=\"nodeLabel\"><p>Typeahead</p></span></div></foreignObject></g></g></g></g></g></svg></p>\n<p>There are aspects of the view that are tricky. Let‚Äôs start with syntax highlighting. On its own, this is fairly straightforward to implement ‚Äî a common trick is to use a standard HTML <code class=\"language-text\">input</code> element, make its contents invisible, and then overlay that input with an element that renders its content identically, save for the additional styling. GitHub uses this trick to achieve its highlighting. The input content is grey in the animation below:</p>\n<p><img src=\"/596b56fad25a44db546b67e50bb9baad/github-input.gif\" alt=\"GitHub&#x27;s approach to syntax highlighting in its query input, embiggened and animated for demonstration purposes.\"></p>\n<p>Even better, there‚Äôs a new CSS feature, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CSS_Custom_Highlight_API\">Custom Highlight API</a>, which is now widely available in modern browsers, and is probably a better solution if you don‚Äôt need legacy browser support.</p>\n<p>Our query UI goes beyond coloured text, though. I‚Äôd like to add a visual representation of our chips that makes their role in queries clearer, a bit like the UX for Giant we‚Äôve briefly seen in part 1. You can see below that key-value pairs have their own visual treatment, as well as a way to remove them with a click:</p>\n<p><img src=\"/e878e2b4bebe415e87156670e95ee87e/giant-chips.gif\" alt=\"alt text\"></p>\n<p>That sort of thing isn‚Äôt possible with the above approach, because the additional spacing around each chip can‚Äôt be accounted for in the plain text accepted by an <code class=\"language-text\">input</code> element of type <code class=\"language-text\">text</code>.</p>\n<p>There are many ways we can implement this UI sugar. Giant does it by rendering each query element ‚Äî search text, chip key, chip value ‚Äî as its own input. The search component then manages cursor movement manually as users move the caret across those elements with the keyboard. This works well for collapsed selections (selections for which <code class=\"language-text\">from</code> and <code class=\"language-text\">to</code> are equal), where there‚Äôs only a caret to represent, but it‚Äôs trickier to represent selections that cut across multiple fields, or the entire document: the <code class=\"language-text\">üìÑ Query as single document</code> feature above. Giant simply doesn‚Äôt implement that.</p>\n<p>Another way to do this might be to treat the entire query as a single, <code class=\"language-text\">contenteditable</code> interface, giving us copy and paste for free, and letting us insert arbitrary markup to style different parts of our query. Unfortuately, working with <code class=\"language-text\">contenteditable</code> is <a href=\"https://www.youtube.com/watch?v=EEF2DlOUkag\">widely acknowledged</a> to be <a href=\"https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480#.mqvm5uq1o\">a terrible time</a>.</p>\n<p>Happily, this is where I can activate a trap card! For some number of years now, I‚Äôve worked on-and-off on the Guardian‚Äôs CMS, Composer, which is powered by the open-source text editor library <a href=\"https://prosemirror.net\">ProseMirror</a> since 2018. ProseMirror does a good enough job of abstracting the gnarly parts of contenteditable behind a clean, stable interface that some non-trivial subset of the publishing world use it for their tooling, too.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> Which makes implementing the final part of the CQL project a neat intersection of two fun things:</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\n                text-align: center;\n                color: #b1afaf;\n                font-size: 0.75em;\n              \">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b4b730f93b258fd2a6a35869d13b191a/66cde/venn.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.265625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB6O6l0soD/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECERITMf/aAAgBAQABBQKUpbOvJooVMo//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAABBQAAAAAAAAAAAAAAAAABACAhIkH/2gAIAQEABj8CE11Fv//EABgQAQADAQAAAAAAAAAAAAAAAAEAESFh/9oACAEBAAE/ISUjrLeRyGIiJtoSmADJ/9oADAMBAAIAAwAAABDTz//EABYRAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxARf//EABYRAAMAAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPxCoqP/EABwQAQADAAIDAAAAAAAAAAAAAAEAESExUUFhcf/aAAgBAQABPxBD8UEiPdVsOcaCeoDzB6uam0+MJrAHeZUhP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"With apologies to Edith Pritchett.\"\n        title=\"\"\n        src=\"/static/b4b730f93b258fd2a6a35869d13b191a/72e01/venn.jpg\"\n        srcset=\"/static/b4b730f93b258fd2a6a35869d13b191a/e4a55/venn.jpg 256w,\n/static/b4b730f93b258fd2a6a35869d13b191a/36dd4/venn.jpg 512w,\n/static/b4b730f93b258fd2a6a35869d13b191a/72e01/venn.jpg 1024w,\n/static/b4b730f93b258fd2a6a35869d13b191a/66cde/venn.jpg 1045w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>With apologies to Edith Pritchett.</p></figcaption>\n  </figure></p>\n<p>The downside is the bundle cost: around 60kb of JavaScript, minified and gzipped, for the library. As we‚Äôre in prototype mode, and writing ProseMirror code is likely to be quicker and less buggy than writing our own code to achieve the same thing, we‚Äôll use ProseMirror for now. We can always write our own view implementation if a minimal bundle size becomes a constraint.</p>\n<p>With all this in mind, let‚Äôs write some code. We‚Äôll express our UI as a web component, for portability, with a simple interface like:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In HTML</span>\n<span class=\"token punctuation\">;</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>cql-input</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>example-input<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>cql-input</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\">// In JavaScript</span>\n<span class=\"token keyword\">const</span> input <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"example-input\"</span><span class=\"token punctuation\">)</span>\ninput<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"query-change\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">queryStr</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Do something with the new query :)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The scaffolding for a web component looks a bit like:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">CqlResult</span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      tokens<span class=\"token operator\">:</span> Token<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">{</span>\n      queryAst<span class=\"token operator\">:</span> CqlQuery\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span>\n      error<span class=\"token operator\">:</span> Error\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">createCqlInput</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">parseCqlQuery</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>cqlQuery<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> CqlResult\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">CqlInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HTMLElement</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> value <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token keyword\">private</span> styleTemplate <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"template\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> editorView<span class=\"token operator\">:</span> EditorView <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span>\n\n    <span class=\"token function\">connectedCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Set up shadow DOM and styling</span>\n      <span class=\"token keyword\">const</span> shadow <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">attachShadow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> mode<span class=\"token operator\">:</span> <span class=\"token string\">\"open\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      template<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;style>/* styling will go here */&lt;/style></span><span class=\"token template-punctuation string\">`</span></span>\n      shadow<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">.</span><span class=\"token function\">cloneNode</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token comment\">// Attach input element to shadow DOM</span>\n      <span class=\"token keyword\">const</span> cqlInputId <span class=\"token operator\">=</span> <span class=\"token string\">\"cql-input\"</span>\n      <span class=\"token keyword\">const</span> cqlInput <span class=\"token operator\">=</span> shadow<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span>cqlInputId<span class=\"token punctuation\">)</span><span class=\"token operator\">!</span>\n      shadow<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div id=\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>cqlInputId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" spellcheck=\"false\">&lt;/div></span><span class=\"token template-punctuation string\">`</span></span>\n\n      <span class=\"token comment\">// Add a change handler</span>\n      <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onChange</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>detail<span class=\"token operator\">:</span> QueryChangeEventDetail<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> detail<span class=\"token punctuation\">.</span>cqlQuery\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">CustomEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"query-change\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n            detail<span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\">// Create our ProseMirror view, bound to the input element, and pass</span>\n      <span class=\"token comment\">// a change handler to call when the document state changes</span>\n      <span class=\"token keyword\">const</span> editorView <span class=\"token operator\">=</span> <span class=\"token function\">createEditorView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        mountEl<span class=\"token operator\">:</span> cqlInput<span class=\"token punctuation\">,</span>\n        onChange<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">disconnectedCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>editorView<span class=\"token operator\">?.</span><span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> CqlInput\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We‚Äôre assuming the existence of a function that, given a CQL query, returns a list of tokens, and either a CQL AST, or an error. This makes our CQL component pluggable ‚Äî the user can bring their own parser implementation. There‚Äôs some boilerplate to set up the component DOM and styling, and then we call <code class=\"language-text\">createEditorView</code>, which will create an instance of a ProseMirror editor. Here‚Äôs what that looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> EditorView <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"prosemirror-view\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> EditorState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"prosemirror-state\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> baseKeymap <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"prosemirror-commands\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> undo<span class=\"token punctuation\">,</span> redo<span class=\"token punctuation\">,</span> history <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"prosemirror-history\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> keymap <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"prosemirror-keymap\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> doc <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./schema\"</span>\n\n<span class=\"token keyword\">const</span> schema <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Schema</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  nodes<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    doc<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      content<span class=\"token operator\">:</span> <span class=\"token string\">\"text*\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    text<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">createEditorView</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> mountEl <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> mountEl<span class=\"token operator\">:</span> HTMLElement <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> view <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EditorView</span><span class=\"token punctuation\">(</span>mountEl<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token operator\">:</span> EditorState<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      doc<span class=\"token operator\">:</span> doc<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      schema<span class=\"token operator\">:</span> schema<span class=\"token punctuation\">,</span>\n      plugins<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token function\">keymap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n          <span class=\"token operator\">...</span>baseKeymap<span class=\"token punctuation\">,</span>\n          <span class=\"token string-property property\">\"Mod-z\"</span><span class=\"token operator\">:</span> undo<span class=\"token punctuation\">,</span>\n          <span class=\"token string-property property\">\"Mod-y\"</span><span class=\"token operator\">:</span> redo<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function\">history</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> view\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This will create a standard ProseMirror editor with some basic functionality: platform-specific keybindings for <a href=\"https://prosemirror.net/docs/ref/#commands.baseKeymap\">common actions</a>, and document history for undo/redo with the <a href=\"https://prosemirror.net/docs/ref/#history\"><code class=\"language-text\">prosemirror-history</code> plugin.</a></p>\n<p>But hang on ‚Äî what‚Äôs <code class=\"language-text\">schema</code>? A ProseMirror editor requires a schema to enforce its document structure. A document structure is a tree, just like the contents of a HTML element, but unlike <code class=\"language-text\">contenteditable</code>, a ProseMirror document doesn‚Äôt contain arbitrary content: the document schema establishes what nodes can exist in its document, and how they can be combined. We‚Äôll dig into schemas in more detail later in this post, but for now, our needs are very basic ‚Äî the above schema defines a document that can only contain plain text. Here‚Äôs how our input looks:</p>\n<div data-pm-input></div>\n<p>It‚Äôs not much! But there is some important functionality here, even in this very simple input. Firstly, perhaps you can pop the devtools to note that the input is definitely a <code class=\"language-text\">div</code> element with <code class=\"language-text\">contenteditable</code> enabled, rather than an <code class=\"language-text\">input</code>, as it might appear. However, <em>unlike</em> a standard contenteditable element, our ProseMirror element won‚Äôt accept arbitrary HTML ‚Äî if you copy and paste some <strong>content</strong> <del>with</del> <em>markup</em> (like the preceding words) into it, you‚Äôll find that ProseMirror enforces the document schema, stripping any structure or styling to make sure that it only contains plain text.</p>\n<p>So far, so good ‚Äî but that‚Äôs about 60kb of library code we‚Äôre sending across the wire to provide something that HTML gives us with <code class=\"language-text\">input</code>! In the next post, we‚Äôll connect the ProseMirror editor with our parser, and start implementing our feature list.</p>\n<style>\n  div[data-pm-input] {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    margin-bottom: 1.5rem;\n  }\n\n  div[data-pm-input] > div {\n    max-width: 400px;\n    width: stretch;\n    border: 2px solid #ccc;\n    border-radius: 5px;\n    padding: 5px 10px;\n  }\n</style>\n<script id=\"page-script\" type=\"module\">\n\n// node_modules/orderedmap/dist/index.js\nfunction OrderedMap(content) {\n  this.content = content;\n}\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n  find: function(key) {\n    for (var i = 0;i < this.content.length; i += 2)\n      if (this.content[i] === key)\n        return i;\n    return -1;\n  },\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1];\n  },\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey)\n        content[found] = newKey;\n    }\n    return new OrderedMap(content);\n  },\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1)\n      return this;\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content);\n  },\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content));\n  },\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content);\n  },\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content);\n  },\n  forEach: function(f) {\n    for (var i = 0;i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size)\n      return this;\n    return new OrderedMap(map.content.concat(this.subtract(map).content));\n  },\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size)\n      return this;\n    return new OrderedMap(this.subtract(map).content.concat(map.content));\n  },\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0;i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result;\n  },\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) {\n      result[key] = value;\n    });\n    return result;\n  },\n  get size() {\n    return this.content.length >> 1;\n  }\n};\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap)\n    return value;\n  var content = [];\n  if (value)\n    for (var prop in value)\n      content.push(prop, value[prop]);\n  return new OrderedMap(content);\n};\nvar dist_default = OrderedMap;\n\n// node_modules/prosemirror-model/dist/index.js\nfunction findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos;\n    let childA = a.child(i), childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n    if (!childA.sameMarkup(childB))\n      return pos;\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0;childA.text[j] == childB.text[j]; j++)\n        pos++;\n      return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null)\n        return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;; ) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : { a: posA, b: posB };\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n    if (!childA.sameMarkup(childB))\n      return { a: posA, b: posB };\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n      return { a: posA, b: posB };\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner)\n        return inner;\n    }\n    posA -= size;\n    posB -= size;\n  }\n}\n\nclass Fragment {\n  constructor(content, size) {\n    this.content = content;\n    this.size = size || 0;\n    if (size == null)\n      for (let i = 0;i < content.length; i++)\n        this.size += content[i].nodeSize;\n  }\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0;pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize;\n      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n        let start = pos + 1;\n        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n      }\n      pos = end;\n    }\n  }\n  descendants(f) {\n    this.nodesBetween(0, this.size, f);\n  }\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", first = true;\n    this.nodesBetween(from, to, (node, pos) => {\n      let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n        if (first)\n          first = false;\n        else\n          text += blockSeparator;\n      }\n      text += nodeText;\n    }, 0);\n    return text;\n  }\n  append(other) {\n    if (!other.size)\n      return this;\n    if (!this.size)\n      return other;\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text);\n      i = 1;\n    }\n    for (;i < other.content.length; i++)\n      content.push(other.content[i]);\n    return new Fragment(content, this.size + other.size);\n  }\n  cut(from, to = this.size) {\n    if (from == 0 && to == this.size)\n      return this;\n    let result = [], size = 0;\n    if (to > from)\n      for (let i = 0, pos = 0;pos < to; i++) {\n        let child = this.content[i], end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText)\n              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n            else\n              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n    return new Fragment(result, size);\n  }\n  cutByIndex(from, to) {\n    if (from == to)\n      return Fragment.empty;\n    if (from == 0 && to == this.content.length)\n      return this;\n    return new Fragment(this.content.slice(from, to));\n  }\n  replaceChild(index, node) {\n    let current = this.content[index];\n    if (current == node)\n      return this;\n    let copy = this.content.slice();\n    let size = this.size + node.nodeSize - current.nodeSize;\n    copy[index] = node;\n    return new Fragment(copy, size);\n  }\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n  }\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n  }\n  eq(other) {\n    if (this.content.length != other.content.length)\n      return false;\n    for (let i = 0;i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i]))\n        return false;\n    return true;\n  }\n  get firstChild() {\n    return this.content.length ? this.content[0] : null;\n  }\n  get lastChild() {\n    return this.content.length ? this.content[this.content.length - 1] : null;\n  }\n  get childCount() {\n    return this.content.length;\n  }\n  child(index) {\n    let found = this.content[index];\n    if (!found)\n      throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n    return found;\n  }\n  maybeChild(index) {\n    return this.content[index] || null;\n  }\n  forEach(f) {\n    for (let i = 0, p = 0;i < this.content.length; i++) {\n      let child = this.content[i];\n      f(child, p, i);\n      p += child.nodeSize;\n    }\n  }\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos);\n  }\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos);\n  }\n  findIndex(pos) {\n    if (pos == 0)\n      return retIndex(0, pos);\n    if (pos == this.size)\n      return retIndex(this.content.length, pos);\n    if (pos > this.size || pos < 0)\n      throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize;\n      if (end >= pos) {\n        if (end == pos)\n          return retIndex(i + 1, end);\n        return retIndex(i, curPos);\n      }\n      curPos = end;\n    }\n  }\n  toString() {\n    return \"<\" + this.toStringInner() + \">\";\n  }\n  toStringInner() {\n    return this.content.join(\", \");\n  }\n  toJSON() {\n    return this.content.length ? this.content.map((n) => n.toJSON()) : null;\n  }\n  static fromJSON(schema, value) {\n    if (!value)\n      return Fragment.empty;\n    if (!Array.isArray(value))\n      throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n    return new Fragment(value.map(schema.nodeFromJSON));\n  }\n  static fromArray(array) {\n    if (!array.length)\n      return Fragment.empty;\n    let joined, size = 0;\n    for (let i = 0;i < array.length; i++) {\n      let node = array[i];\n      size += node.nodeSize;\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined)\n          joined = array.slice(0, i);\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n      } else if (joined) {\n        joined.push(node);\n      }\n    }\n    return new Fragment(joined || array, size);\n  }\n  static from(nodes) {\n    if (!nodes)\n      return Fragment.empty;\n    if (nodes instanceof Fragment)\n      return nodes;\n    if (Array.isArray(nodes))\n      return this.fromArray(nodes);\n    if (nodes.attrs)\n      return new Fragment([nodes], nodes.nodeSize);\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n  }\n}\nFragment.empty = new Fragment([], 0);\nvar found = { index: 0, offset: 0 };\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\nfunction compareDeep(a, b) {\n  if (a === b)\n    return true;\n  if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\"))\n    return false;\n  let array = Array.isArray(a);\n  if (Array.isArray(b) != array)\n    return false;\n  if (array) {\n    if (a.length != b.length)\n      return false;\n    for (let i = 0;i < a.length; i++)\n      if (!compareDeep(a[i], b[i]))\n        return false;\n  } else {\n    for (let p in a)\n      if (!(p in b) || !compareDeep(a[p], b[p]))\n        return false;\n    for (let p in b)\n      if (!(p in a))\n        return false;\n  }\n  return true;\n}\n\nclass Mark {\n  constructor(type, attrs) {\n    this.type = type;\n    this.attrs = attrs;\n  }\n  addToSet(set) {\n    let copy, placed = false;\n    for (let i = 0;i < set.length; i++) {\n      let other = set[i];\n      if (this.eq(other))\n        return set;\n      if (this.type.excludes(other.type)) {\n        if (!copy)\n          copy = set.slice(0, i);\n      } else if (other.type.excludes(this.type)) {\n        return set;\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy)\n            copy = set.slice(0, i);\n          copy.push(this);\n          placed = true;\n        }\n        if (copy)\n          copy.push(other);\n      }\n    }\n    if (!copy)\n      copy = set.slice();\n    if (!placed)\n      copy.push(this);\n    return copy;\n  }\n  removeFromSet(set) {\n    for (let i = 0;i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1));\n    return set;\n  }\n  isInSet(set) {\n    for (let i = 0;i < set.length; i++)\n      if (this.eq(set[i]))\n        return true;\n    return false;\n  }\n  eq(other) {\n    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n  }\n  toJSON() {\n    let obj = { type: this.type.name };\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs;\n      break;\n    }\n    return obj;\n  }\n  static fromJSON(schema, json) {\n    if (!json)\n      throw new RangeError(\"Invalid input for Mark.fromJSON\");\n    let type = schema.marks[json.type];\n    if (!type)\n      throw new RangeError(`There is no mark type ${json.type} in this schema`);\n    let mark = type.create(json.attrs);\n    type.checkAttrs(mark.attrs);\n    return mark;\n  }\n  static sameSet(a, b) {\n    if (a == b)\n      return true;\n    if (a.length != b.length)\n      return false;\n    for (let i = 0;i < a.length; i++)\n      if (!a[i].eq(b[i]))\n        return false;\n    return true;\n  }\n  static setFrom(marks) {\n    if (!marks || Array.isArray(marks) && marks.length == 0)\n      return Mark.none;\n    if (marks instanceof Mark)\n      return [marks];\n    let copy = marks.slice();\n    copy.sort((a, b) => a.type.rank - b.type.rank);\n    return copy;\n  }\n}\nMark.none = [];\n\nclass ReplaceError extends Error {\n}\n\nclass Slice {\n  constructor(content, openStart, openEnd) {\n    this.content = content;\n    this.openStart = openStart;\n    this.openEnd = openEnd;\n  }\n  get size() {\n    return this.content.size - this.openStart - this.openEnd;\n  }\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment);\n    return content && new Slice(content, this.openStart, this.openEnd);\n  }\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n  }\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n  }\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n  }\n  toJSON() {\n    if (!this.content.size)\n      return null;\n    let json = { content: this.content.toJSON() };\n    if (this.openStart > 0)\n      json.openStart = this.openStart;\n    if (this.openEnd > 0)\n      json.openEnd = this.openEnd;\n    return json;\n  }\n  static fromJSON(schema, json) {\n    if (!json)\n      return Slice.empty;\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\");\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n  }\n  static maxOpen(fragment, openIsolating = true) {\n    let openStart = 0, openEnd = 0;\n    for (let n = fragment.firstChild;n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n      openStart++;\n    for (let n = fragment.lastChild;n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n      openEnd++;\n    return new Slice(fragment, openStart, openEnd);\n  }\n}\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n  let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n  let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText)\n      throw new RangeError(\"Removing non-flat range\");\n    return content.cut(0, from).append(content.cut(to));\n  }\n  if (index != indexTo)\n    throw new RangeError(\"Removing non-flat range\");\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n  let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert))\n      return null;\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert, child);\n  return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    let parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    let { start, end } = prepareSliceForReplace(slice, $from);\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\nfunction addNode(child, target) {\n  let last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text);\n  else\n    target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth);\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (let i = startIndex;i < endIndex; i++)\n    addNode(node.child(i), target);\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n  node.type.checkContent(content);\n  return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  let content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n  let content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  let node = parent.copy(slice.content);\n  for (let i = extra - 1;i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node));\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n}\n\nclass ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    this.pos = pos;\n    this.path = path;\n    this.parentOffset = parentOffset;\n    this.depth = path.length / 3 - 1;\n  }\n  resolveDepth(val) {\n    if (val == null)\n      return this.depth;\n    if (val < 0)\n      return this.depth + val;\n    return val;\n  }\n  get parent() {\n    return this.node(this.depth);\n  }\n  get doc() {\n    return this.node(0);\n  }\n  node(depth) {\n    return this.path[this.resolveDepth(depth) * 3];\n  }\n  index(depth) {\n    return this.path[this.resolveDepth(depth) * 3 + 1];\n  }\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth);\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n  }\n  start(depth) {\n    depth = this.resolveDepth(depth);\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  }\n  end(depth) {\n    depth = this.resolveDepth(depth);\n    return this.start(depth) + this.node(depth).content.size;\n  }\n  before(depth) {\n    depth = this.resolveDepth(depth);\n    if (!depth)\n      throw new RangeError(\"There is no position before the top-level node\");\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n  }\n  after(depth) {\n    depth = this.resolveDepth(depth);\n    if (!depth)\n      throw new RangeError(\"There is no position after the top-level node\");\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n  }\n  get textOffset() {\n    return this.pos - this.path[this.path.length - 1];\n  }\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth);\n    if (index == parent.childCount)\n      return null;\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n    return dOff ? parent.child(index).cut(dOff) : child;\n  }\n  get nodeBefore() {\n    let index = this.index(this.depth);\n    let dOff = this.pos - this.path[this.path.length - 1];\n    if (dOff)\n      return this.parent.child(index).cut(0, dOff);\n    return index == 0 ? null : this.parent.child(index - 1);\n  }\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth);\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    for (let i = 0;i < index; i++)\n      pos += node.child(i).nodeSize;\n    return pos;\n  }\n  marks() {\n    let parent = this.parent, index = this.index();\n    if (parent.content.size == 0)\n      return Mark.none;\n    if (this.textOffset)\n      return parent.child(index).marks;\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n    if (!main) {\n      let tmp = main;\n      main = other;\n      other = tmp;\n    }\n    let marks = main.marks;\n    for (var i = 0;i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks);\n    return marks;\n  }\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index());\n    if (!after || !after.isInline)\n      return null;\n    let marks = after.marks, next = $end.parent.maybeChild($end.index());\n    for (var i = 0;i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks);\n    return marks;\n  }\n  sharedDepth(pos) {\n    for (let depth = this.depth;depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos)\n        return depth;\n    return 0;\n  }\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos)\n      return other.blockRange(this);\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0);d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d);\n    return null;\n  }\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset;\n  }\n  max(other) {\n    return other.pos > this.pos ? other : this;\n  }\n  min(other) {\n    return other.pos < this.pos ? other : this;\n  }\n  toString() {\n    let str = \"\";\n    for (let i = 1;i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n    return str + \":\" + this.parentOffset;\n  }\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size))\n      throw new RangeError(\"Position \" + pos + \" out of range\");\n    let path = [];\n    let start = 0, parentOffset = pos;\n    for (let node = doc;; ) {\n      let { index, offset } = node.content.findIndex(parentOffset);\n      let rem = parentOffset - offset;\n      path.push(node, index, start + offset);\n      if (!rem)\n        break;\n      node = node.child(index);\n      if (node.isText)\n        break;\n      parentOffset = rem - 1;\n      start += offset + 1;\n    }\n    return new ResolvedPos(pos, path, parentOffset);\n  }\n  static resolveCached(doc, pos) {\n    let cache = resolveCache.get(doc);\n    if (cache) {\n      for (let i = 0;i < cache.elts.length; i++) {\n        let elt = cache.elts[i];\n        if (elt.pos == pos)\n          return elt;\n      }\n    } else {\n      resolveCache.set(doc, cache = new ResolveCache);\n    }\n    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n    cache.i = (cache.i + 1) % resolveCacheSize;\n    return result;\n  }\n}\n\nclass ResolveCache {\n  constructor() {\n    this.elts = [];\n    this.i = 0;\n  }\n}\nvar resolveCacheSize = 12;\nvar resolveCache = new WeakMap;\n\nclass NodeRange {\n  constructor($from, $to, depth) {\n    this.$from = $from;\n    this.$to = $to;\n    this.depth = depth;\n  }\n  get start() {\n    return this.$from.before(this.depth + 1);\n  }\n  get end() {\n    return this.$to.after(this.depth + 1);\n  }\n  get parent() {\n    return this.$from.node(this.depth);\n  }\n  get startIndex() {\n    return this.$from.index(this.depth);\n  }\n  get endIndex() {\n    return this.$to.indexAfter(this.depth);\n  }\n}\nvar emptyAttrs = Object.create(null);\n\nclass Node {\n  constructor(type, attrs, content, marks = Mark.none) {\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.content = content || Fragment.empty;\n  }\n  get children() {\n    return this.content.content;\n  }\n  get nodeSize() {\n    return this.isLeaf ? 1 : 2 + this.content.size;\n  }\n  get childCount() {\n    return this.content.childCount;\n  }\n  child(index) {\n    return this.content.child(index);\n  }\n  maybeChild(index) {\n    return this.content.maybeChild(index);\n  }\n  forEach(f) {\n    this.content.forEach(f);\n  }\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this);\n  }\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f);\n  }\n  get textContent() {\n    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n  }\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText);\n  }\n  get firstChild() {\n    return this.content.firstChild;\n  }\n  get lastChild() {\n    return this.content.lastChild;\n  }\n  eq(other) {\n    return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n  }\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks);\n  }\n  hasMarkup(type, attrs, marks) {\n    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n  }\n  copy(content = null) {\n    if (content == this.content)\n      return this;\n    return new Node(this.type, this.attrs, content, this.marks);\n  }\n  mark(marks) {\n    return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n  }\n  cut(from, to = this.content.size) {\n    if (from == 0 && to == this.content.size)\n      return this;\n    return this.copy(this.content.cut(from, to));\n  }\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to)\n      return Slice.empty;\n    let $from = this.resolve(from), $to = this.resolve(to);\n    let depth = includeParents ? 0 : $from.sharedDepth(to);\n    let start = $from.start(depth), node = $from.node(depth);\n    let content = node.content.cut($from.pos - start, $to.pos - start);\n    return new Slice(content, $from.depth - depth, $to.depth - depth);\n  }\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice);\n  }\n  nodeAt(pos) {\n    for (let node = this;; ) {\n      let { index, offset } = node.content.findIndex(pos);\n      node = node.maybeChild(index);\n      if (!node)\n        return null;\n      if (offset == pos || node.isText)\n        return node;\n      pos -= offset + 1;\n    }\n  }\n  childAfter(pos) {\n    let { index, offset } = this.content.findIndex(pos);\n    return { node: this.content.maybeChild(index), index, offset };\n  }\n  childBefore(pos) {\n    if (pos == 0)\n      return { node: null, index: 0, offset: 0 };\n    let { index, offset } = this.content.findIndex(pos);\n    if (offset < pos)\n      return { node: this.content.child(index), index, offset };\n    let node = this.content.child(index - 1);\n    return { node, index: index - 1, offset: offset - node.nodeSize };\n  }\n  resolve(pos) {\n    return ResolvedPos.resolveCached(this, pos);\n  }\n  resolveNoCache(pos) {\n    return ResolvedPos.resolve(this, pos);\n  }\n  rangeHasMark(from, to, type) {\n    let found2 = false;\n    if (to > from)\n      this.nodesBetween(from, to, (node) => {\n        if (type.isInSet(node.marks))\n          found2 = true;\n        return !found2;\n      });\n    return found2;\n  }\n  get isBlock() {\n    return this.type.isBlock;\n  }\n  get isTextblock() {\n    return this.type.isTextblock;\n  }\n  get inlineContent() {\n    return this.type.inlineContent;\n  }\n  get isInline() {\n    return this.type.isInline;\n  }\n  get isText() {\n    return this.type.isText;\n  }\n  get isLeaf() {\n    return this.type.isLeaf;\n  }\n  get isAtom() {\n    return this.type.isAtom;\n  }\n  toString() {\n    if (this.type.spec.toDebugString)\n      return this.type.spec.toDebugString(this);\n    let name = this.type.name;\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\";\n    return wrapMarks(this.marks, name);\n  }\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n    if (!match)\n      throw new Error(\"Called contentMatchAt on a node with invalid content\");\n    return match;\n  }\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n    let two = one && one.matchFragment(this.content, to);\n    if (!two || !two.validEnd)\n      return false;\n    for (let i = start;i < end; i++)\n      if (!this.type.allowsMarks(replacement.child(i).marks))\n        return false;\n    return true;\n  }\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks))\n      return false;\n    let start = this.contentMatchAt(from).matchType(type);\n    let end = start && start.matchFragment(this.content, to);\n    return end ? end.validEnd : false;\n  }\n  canAppend(other) {\n    if (other.content.size)\n      return this.canReplace(this.childCount, this.childCount, other.content);\n    else\n      return this.type.compatibleContent(other.type);\n  }\n  check() {\n    this.type.checkContent(this.content);\n    this.type.checkAttrs(this.attrs);\n    let copy = Mark.none;\n    for (let i = 0;i < this.marks.length; i++) {\n      let mark = this.marks[i];\n      mark.type.checkAttrs(mark.attrs);\n      copy = mark.addToSet(copy);\n    }\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);\n    this.content.forEach((node) => node.check());\n  }\n  toJSON() {\n    let obj = { type: this.type.name };\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs;\n      break;\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON();\n    if (this.marks.length)\n      obj.marks = this.marks.map((n) => n.toJSON());\n    return obj;\n  }\n  static fromJSON(schema, json) {\n    if (!json)\n      throw new RangeError(\"Invalid input for Node.fromJSON\");\n    let marks = undefined;\n    if (json.marks) {\n      if (!Array.isArray(json.marks))\n        throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n      marks = json.marks.map(schema.markFromJSON);\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\")\n        throw new RangeError(\"Invalid text node in JSON\");\n      return schema.text(json.text, marks);\n    }\n    let content = Fragment.fromJSON(schema, json.content);\n    let node = schema.nodeType(json.type).create(json.attrs, content, marks);\n    node.type.checkAttrs(node.attrs);\n    return node;\n  }\n}\nNode.prototype.text = undefined;\n\nclass TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks);\n    if (!content)\n      throw new RangeError(\"Empty text nodes are not allowed\");\n    this.text = content;\n  }\n  toString() {\n    if (this.type.spec.toDebugString)\n      return this.type.spec.toDebugString(this);\n    return wrapMarks(this.marks, JSON.stringify(this.text));\n  }\n  get textContent() {\n    return this.text;\n  }\n  textBetween(from, to) {\n    return this.text.slice(from, to);\n  }\n  get nodeSize() {\n    return this.text.length;\n  }\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n  }\n  withText(text) {\n    if (text == this.text)\n      return this;\n    return new TextNode(this.type, this.attrs, text, this.marks);\n  }\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length)\n      return this;\n    return this.withText(this.text.slice(from, to));\n  }\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text;\n  }\n  toJSON() {\n    let base = super.toJSON();\n    base.text = this.text;\n    return base;\n  }\n}\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1;i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\";\n  return str;\n}\n\nclass ContentMatch {\n  constructor(validEnd) {\n    this.validEnd = validEnd;\n    this.next = [];\n    this.wrapCache = [];\n  }\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes);\n    if (stream.next == null)\n      return ContentMatch.empty;\n    let expr = parseExpr(stream);\n    if (stream.next)\n      stream.err(\"Unexpected trailing text\");\n    let match = dfa(nfa(expr));\n    checkForDeadEnds(match, stream);\n    return match;\n  }\n  matchType(type) {\n    for (let i = 0;i < this.next.length; i++)\n      if (this.next[i].type == type)\n        return this.next[i].next;\n    return null;\n  }\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this;\n    for (let i = start;cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type);\n    return cur;\n  }\n  get inlineContent() {\n    return this.next.length != 0 && this.next[0].type.isInline;\n  }\n  get defaultType() {\n    for (let i = 0;i < this.next.length; i++) {\n      let { type } = this.next[i];\n      if (!(type.isText || type.hasRequiredAttrs()))\n        return type;\n    }\n    return null;\n  }\n  compatible(other) {\n    for (let i = 0;i < this.next.length; i++)\n      for (let j = 0;j < other.next.length; j++)\n        if (this.next[i].type == other.next[j].type)\n          return true;\n    return false;\n  }\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this];\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex);\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map((tp) => tp.createAndFill()));\n      for (let i = 0;i < match.next.length; i++) {\n        let { type, next } = match.next[i];\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next);\n          let found2 = search(next, types.concat(type));\n          if (found2)\n            return found2;\n        }\n      }\n      return null;\n    }\n    return search(this, []);\n  }\n  findWrapping(target) {\n    for (let i = 0;i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target)\n        return this.wrapCache[i + 1];\n    let computed = this.computeWrapping(target);\n    this.wrapCache.push(target, computed);\n    return computed;\n  }\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{ match: this, type: null, via: null }];\n    while (active.length) {\n      let current = active.shift(), match = current.match;\n      if (match.matchType(target)) {\n        let result = [];\n        for (let obj = current;obj.type; obj = obj.via)\n          result.push(obj.type);\n        return result.reverse();\n      }\n      for (let i = 0;i < match.next.length; i++) {\n        let { type, next } = match.next[i];\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n          active.push({ match: type.contentMatch, type, via: current });\n          seen[type.name] = true;\n        }\n      }\n    }\n    return null;\n  }\n  get edgeCount() {\n    return this.next.length;\n  }\n  edge(n) {\n    if (n >= this.next.length)\n      throw new RangeError(`There's no ${n}th edge in this content match`);\n    return this.next[n];\n  }\n  toString() {\n    let seen = [];\n    function scan(m) {\n      seen.push(m);\n      for (let i = 0;i < m.next.length; i++)\n        if (seen.indexOf(m.next[i].next) == -1)\n          scan(m.next[i].next);\n    }\n    scan(this);\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n      for (let i2 = 0;i2 < m.next.length; i2++)\n        out += (i2 ? \", \" : \"\") + m.next[i2].type.name + \"->\" + seen.indexOf(m.next[i2].next);\n      return out;\n    }).join(`\n`);\n  }\n}\nContentMatch.empty = new ContentMatch(true);\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string;\n    this.nodeTypes = nodeTypes;\n    this.inline = null;\n    this.pos = 0;\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n    if (this.tokens[this.tokens.length - 1] == \"\")\n      this.tokens.pop();\n    if (this.tokens[0] == \"\")\n      this.tokens.shift();\n  }\n  get next() {\n    return this.tokens[this.pos];\n  }\n  eat(tok) {\n    return this.next == tok && (this.pos++ || true);\n  }\n  err(str) {\n    throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n  }\n}\nfunction parseExpr(stream) {\n  let exprs = [];\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n  return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n}\nfunction parseExprSeq(stream) {\n  let exprs = [];\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n  return exprs.length == 1 ? exprs[0] : { type: \"seq\", exprs };\n}\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream);\n  for (;; ) {\n    if (stream.eat(\"+\"))\n      expr = { type: \"plus\", expr };\n    else if (stream.eat(\"*\"))\n      expr = { type: \"star\", expr };\n    else if (stream.eat(\"?\"))\n      expr = { type: \"opt\", expr };\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr);\n    else\n      break;\n  }\n  return expr;\n}\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next))\n    stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  let result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\")\n      max = parseNum(stream);\n    else\n      max = -1;\n  }\n  if (!stream.eat(\"}\"))\n    stream.err(\"Unclosed braced range\");\n  return { type: \"range\", min, max, expr };\n}\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name];\n  if (type)\n    return [type];\n  let result = [];\n  for (let typeName in types) {\n    let type2 = types[typeName];\n    if (type2.isInGroup(name))\n      result.push(type2);\n  }\n  if (result.length == 0)\n    stream.err(\"No node type or group '\" + name + \"' found\");\n  return result;\n}\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream);\n    if (!stream.eat(\")\"))\n      stream.err(\"Missing closing paren\");\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map((type) => {\n      if (stream.inline == null)\n        stream.inline = type.isInline;\n      else if (stream.inline != type.isInline)\n        stream.err(\"Mixing inline and block content\");\n      return { type: \"name\", value: type };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\nfunction nfa(expr) {\n  let nfa2 = [[]];\n  connect(compile(expr, 0), node());\n  return nfa2;\n  function node() {\n    return nfa2.push([]) - 1;\n  }\n  function edge(from, to, term) {\n    let edge2 = { term, to };\n    nfa2[from].push(edge2);\n    return edge2;\n  }\n  function connect(edges, to) {\n    edges.forEach((edge2) => edge2.to = to);\n  }\n  function compile(expr2, from) {\n    if (expr2.type == \"choice\") {\n      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);\n    } else if (expr2.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr2.exprs[i], from);\n        if (i == expr2.exprs.length - 1)\n          return next;\n        connect(next, from = node());\n      }\n    } else if (expr2.type == \"star\") {\n      let loop = node();\n      edge(from, loop);\n      connect(compile(expr2.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr2.type == \"plus\") {\n      let loop = node();\n      connect(compile(expr2.expr, from), loop);\n      connect(compile(expr2.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr2.type == \"opt\") {\n      return [edge(from)].concat(compile(expr2.expr, from));\n    } else if (expr2.type == \"range\") {\n      let cur = from;\n      for (let i = 0;i < expr2.min; i++) {\n        let next = node();\n        connect(compile(expr2.expr, cur), next);\n        cur = next;\n      }\n      if (expr2.max == -1) {\n        connect(compile(expr2.expr, cur), cur);\n      } else {\n        for (let i = expr2.min;i < expr2.max; i++) {\n          let next = node();\n          edge(cur, next);\n          connect(compile(expr2.expr, cur), next);\n          cur = next;\n        }\n      }\n      return [edge(cur)];\n    } else if (expr2.type == \"name\") {\n      return [edge(from, undefined, expr2.value)];\n    } else {\n      throw new Error(\"Unknown expr type\");\n    }\n  }\n}\nfunction cmp(a, b) {\n  return b - a;\n}\nfunction nullFrom(nfa2, node) {\n  let result = [];\n  scan(node);\n  return result.sort(cmp);\n  function scan(node2) {\n    let edges = nfa2[node2];\n    if (edges.length == 1 && !edges[0].term)\n      return scan(edges[0].to);\n    result.push(node2);\n    for (let i = 0;i < edges.length; i++) {\n      let { term, to } = edges[i];\n      if (!term && result.indexOf(to) == -1)\n        scan(to);\n    }\n  }\n}\nfunction dfa(nfa2) {\n  let labeled = Object.create(null);\n  return explore(nullFrom(nfa2, 0));\n  function explore(states) {\n    let out = [];\n    states.forEach((node) => {\n      nfa2[node].forEach(({ term, to }) => {\n        if (!term)\n          return;\n        let set;\n        for (let i = 0;i < out.length; i++)\n          if (out[i][0] == term)\n            set = out[i][1];\n        nullFrom(nfa2, to).forEach((node2) => {\n          if (!set)\n            out.push([term, set = []]);\n          if (set.indexOf(node2) == -1)\n            set.push(node2);\n        });\n      });\n    });\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);\n    for (let i = 0;i < out.length; i++) {\n      let states2 = out[i][1].sort(cmp);\n      state.next.push({ type: out[i][0], next: labeled[states2.join(\",\")] || explore(states2) });\n    }\n    return state;\n  }\n}\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match];i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = [];\n    for (let j = 0;j < state.next.length; j++) {\n      let { type, next } = state.next[j];\n      nodes.push(type.name);\n      if (dead && !(type.isText || type.hasRequiredAttrs()))\n        dead = false;\n      if (work.indexOf(next) == -1)\n        work.push(next);\n    }\n    if (dead)\n      stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n  }\n}\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null);\n  for (let attrName in attrs) {\n    let attr = attrs[attrName];\n    if (!attr.hasDefault)\n      return null;\n    defaults[attrName] = attr.default;\n  }\n  return defaults;\n}\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null);\n  for (let name in attrs) {\n    let given = value && value[name];\n    if (given === undefined) {\n      let attr = attrs[name];\n      if (attr.hasDefault)\n        given = attr.default;\n      else\n        throw new RangeError(\"No value supplied for attribute \" + name);\n    }\n    built[name] = given;\n  }\n  return built;\n}\nfunction checkAttrs(attrs, values, type, name) {\n  for (let name2 in values)\n    if (!(name2 in attrs))\n      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);\n  for (let name2 in attrs) {\n    let attr = attrs[name2];\n    if (attr.validate)\n      attr.validate(values[name2]);\n  }\n}\nfunction initAttrs(typeName, attrs) {\n  let result = Object.create(null);\n  if (attrs)\n    for (let name in attrs)\n      result[name] = new Attribute(typeName, name, attrs[name]);\n  return result;\n}\n\nclass NodeType {\n  constructor(name, schema, spec) {\n    this.name = name;\n    this.schema = schema;\n    this.spec = spec;\n    this.markSet = null;\n    this.groups = spec.group ? spec.group.split(\" \") : [];\n    this.attrs = initAttrs(name, spec.attrs);\n    this.defaultAttrs = defaultAttrs(this.attrs);\n    this.contentMatch = null;\n    this.inlineContent = null;\n    this.isBlock = !(spec.inline || name == \"text\");\n    this.isText = name == \"text\";\n  }\n  get isInline() {\n    return !this.isBlock;\n  }\n  get isTextblock() {\n    return this.isBlock && this.inlineContent;\n  }\n  get isLeaf() {\n    return this.contentMatch == ContentMatch.empty;\n  }\n  get isAtom() {\n    return this.isLeaf || !!this.spec.atom;\n  }\n  isInGroup(group) {\n    return this.groups.indexOf(group) > -1;\n  }\n  get whitespace() {\n    return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n  }\n  hasRequiredAttrs() {\n    for (let n in this.attrs)\n      if (this.attrs[n].isRequired)\n        return true;\n    return false;\n  }\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch);\n  }\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs)\n      return this.defaultAttrs;\n    else\n      return computeAttrs(this.attrs, attrs);\n  }\n  create(attrs = null, content, marks) {\n    if (this.isText)\n      throw new Error(\"NodeType.create can't construct text nodes\");\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n  }\n  createChecked(attrs = null, content, marks) {\n    content = Fragment.from(content);\n    this.checkContent(content);\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n  }\n  createAndFill(attrs = null, content, marks) {\n    attrs = this.computeAttrs(attrs);\n    content = Fragment.from(content);\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content);\n      if (!before)\n        return null;\n      content = before.append(content);\n    }\n    let matched = this.contentMatch.matchFragment(content);\n    let after = matched && matched.fillBefore(Fragment.empty, true);\n    if (!after)\n      return null;\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n  }\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content);\n    if (!result || !result.validEnd)\n      return false;\n    for (let i = 0;i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks))\n        return false;\n    return true;\n  }\n  checkContent(content) {\n    if (!this.validContent(content))\n      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n  }\n  checkAttrs(attrs) {\n    checkAttrs(this.attrs, attrs, \"node\", this.name);\n  }\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1;\n  }\n  allowsMarks(marks) {\n    if (this.markSet == null)\n      return true;\n    for (let i = 0;i < marks.length; i++)\n      if (!this.allowsMarkType(marks[i].type))\n        return false;\n    return true;\n  }\n  allowedMarks(marks) {\n    if (this.markSet == null)\n      return marks;\n    let copy;\n    for (let i = 0;i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy)\n          copy = marks.slice(0, i);\n      } else if (copy) {\n        copy.push(marks[i]);\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.none;\n  }\n  static compile(nodes, schema) {\n    let result = Object.create(null);\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));\n    let topType = schema.spec.topNode || \"doc\";\n    if (!result[topType])\n      throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n    if (!result.text)\n      throw new RangeError(\"Every schema needs a 'text' type\");\n    for (let _ in result.text.attrs)\n      throw new RangeError(\"The text node type should not have attributes\");\n    return result;\n  }\n}\nfunction validateType(typeName, attrName, type) {\n  let types = type.split(\"|\");\n  return (value) => {\n    let name = value === null ? \"null\" : typeof value;\n    if (types.indexOf(name) < 0)\n      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);\n  };\n}\n\nclass Attribute {\n  constructor(typeName, attrName, options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n    this.default = options.default;\n    this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n  }\n  get isRequired() {\n    return !this.hasDefault;\n  }\n}\n\nclass MarkType {\n  constructor(name, rank, schema, spec) {\n    this.name = name;\n    this.rank = rank;\n    this.schema = schema;\n    this.spec = spec;\n    this.attrs = initAttrs(name, spec.attrs);\n    this.excluded = null;\n    let defaults = defaultAttrs(this.attrs);\n    this.instance = defaults ? new Mark(this, defaults) : null;\n  }\n  create(attrs = null) {\n    if (!attrs && this.instance)\n      return this.instance;\n    return new Mark(this, computeAttrs(this.attrs, attrs));\n  }\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0;\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));\n    return result;\n  }\n  removeFromSet(set) {\n    for (var i = 0;i < set.length; i++)\n      if (set[i].type == this) {\n        set = set.slice(0, i).concat(set.slice(i + 1));\n        i--;\n      }\n    return set;\n  }\n  isInSet(set) {\n    for (let i = 0;i < set.length; i++)\n      if (set[i].type == this)\n        return set[i];\n  }\n  checkAttrs(attrs) {\n    checkAttrs(this.attrs, attrs, \"mark\", this.name);\n  }\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1;\n  }\n}\n\nclass Schema {\n  constructor(spec) {\n    this.linebreakReplacement = null;\n    this.cached = Object.create(null);\n    let instanceSpec = this.spec = {};\n    for (let prop in spec)\n      instanceSpec[prop] = spec[prop];\n    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n    this.marks = MarkType.compile(this.spec.marks, this);\n    let contentExprCache = Object.create(null);\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\");\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n      type.inlineContent = type.contentMatch.inlineContent;\n      if (type.spec.linebreakReplacement) {\n        if (this.linebreakReplacement)\n          throw new RangeError(\"Multiple linebreak nodes defined\");\n        if (!type.isInline || !type.isLeaf)\n          throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n        this.linebreakReplacement = type;\n      }\n      type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes;\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n    }\n    this.nodeFromJSON = (json) => Node.fromJSON(this, json);\n    this.markFromJSON = (json) => Mark.fromJSON(this, json);\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n    this.cached.wrappings = Object.create(null);\n  }\n  node(type, attrs = null, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type);\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type);\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n    return type.createChecked(attrs, content, marks);\n  }\n  text(text, marks) {\n    let type = this.nodes.text;\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n  }\n  mark(type, attrs) {\n    if (typeof type == \"string\")\n      type = this.marks[type];\n    return type.create(attrs);\n  }\n  nodeType(name) {\n    let found2 = this.nodes[name];\n    if (!found2)\n      throw new RangeError(\"Unknown node type: \" + name);\n    return found2;\n  }\n}\nfunction gatherMarks(schema, marks) {\n  let found2 = [];\n  for (let i = 0;i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found2.push(mark);\n    } else {\n      for (let prop in schema.marks) {\n        let mark2 = schema.marks[prop];\n        if (name == \"_\" || mark2.spec.group && mark2.spec.group.split(\" \").indexOf(name) > -1)\n          found2.push(ok = mark2);\n      }\n    }\n    if (!ok)\n      throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n  return found2;\n}\nfunction isTagRule(rule) {\n  return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n  return rule.style != null;\n}\n\nclass DOMParser {\n  constructor(schema, rules) {\n    this.schema = schema;\n    this.rules = rules;\n    this.tags = [];\n    this.styles = [];\n    let matchedStyles = this.matchedStyles = [];\n    rules.forEach((rule) => {\n      if (isTagRule(rule)) {\n        this.tags.push(rule);\n      } else if (isStyleRule(rule)) {\n        let prop = /[^=]*/.exec(rule.style)[0];\n        if (matchedStyles.indexOf(prop) < 0)\n          matchedStyles.push(prop);\n        this.styles.push(rule);\n      }\n    });\n    this.normalizeLists = !this.tags.some((r) => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n        return false;\n      let node = schema.nodes[r.node];\n      return node.contentMatch.matchType(node);\n    });\n  }\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false);\n    context.addAll(dom, Mark.none, options.from, options.to);\n    return context.finish();\n  }\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true);\n    context.addAll(dom, Mark.none, options.from, options.to);\n    return Slice.maxOpen(context.finish());\n  }\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0;i < this.tags.length; i++) {\n      let rule = this.tags[i];\n      if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom);\n          if (result === false)\n            continue;\n          rule.attrs = result || undefined;\n        }\n        return rule;\n      }\n    }\n  }\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0;i < this.styles.length; i++) {\n      let rule = this.styles[i], style = rule.style;\n      if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n        continue;\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value);\n        if (result === false)\n          continue;\n        rule.attrs = result || undefined;\n      }\n      return rule;\n    }\n  }\n  static schemaRules(schema) {\n    let result = [];\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n      for (;i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n        if (nextPriority < priority)\n          break;\n      }\n      result.splice(i, 0, rule);\n    }\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM;\n      if (rules)\n        rules.forEach((rule) => {\n          insert(rule = copy(rule));\n          if (!(rule.mark || rule.ignore || rule.clearMark))\n            rule.mark = name;\n        });\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM;\n      if (rules)\n        rules.forEach((rule) => {\n          insert(rule = copy(rule));\n          if (!(rule.node || rule.ignore || rule.mark))\n            rule.node = name;\n        });\n    }\n    return result;\n  }\n  static fromSchema(schema) {\n    return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n  }\n}\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n};\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n};\nvar listTags = { ol: true, ul: true };\nvar OPT_PRESERVE_WS = 1;\nvar OPT_PRESERVE_WS_FULL = 2;\nvar OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null)\n    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, solid, match, options) {\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.solid = solid;\n    this.options = options;\n    this.content = [];\n    this.activeMarks = Mark.none;\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  }\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type)\n        return [];\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill);\n      } else {\n        let start = this.type.contentMatch, wrap;\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start;\n          return wrap;\n        } else {\n          return null;\n        }\n      }\n    }\n    return this.match.findWrapping(node.type);\n  }\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) {\n      let last = this.content[this.content.length - 1], m;\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        let text = last;\n        if (last.text.length == m[0].length)\n          this.content.pop();\n        else\n          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n      }\n    }\n    let content = Fragment.from(this.content);\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true));\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n  }\n  inlineContext(node) {\n    if (this.type)\n      return this.type.inlineContent;\n    if (this.content.length)\n      return this.content[0].isInline;\n    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n  }\n}\n\nclass ParseContext {\n  constructor(parser, options, isOpen) {\n    this.parser = parser;\n    this.options = options;\n    this.isOpen = isOpen;\n    this.open = 0;\n    this.localPreserveWS = false;\n    let topNode = options.topNode, topContext;\n    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n    else if (isOpen)\n      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n    this.nodes = [topContext];\n    this.find = options.findPositions;\n    this.needsBlock = false;\n  }\n  get top() {\n    return this.nodes[this.open];\n  }\n  addDOM(dom, marks) {\n    if (dom.nodeType == 3)\n      this.addTextNode(dom, marks);\n    else if (dom.nodeType == 1)\n      this.addElement(dom, marks);\n  }\n  addTextNode(dom, marks) {\n    let value = dom.nodeValue;\n    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n    let { schema } = this.parser;\n    if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!preserveWS) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1];\n          let domNodeBefore = dom.previousSibling;\n          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text))\n            value = value.slice(1);\n        }\n      } else if (preserveWS === \"full\") {\n        value = value.replace(/\\r\\n?/g, `\n`);\n      } else if (schema.linebreakReplacement && /[\\r\\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {\n        let lines = value.split(/\\r?\\n|\\r/);\n        for (let i = 0;i < lines.length; i++) {\n          if (i)\n            this.insertNode(schema.linebreakReplacement.create(), marks, true);\n          if (lines[i])\n            this.insertNode(schema.text(lines[i]), marks, !/\\S/.test(lines[i]));\n        }\n        value = \"\";\n      } else {\n        value = value.replace(/\\r?\\n|\\r/g, \" \");\n      }\n      if (value)\n        this.insertNode(schema.text(value), marks, !/\\S/.test(value));\n      this.findInText(dom);\n    } else {\n      this.findInside(dom);\n    }\n  }\n  addElement(dom, marks, matchAfter) {\n    let outerWS = this.localPreserveWS, top = this.top;\n    if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace))\n      this.localPreserveWS = true;\n    let name = dom.nodeName.toLowerCase(), ruleID;\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n      normalizeList(dom);\n    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n    out:\n      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom, marks);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent)\n          this.open = Math.max(0, this.open - 1);\n        else if (rule && rule.skip.nodeType)\n          dom = rule.skip;\n        let sync, oldNeedsBlock = this.needsBlock;\n        if (blockTags.hasOwnProperty(name)) {\n          if (top.content.length && top.content[0].isInline && this.open) {\n            this.open--;\n            top = this.top;\n          }\n          sync = true;\n          if (!top.type)\n            this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom, marks);\n          break out;\n        }\n        let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n        if (innerMarks)\n          this.addAll(dom, innerMarks);\n        if (sync)\n          this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        let innerMarks = this.readStyles(dom, marks);\n        if (innerMarks)\n          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : undefined);\n      }\n    this.localPreserveWS = outerWS;\n  }\n  leafFallback(dom, marks) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(`\n`), marks);\n  }\n  ignoreFallback(dom, marks) {\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"), marks, true);\n  }\n  readStyles(dom, marks) {\n    let styles = dom.style;\n    if (styles && styles.length)\n      for (let i = 0;i < this.parser.matchedStyles.length; i++) {\n        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);\n        if (value)\n          for (let after = undefined;; ) {\n            let rule = this.parser.matchStyle(name, value, this, after);\n            if (!rule)\n              break;\n            if (rule.ignore)\n              return null;\n            if (rule.clearMark)\n              marks = marks.filter((m) => !rule.clearMark(m));\n            else\n              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));\n            if (rule.consuming === false)\n              after = rule;\n            else\n              break;\n          }\n      }\n    return marks;\n  }\n  addElementByRule(dom, rule, marks, continueAfter) {\n    let sync, nodeType;\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node];\n      if (!nodeType.isLeaf) {\n        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n        if (inner) {\n          sync = true;\n          marks = inner;\n        }\n      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == \"BR\")) {\n        this.leafFallback(dom, marks);\n      }\n    } else {\n      let markType = this.parser.schema.marks[rule.mark];\n      marks = marks.concat(markType.create(rule.attrs));\n    }\n    let startIn = this.top;\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom);\n    } else if (continueAfter) {\n      this.addElement(dom, marks, continueAfter);\n    } else if (rule.getContent) {\n      this.findInside(dom);\n      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));\n    } else {\n      let contentDOM = dom;\n      if (typeof rule.contentElement == \"string\")\n        contentDOM = dom.querySelector(rule.contentElement);\n      else if (typeof rule.contentElement == \"function\")\n        contentDOM = rule.contentElement(dom);\n      else if (rule.contentElement)\n        contentDOM = rule.contentElement;\n      this.findAround(dom, contentDOM, true);\n      this.addAll(contentDOM, marks);\n      this.findAround(dom, contentDOM, false);\n    }\n    if (sync && this.sync(startIn))\n      this.open--;\n  }\n  addAll(parent, marks, startIndex, endIndex) {\n    let index = startIndex || 0;\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex];dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index);\n      this.addDOM(dom, marks);\n    }\n    this.findAtPoint(parent, index);\n  }\n  findPlace(node, marks, cautious) {\n    let route, sync;\n    for (let depth = this.open, penalty = 0;depth >= 0; depth--) {\n      let cx = this.nodes[depth];\n      let found2 = cx.findWrapping(node);\n      if (found2 && (!route || route.length > found2.length + penalty)) {\n        route = found2;\n        sync = cx;\n        if (!found2.length)\n          break;\n      }\n      if (cx.solid) {\n        if (cautious)\n          break;\n        penalty += 2;\n      }\n    }\n    if (!route)\n      return null;\n    this.sync(sync);\n    for (let i = 0;i < route.length; i++)\n      marks = this.enterInner(route[i], null, marks, false);\n    return marks;\n  }\n  insertNode(node, marks, cautious) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext();\n      if (block)\n        marks = this.enterInner(block, null, marks);\n    }\n    let innerMarks = this.findPlace(node, marks, cautious);\n    if (innerMarks) {\n      this.closeExtra();\n      let top = this.top;\n      if (top.match)\n        top.match = top.match.matchType(node.type);\n      let nodeMarks = Mark.none;\n      for (let m of innerMarks.concat(node.marks))\n        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))\n          nodeMarks = m.addToSet(nodeMarks);\n      top.content.push(node.mark(nodeMarks));\n      return true;\n    }\n    return false;\n  }\n  enter(type, attrs, marks, preserveWS) {\n    let innerMarks = this.findPlace(type.create(attrs), marks, false);\n    if (innerMarks)\n      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n    return innerMarks;\n  }\n  enterInner(type, attrs, marks, solid = false, preserveWS) {\n    this.closeExtra();\n    let top = this.top;\n    top.match = top.match && top.match.matchType(type);\n    let options = wsOptionsFor(type, preserveWS, top.options);\n    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)\n      options |= OPT_OPEN_LEFT;\n    let applyMarks = Mark.none;\n    marks = marks.filter((m) => {\n      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n        applyMarks = m.addToSet(applyMarks);\n        return false;\n      }\n      return true;\n    });\n    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n    this.open++;\n    return marks;\n  }\n  closeExtra(openEnd = false) {\n    let i = this.nodes.length - 1;\n    if (i > this.open) {\n      for (;i > this.open; i--)\n        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n      this.nodes.length = this.open + 1;\n    }\n  }\n  finish() {\n    this.open = 0;\n    this.closeExtra(this.isOpen);\n    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n  }\n  sync(to) {\n    for (let i = this.open;i >= 0; i--) {\n      if (this.nodes[i] == to) {\n        this.open = i;\n        return true;\n      } else if (this.localPreserveWS) {\n        this.nodes[i].options |= OPT_PRESERVE_WS;\n      }\n    }\n    return false;\n  }\n  get currentPos() {\n    this.closeExtra();\n    let pos = 0;\n    for (let i = this.open;i >= 0; i--) {\n      let content = this.nodes[i].content;\n      for (let j = content.length - 1;j >= 0; j--)\n        pos += content[j].nodeSize;\n      if (i)\n        pos++;\n    }\n    return pos;\n  }\n  findAtPoint(parent, offset) {\n    if (this.find)\n      for (let i = 0;i < this.find.length; i++) {\n        if (this.find[i].node == parent && this.find[i].offset == offset)\n          this.find[i].pos = this.currentPos;\n      }\n  }\n  findInside(parent) {\n    if (this.find)\n      for (let i = 0;i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n          this.find[i].pos = this.currentPos;\n      }\n  }\n  findAround(parent, content, before) {\n    if (parent != content && this.find)\n      for (let i = 0;i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n          let pos = content.compareDocumentPosition(this.find[i].node);\n          if (pos & (before ? 2 : 4))\n            this.find[i].pos = this.currentPos;\n        }\n      }\n  }\n  findInText(textNode) {\n    if (this.find)\n      for (let i = 0;i < this.find.length; i++) {\n        if (this.find[i].node == textNode)\n          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n  }\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n    let parts = context.split(\"/\");\n    let option = this.options.context;\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n    let match = (i, depth) => {\n      for (;i >= 0; i--) {\n        let part = parts[i];\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0)\n            continue;\n          for (;depth >= minDepth; depth--)\n            if (match(i - 1, depth))\n              return true;\n          return false;\n        } else {\n          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n          if (!next || next.name != part && !next.isInGroup(part))\n            return false;\n          depth--;\n        }\n      }\n      return true;\n    };\n    return match(parts.length - 1, this.open);\n  }\n  textblockFromContext() {\n    let $context = this.options.context;\n    if ($context)\n      for (let d = $context.depth;d >= 0; d--) {\n        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n        if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n          return deflt;\n      }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name];\n      if (type.isTextblock && type.defaultAttrs)\n        return type;\n    }\n  }\n}\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null;child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n  let copy2 = {};\n  for (let prop in obj)\n    copy2[prop] = obj[prop];\n  return copy2;\n}\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes;\n  for (let name in nodes) {\n    let parent = nodes[name];\n    if (!parent.allowsMarkType(markType))\n      continue;\n    let seen = [], scan = (match) => {\n      seen.push(match);\n      for (let i = 0;i < match.edgeCount; i++) {\n        let { type, next } = match.edge(i);\n        if (type == nodeType)\n          return true;\n        if (seen.indexOf(next) < 0 && scan(next))\n          return true;\n      }\n    };\n    if (scan(parent.contentMatch))\n      return true;\n  }\n}\n\nclass DOMSerializer {\n  constructor(nodes, marks) {\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n  serializeFragment(fragment, options = {}, target) {\n    if (!target)\n      target = doc(options).createDocumentFragment();\n    let top = target, active = [];\n    fragment.forEach((node) => {\n      if (active.length || node.marks.length) {\n        let keep = 0, rendered = 0;\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered];\n          if (!this.marks[next.type.name]) {\n            rendered++;\n            continue;\n          }\n          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n            break;\n          keep++;\n          rendered++;\n        }\n        while (keep < active.length)\n          top = active.pop()[1];\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++];\n          let markDOM = this.serializeMark(add, node.isInline, options);\n          if (markDOM) {\n            active.push([add, top]);\n            top.appendChild(markDOM.dom);\n            top = markDOM.contentDOM || markDOM.dom;\n          }\n        }\n      }\n      top.appendChild(this.serializeNodeInner(node, options));\n    });\n    return target;\n  }\n  serializeNodeInner(node, options) {\n    let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n      this.serializeFragment(node.content, options, contentDOM);\n    }\n    return dom;\n  }\n  serializeNode(node, options = {}) {\n    let dom = this.serializeNodeInner(node, options);\n    for (let i = node.marks.length - 1;i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n      if (wrap) {\n        (wrap.contentDOM || wrap.dom).appendChild(dom);\n        dom = wrap.dom;\n      }\n    }\n    return dom;\n  }\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name];\n    return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n  }\n  static renderSpec(doc, structure, xmlNS = null, blockArraysIn) {\n    return renderSpec(doc, structure, xmlNS, blockArraysIn);\n  }\n  static fromSchema(schema) {\n    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n  }\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes);\n    if (!result.text)\n      result.text = (node) => node.text;\n    return result;\n  }\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks);\n  }\n}\nfunction gatherToDOM(obj) {\n  let result = {};\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM;\n    if (toDOM)\n      result[name] = toDOM;\n  }\n  return result;\n}\nfunction doc(options) {\n  return options.document || window.document;\n}\nvar suspiciousAttributeCache = new WeakMap;\nfunction suspiciousAttributes(attrs) {\n  let value = suspiciousAttributeCache.get(attrs);\n  if (value === undefined)\n    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n  return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n  let result = null;\n  function scan(value) {\n    if (value && typeof value == \"object\") {\n      if (Array.isArray(value)) {\n        if (typeof value[0] == \"string\") {\n          if (!result)\n            result = [];\n          result.push(value);\n        } else {\n          for (let i = 0;i < value.length; i++)\n            scan(value[i]);\n        }\n      } else {\n        for (let prop in value)\n          scan(value[prop]);\n      }\n    }\n  }\n  scan(attrs);\n  return result;\n}\nfunction renderSpec(doc2, structure, xmlNS, blockArraysIn) {\n  if (typeof structure == \"string\")\n    return { dom: doc2.createTextNode(structure) };\n  if (structure.nodeType != null)\n    return { dom: structure };\n  if (structure.dom && structure.dom.nodeType != null)\n    return structure;\n  let tagName = structure[0], suspicious;\n  if (typeof tagName != \"string\")\n    throw new RangeError(\"Invalid array passed to renderSpec\");\n  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)\n    throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n  let space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  let contentDOM;\n  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);\n  let attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (let name in attrs)\n      if (attrs[name] != null) {\n        let space2 = name.indexOf(\" \");\n        if (space2 > 0)\n          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);\n        else if (name == \"style\" && dom.style)\n          dom.style.cssText = attrs[name];\n        else\n          dom.setAttribute(name, attrs[name]);\n      }\n  }\n  for (let i = start;i < structure.length; i++) {\n    let child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        throw new RangeError(\"Content hole must be the only child of its parent node\");\n      return { dom, contentDOM: dom };\n    } else {\n      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM)\n          throw new RangeError(\"Multiple content holes\");\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return { dom, contentDOM };\n}\n\n// node_modules/prosemirror-transform/dist/index.js\nvar lower16 = 65535;\nvar factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n  return value & lower16;\n}\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\nvar DEL_BEFORE = 1;\nvar DEL_AFTER = 2;\nvar DEL_ACROSS = 4;\nvar DEL_SIDE = 8;\n\nclass MapResult {\n  constructor(pos, delInfo, recover) {\n    this.pos = pos;\n    this.delInfo = delInfo;\n    this.recover = recover;\n  }\n  get deleted() {\n    return (this.delInfo & DEL_SIDE) > 0;\n  }\n  get deletedBefore() {\n    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n  }\n  get deletedAfter() {\n    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n  }\n  get deletedAcross() {\n    return (this.delInfo & DEL_ACROSS) > 0;\n  }\n}\n\nclass StepMap {\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges;\n    this.inverted = inverted;\n    if (!ranges.length && StepMap.empty)\n      return StepMap.empty;\n  }\n  recover(value) {\n    let diff = 0, index = recoverIndex(value);\n    if (!this.inverted)\n      for (let i = 0;i < index; i++)\n        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n    return this.ranges[index * 3] + diff + recoverOffset(value);\n  }\n  mapResult(pos, assoc = 1) {\n    return this._map(pos, assoc, false);\n  }\n  map(pos, assoc = 1) {\n    return this._map(pos, assoc, true);\n  }\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n    for (let i = 0;i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0);\n      if (start > pos)\n        break;\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n        let result = start + diff + (side < 0 ? 0 : newSize);\n        if (simple)\n          return result;\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n        if (assoc < 0 ? pos != start : pos != end)\n          del |= DEL_SIDE;\n        return new MapResult(result, del, recover);\n      }\n      diff += newSize - oldSize;\n    }\n    return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n  }\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover);\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n    for (let i = 0;i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0);\n      if (start > pos)\n        break;\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n      if (pos <= end && i == index * 3)\n        return true;\n      diff += this.ranges[i + newIndex] - oldSize;\n    }\n    return false;\n  }\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n    for (let i = 0, diff = 0;i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n      diff += newSize - oldSize;\n    }\n  }\n  invert() {\n    return new StepMap(this.ranges, !this.inverted);\n  }\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n  }\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n  }\n}\nStepMap.empty = new StepMap([]);\n\nclass Mapping {\n  constructor(maps, mirror, from = 0, to = maps ? maps.length : 0) {\n    this.mirror = mirror;\n    this.from = from;\n    this.to = to;\n    this._maps = maps || [];\n    this.ownData = !(maps || mirror);\n  }\n  get maps() {\n    return this._maps;\n  }\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this._maps, this.mirror, from, to);\n  }\n  appendMap(map, mirrors) {\n    if (!this.ownData) {\n      this._maps = this._maps.slice();\n      this.mirror = this.mirror && this.mirror.slice();\n      this.ownData = true;\n    }\n    this.to = this._maps.push(map);\n    if (mirrors != null)\n      this.setMirror(this._maps.length - 1, mirrors);\n  }\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this._maps.length;i < mapping._maps.length; i++) {\n      let mirr = mapping.getMirror(i);\n      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n    }\n  }\n  getMirror(n) {\n    if (this.mirror) {\n      for (let i = 0;i < this.mirror.length; i++)\n        if (this.mirror[i] == n)\n          return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n  }\n  setMirror(n, m) {\n    if (!this.mirror)\n      this.mirror = [];\n    this.mirror.push(n, m);\n  }\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length;i >= 0; i--) {\n      let mirr = mapping.getMirror(i);\n      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n    }\n  }\n  invert() {\n    let inverse = new Mapping;\n    inverse.appendMappingInverted(this);\n    return inverse;\n  }\n  map(pos, assoc = 1) {\n    if (this.mirror)\n      return this._map(pos, assoc, true);\n    for (let i = this.from;i < this.to; i++)\n      pos = this._maps[i].map(pos, assoc);\n    return pos;\n  }\n  mapResult(pos, assoc = 1) {\n    return this._map(pos, assoc, false);\n  }\n  _map(pos, assoc, simple) {\n    let delInfo = 0;\n    for (let i = this.from;i < this.to; i++) {\n      let map = this._maps[i], result = map.mapResult(pos, assoc);\n      if (result.recover != null) {\n        let corr = this.getMirror(i);\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr;\n          pos = this._maps[corr].recover(result.recover);\n          continue;\n        }\n      }\n      delInfo |= result.delInfo;\n      pos = result.pos;\n    }\n    return simple ? pos : new MapResult(pos, delInfo, null);\n  }\n}\nvar stepsByID = Object.create(null);\n\nclass Step {\n  getMap() {\n    return StepMap.empty;\n  }\n  merge(other) {\n    return null;\n  }\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType)\n      throw new RangeError(\"Invalid input for Step.fromJSON\");\n    let type = stepsByID[json.stepType];\n    if (!type)\n      throw new RangeError(`No step type ${json.stepType} defined`);\n    return type.fromJSON(schema, json);\n  }\n  static jsonID(id, stepClass) {\n    if (id in stepsByID)\n      throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n    stepsByID[id] = stepClass;\n    stepClass.prototype.jsonID = id;\n    return stepClass;\n  }\n}\n\nclass StepResult {\n  constructor(doc2, failed) {\n    this.doc = doc2;\n    this.failed = failed;\n  }\n  static ok(doc2) {\n    return new StepResult(doc2, null);\n  }\n  static fail(message) {\n    return new StepResult(null, message);\n  }\n  static fromReplace(doc2, from, to, slice) {\n    try {\n      return StepResult.ok(doc2.replace(from, to, slice));\n    } catch (e) {\n      if (e instanceof ReplaceError)\n        return StepResult.fail(e.message);\n      throw e;\n    }\n  }\n}\nfunction mapFragment(fragment, f, parent) {\n  let mapped = [];\n  for (let i = 0;i < fragment.childCount; i++) {\n    let child = fragment.child(i);\n    if (child.content.size)\n      child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline)\n      child = f(child, parent, i);\n    mapped.push(child);\n  }\n  return Fragment.fromArray(mapped);\n}\n\nclass AddMarkStep extends Step {\n  constructor(from, to, mark) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n  apply(doc2) {\n    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);\n    let parent = $from.node($from.sharedDepth(this.to));\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {\n      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))\n        return node;\n      return node.mark(this.mark.addToSet(node.marks));\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc2, this.from, this.to, slice);\n  }\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos)\n      return null;\n    return new AddMarkStep(from.pos, to.pos, this.mark);\n  }\n  merge(other) {\n    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    return null;\n  }\n  toJSON() {\n    return {\n      stepType: \"addMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n\nclass RemoveMarkStep extends Step {\n  constructor(from, to, mark) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n  apply(doc2) {\n    let oldSlice = doc2.slice(this.from, this.to);\n    let slice = new Slice(mapFragment(oldSlice.content, (node) => {\n      return node.mark(this.mark.removeFromSet(node.marks));\n    }, doc2), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc2, this.from, this.to, slice);\n  }\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos)\n      return null;\n    return new RemoveMarkStep(from.pos, to.pos, this.mark);\n  }\n  merge(other) {\n    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    return null;\n  }\n  toJSON() {\n    return {\n      stepType: \"removeMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\nclass AddNodeMarkStep extends Step {\n  constructor(pos, mark) {\n    super();\n    this.pos = pos;\n    this.mark = mark;\n  }\n  apply(doc2) {\n    let node = doc2.nodeAt(this.pos);\n    if (!node)\n      return StepResult.fail(\"No node at mark step's position\");\n    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  invert(doc2) {\n    let node = doc2.nodeAt(this.pos);\n    if (node) {\n      let newSet = this.mark.addToSet(node.marks);\n      if (newSet.length == node.marks.length) {\n        for (let i = 0;i < node.marks.length; i++)\n          if (!node.marks[i].isInSet(newSet))\n            return new AddNodeMarkStep(this.pos, node.marks[i]);\n        return new AddNodeMarkStep(this.pos, this.mark);\n      }\n    }\n    return new RemoveNodeMarkStep(this.pos, this.mark);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n  }\n  toJSON() {\n    return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.pos != \"number\")\n      throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n\nclass RemoveNodeMarkStep extends Step {\n  constructor(pos, mark) {\n    super();\n    this.pos = pos;\n    this.mark = mark;\n  }\n  apply(doc2) {\n    let node = doc2.nodeAt(this.pos);\n    if (!node)\n      return StepResult.fail(\"No node at mark step's position\");\n    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  invert(doc2) {\n    let node = doc2.nodeAt(this.pos);\n    if (!node || !this.mark.isInSet(node.marks))\n      return this;\n    return new AddNodeMarkStep(this.pos, this.mark);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n  }\n  toJSON() {\n    return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.pos != \"number\")\n      throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\nclass ReplaceStep extends Step {\n  constructor(from, to, slice, structure = false) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.slice = slice;\n    this.structure = structure;\n  }\n  apply(doc2) {\n    if (this.structure && contentBetween(doc2, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\");\n    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);\n  }\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size]);\n  }\n  invert(doc2) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deletedAcross && to.deletedAcross)\n      return null;\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);\n  }\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n      return null;\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice, this.structure);\n    } else {\n      return null;\n    }\n  }\n  toJSON() {\n    let json = { stepType: \"replace\", from: this.from, to: this.to };\n    if (this.slice.size)\n      json.slice = this.slice.toJSON();\n    if (this.structure)\n      json.structure = true;\n    return json;\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);\n  }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n\nclass ReplaceAroundStep extends Step {\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.gapFrom = gapFrom;\n    this.gapTo = gapTo;\n    this.slice = slice;\n    this.insert = insert;\n    this.structure = structure;\n  }\n  apply(doc2) {\n    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\");\n    let gap = doc2.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\");\n    let inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted)\n      return StepResult.fail(\"Content does not fit in gap\");\n    return StepResult.fromReplace(doc2, this.from, this.to, inserted);\n  }\n  getMap() {\n    return new StepMap([\n      this.from,\n      this.gapFrom - this.from,\n      this.insert,\n      this.gapTo,\n      this.to - this.gapTo,\n      this.slice.size - this.insert\n    ]);\n  }\n  invert(doc2) {\n    let gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)\n      return null;\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n  }\n  toJSON() {\n    let json = {\n      stepType: \"replaceAround\",\n      from: this.from,\n      to: this.to,\n      gapFrom: this.gapFrom,\n      gapTo: this.gapTo,\n      insert: this.insert\n    };\n    if (this.slice.size)\n      json.slice = this.slice.toJSON();\n    if (this.structure)\n      json.structure = true;\n    return json;\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n  }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc2, from, to) {\n  let $from = doc2.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf)\n        return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false;\n}\nfunction addMark(tr, from, to, mark) {\n  let removed = [], added = [];\n  let removing, adding;\n  tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline)\n      return;\n    let marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      let newSet = mark.addToSet(marks);\n      for (let i = 0;i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end;\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n        }\n      }\n      if (adding && adding.to == start)\n        adding.to = end;\n      else\n        added.push(adding = new AddMarkStep(start, end, mark));\n    }\n  });\n  removed.forEach((s) => tr.step(s));\n  added.forEach((s) => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n  let matched = [], step = 0;\n  tr.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline)\n      return;\n    step++;\n    let toRemove = null;\n    if (mark instanceof MarkType) {\n      let set = node.marks, found2;\n      while (found2 = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found2);\n        set = found2.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks))\n        toRemove = [mark];\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to);\n      for (let i = 0;i < toRemove.length; i++) {\n        let style = toRemove[i], found2;\n        for (let j = 0;j < matched.length; j++) {\n          let m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style))\n            found2 = m;\n        }\n        if (found2) {\n          found2.to = end;\n          found2.step = step;\n        } else {\n          matched.push({ style, from: Math.max(pos, from), to: end, step });\n        }\n      }\n    }\n  });\n  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n  let node = tr.doc.nodeAt(pos);\n  let replSteps = [], cur = pos + 1;\n  for (let i = 0;i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize;\n    let allowed = match.matchType(child.type);\n    if (!allowed) {\n      replSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n      for (let j = 0;j < child.marks.length; j++)\n        if (!parentType.allowsMarkType(child.marks[j].type))\n          tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n      if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n        let m, newline = /\\r?\\n|\\r/g, slice;\n        while (m = newline.exec(child.text)) {\n          if (!slice)\n            slice = new Slice(Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n        }\n      }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true);\n    tr.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n  for (let i = replSteps.length - 1;i >= 0; i--)\n    tr.step(replSteps[i]);\n}\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\nfunction liftTarget(range) {\n  let parent = range.parent;\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (let depth = range.depth, contentBefore = 0, contentAfter = 0;; --depth) {\n    let node = range.$from.node(depth);\n    let index = range.$from.index(depth) + contentBefore, endIndex = range.$to.indexAfter(depth) - contentAfter;\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth;\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n      break;\n    if (index)\n      contentBefore = 1;\n    if (endIndex < node.childCount)\n      contentAfter = 1;\n  }\n  return null;\n}\nfunction lift(tr, range, target) {\n  let { $from, $to, depth } = range;\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  let start = gapStart, end = gapEnd;\n  let before = Fragment.empty, openStart = 0;\n  for (let d = depth, splitting = false;d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    }\n  let after = Fragment.empty, openEnd = 0;\n  for (let d = depth, splitting = false;d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true;\n      after = Fragment.from($to.node(d).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    }\n  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\nfunction wrap(tr, range, wrappers) {\n  let content = Fragment.empty;\n  for (let i = wrappers.length - 1;i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n  let { start, end } = range;\n  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n  if (!type.isTextblock)\n    throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  let mapFrom = tr.steps.length;\n  tr.doc.nodesBetween(from, to, (node, pos) => {\n    let attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n      let convertNewlines = null;\n      if (type.schema.linebreakReplacement) {\n        let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n        if (pre && !supportLinebreak)\n          convertNewlines = false;\n        else if (!pre && supportLinebreak)\n          convertNewlines = true;\n      }\n      if (convertNewlines === false)\n        replaceLinebreaks(tr, node, pos, mapFrom);\n      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n      let mapping = tr.mapping.slice(mapFrom);\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n      if (convertNewlines === true)\n        replaceNewlines(tr, node, pos, mapFrom);\n      return false;\n    }\n  });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n  node.forEach((child, offset) => {\n    if (child.isText) {\n      let m, newline = /\\r?\\n|\\r/g;\n      while (m = newline.exec(child.text)) {\n        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n      }\n    }\n  });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n  node.forEach((child, offset) => {\n    if (child.type == child.type.schema.linebreakReplacement) {\n      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n      tr.replaceWith(start, start + 1, node.type.schema.text(`\n`));\n    }\n  });\n}\nfunction canChangeType(doc2, pos, type) {\n  let $pos = doc2.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n}\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n  let node = tr.doc.nodeAt(pos);\n  if (!node)\n    throw new RangeError(\"No node at given position\");\n  if (!type)\n    type = node.type;\n  let newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name);\n  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n}\nfunction canSplit(doc2, pos, depth = 1, typesAfter) {\n  let $pos = doc2.resolve(pos), base = $pos.depth - depth;\n  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false;\n  for (let d = $pos.depth - 1, i = depth - 2;d > base; d--, i--) {\n    let node = $pos.node(d), index2 = $pos.index(d);\n    if (node.type.spec.isolating)\n      return false;\n    let rest = node.content.cutByIndex(index2, node.childCount);\n    let overrideChild = typesAfter && typesAfter[i + 1];\n    if (overrideChild)\n      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n    let after = typesAfter && typesAfter[i] || node;\n    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))\n      return false;\n  }\n  let index = $pos.indexAfter(base);\n  let baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1;d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    let typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n}\nfunction canJoin(doc2, pos) {\n  let $pos = doc2.resolve(pos), index = $pos.index();\n  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\nfunction canAppendWithSubstitutedLinebreaks(a, b) {\n  if (!b.content.size)\n    a.type.compatibleContent(b.type);\n  let match = a.contentMatchAt(a.childCount);\n  let { linebreakReplacement } = a.type.schema;\n  for (let i = 0;i < b.childCount; i++) {\n    let child = b.child(i);\n    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n    match = match.matchType(type);\n    if (!match)\n      return false;\n    if (!a.type.allowsMarks(child.marks))\n      return false;\n  }\n  return match.validEnd;\n}\nfunction joinable2(a, b) {\n  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n}\nfunction join(tr, pos, depth) {\n  let convertNewlines = null;\n  let { linebreakReplacement } = tr.doc.type.schema;\n  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;\n  if (linebreakReplacement && beforeType.inlineContent) {\n    let pre = beforeType.whitespace == \"pre\";\n    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n    if (pre && !supportLinebreak)\n      convertNewlines = false;\n    else if (!pre && supportLinebreak)\n      convertNewlines = true;\n  }\n  let mapFrom = tr.steps.length;\n  if (convertNewlines === false) {\n    let $after = tr.doc.resolve(pos + depth);\n    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n  }\n  if (beforeType.inlineContent)\n    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n  let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);\n  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));\n  if (convertNewlines === true) {\n    let $full = tr.doc.resolve(start);\n    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n  }\n  return tr;\n}\nfunction insertPoint(doc2, pos, nodeType) {\n  let $pos = doc2.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n    return pos;\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1;d >= 0; d--) {\n      let index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType))\n        return $pos.before(d + 1);\n      if (index > 0)\n        return null;\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1;d >= 0; d--) {\n      let index = $pos.indexAfter(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType))\n        return $pos.after(d + 1);\n      if (index < $pos.node(d).childCount)\n        return null;\n    }\n  return null;\n}\nfunction dropPoint(doc2, pos, slice) {\n  let $pos = doc2.resolve(pos);\n  if (!slice.content.size)\n    return pos;\n  let content = slice.content;\n  for (let i = 0;i < slice.openStart; i++)\n    content = content.firstChild.content;\n  for (let pass = 1;pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth;d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      let parent = $pos.node(d), fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n    }\n  }\n  return null;\n}\nfunction replaceStep(doc2, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size)\n    return null;\n  let $from = doc2.resolve(from), $to = doc2.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    return new ReplaceStep(from, to, slice);\n  return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n\nclass Fitter {\n  constructor($from, $to, unplaced) {\n    this.$from = $from;\n    this.$to = $to;\n    this.unplaced = unplaced;\n    this.frontier = [];\n    this.placed = Fragment.empty;\n    for (let i = 0;i <= $from.depth; i++) {\n      let node = $from.node(i);\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      });\n    }\n    for (let i = $from.depth;i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed));\n  }\n  get depth() {\n    return this.frontier.length - 1;\n  }\n  fit() {\n    while (this.unplaced.size) {\n      let fit = this.findFittable();\n      if (fit)\n        this.placeNodes(fit);\n      else\n        this.openMore() || this.dropNode();\n    }\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n    if (!$to)\n      return null;\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n    while (openStart && openEnd && content.childCount == 1) {\n      content = content.firstChild.content;\n      openStart--;\n      openEnd--;\n    }\n    let slice = new Slice(content, openStart, openEnd);\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n    if (slice.size || $from.pos != this.$to.pos)\n      return new ReplaceStep($from.pos, $to.pos, slice);\n    return null;\n  }\n  findFittable() {\n    let startDepth = this.unplaced.openStart;\n    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd;d < startDepth; d++) {\n      let node = cur.firstChild;\n      if (cur.childCount > 1)\n        openEnd = 0;\n      if (node.type.spec.isolating && openEnd <= d) {\n        startDepth = d;\n        break;\n      }\n      cur = node.content;\n    }\n    for (let pass = 1;pass <= 2; pass++) {\n      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart;sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent = null;\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n          fragment = parent.content;\n        } else {\n          fragment = this.unplaced.content;\n        }\n        let first = fragment.firstChild;\n        for (let frontierDepth = this.depth;frontierDepth >= 0; frontierDepth--) {\n          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))\n            return { sliceDepth, frontierDepth, parent, inject };\n          else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))\n            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };\n          if (parent && match.matchType(parent.type))\n            break;\n        }\n      }\n    }\n  }\n  openMore() {\n    let { content, openStart, openEnd } = this.unplaced;\n    let inner = contentAt(content, openStart);\n    if (!inner.childCount || inner.firstChild.isLeaf)\n      return false;\n    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n    return true;\n  }\n  dropNode() {\n    let { content, openStart, openEnd } = this.unplaced;\n    let inner = contentAt(content, openStart);\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size;\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n    }\n  }\n  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {\n    while (this.depth > frontierDepth)\n      this.closeFrontierNode();\n    if (wrap2)\n      for (let i = 0;i < wrap2.length; i++)\n        this.openFrontierNode(wrap2[i]);\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n    let openStart = slice.openStart - sliceDepth;\n    let taken = 0, add = [];\n    let { match, type } = this.frontier[frontierDepth];\n    if (inject) {\n      for (let i = 0;i < inject.childCount; i++)\n        add.push(inject.child(i));\n      match = match.matchFragment(inject);\n    }\n    let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches2 = match.matchType(next.type);\n      if (!matches2)\n        break;\n      taken++;\n      if (taken > 1 || openStart == 0 || next.content.size) {\n        match = matches2;\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n      }\n    }\n    let toEnd = taken == fragment.childCount;\n    if (!toEnd)\n      openEndCount = -1;\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n    this.frontier[frontierDepth].match = match;\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode();\n    for (let i = 0, cur = fragment;i < openEndCount; i++) {\n      let node = cur.lastChild;\n      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n      cur = node.content;\n    }\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n  }\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock)\n      return -1;\n    let top = this.frontier[this.depth], level;\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)\n      return -1;\n    let { depth } = this.$to, after = this.$to.after(depth);\n    while (depth > 1 && after == this.$to.end(--depth))\n      ++after;\n    return after;\n  }\n  findCloseLevel($to) {\n    scan:\n      for (let i = Math.min(this.depth, $to.depth);i >= 0; i--) {\n        let { match, type } = this.frontier[i];\n        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        let fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit)\n          continue;\n        for (let d = i - 1;d >= 0; d--) {\n          let { match: match2, type: type2 } = this.frontier[d];\n          let matches2 = contentAfterFits($to, d, type2, match2, true);\n          if (!matches2 || matches2.childCount)\n            continue scan;\n        }\n        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n      }\n  }\n  close($to) {\n    let close2 = this.findCloseLevel($to);\n    if (!close2)\n      return null;\n    while (this.depth > close2.depth)\n      this.closeFrontierNode();\n    if (close2.fit.childCount)\n      this.placed = addToFragment(this.placed, close2.depth, close2.fit);\n    $to = close2.move;\n    for (let d = close2.depth + 1;d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n      this.openFrontierNode(node.type, node.attrs, add);\n    }\n    return $to;\n  }\n  openFrontierNode(type, attrs = null, content) {\n    let top = this.frontier[this.depth];\n    top.match = top.match.matchType(type);\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n    this.frontier.push({ type, match: type.contentMatch });\n  }\n  closeFrontierNode() {\n    let open = this.frontier.pop();\n    let add = open.match.fillBefore(Fragment.empty, true);\n    if (add.childCount)\n      this.placed = addToFragment(this.placed, this.frontier.length, add);\n  }\n}\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0)\n    return fragment.cutByIndex(count, fragment.childCount);\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0)\n    return fragment.append(content);\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n  for (let i = 0;i < depth; i++)\n    fragment = fragment.firstChild.content;\n  return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0)\n    return node;\n  let frag = node.content;\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0)\n      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n  }\n  return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type))\n    return null;\n  let fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start;i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks))\n      return true;\n  return false;\n}\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n  if (!slice.size)\n    return tr.deleteRange(from, to);\n  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    return tr.step(new ReplaceStep(from, to, slice));\n  let targetDepths = coveredDepths($from, $to);\n  if (targetDepths[targetDepths.length - 1] == 0)\n    targetDepths.pop();\n  let preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  for (let d = $from.depth, pos = $from.pos - 1;d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec;\n    if (spec.defining || spec.definingAsContext || spec.isolating)\n      break;\n    if (targetDepths.indexOf(d) > -1)\n      preferredTarget = d;\n    else if ($from.before(d) == pos)\n      targetDepths.splice(1, 0, -d);\n  }\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  let leftNodes = [], preferredDepth = slice.openStart;\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart)\n      break;\n    content = node.content;\n  }\n  for (let d = preferredDepth - 1;d >= 0; d--) {\n    let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n      preferredDepth = d;\n    else if (def || !leftNode.type.isTextblock)\n      break;\n  }\n  for (let j = slice.openStart;j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    let insert = leftNodes[openDepth];\n    if (!insert)\n      continue;\n    for (let i = 0;i < targetDepths.length; i++) {\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n    }\n  }\n  let startSteps = tr.steps.length;\n  for (let i = targetDepths.length - 1;i >= 0; i--) {\n    tr.replace(from, to, slice);\n    if (tr.steps.length > startSteps)\n      break;\n    let depth = targetDepths[i];\n    if (depth < 0)\n      continue;\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0);\n    let start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n  return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(tr.doc, from, node.type);\n    if (point != null)\n      from = to = point;\n  }\n  tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n  let covered = coveredDepths($from, $to);\n  for (let i = 0;i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1;\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)\n      return tr.delete($from.start(depth), $to.end(depth));\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return tr.delete($from.before(depth), $to.after(depth));\n  }\n  for (let d = 1;d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))\n      return tr.delete($from.before(d), to);\n  }\n  tr.delete(from, to);\n}\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (let d = minDepth;d >= 0; d--) {\n    let start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)\n      break;\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)\n      result.push(d);\n  }\n  return result;\n}\n\nclass AttrStep extends Step {\n  constructor(pos, attr, value) {\n    super();\n    this.pos = pos;\n    this.attr = attr;\n    this.value = value;\n  }\n  apply(doc2) {\n    let node = doc2.nodeAt(this.pos);\n    if (!node)\n      return StepResult.fail(\"No node at attribute step's position\");\n    let attrs = Object.create(null);\n    for (let name in node.attrs)\n      attrs[name] = node.attrs[name];\n    attrs[this.attr] = this.value;\n    let updated = node.type.create(attrs, null, node.marks);\n    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  getMap() {\n    return StepMap.empty;\n  }\n  invert(doc2) {\n    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n  }\n  toJSON() {\n    return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n      throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n    return new AttrStep(json.pos, json.attr, json.value);\n  }\n}\nStep.jsonID(\"attr\", AttrStep);\n\nclass DocAttrStep extends Step {\n  constructor(attr, value) {\n    super();\n    this.attr = attr;\n    this.value = value;\n  }\n  apply(doc2) {\n    let attrs = Object.create(null);\n    for (let name in doc2.attrs)\n      attrs[name] = doc2.attrs[name];\n    attrs[this.attr] = this.value;\n    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);\n    return StepResult.ok(updated);\n  }\n  getMap() {\n    return StepMap.empty;\n  }\n  invert(doc2) {\n    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);\n  }\n  map(mapping) {\n    return this;\n  }\n  toJSON() {\n    return { stepType: \"docAttr\", attr: this.attr, value: this.value };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.attr != \"string\")\n      throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n    return new DocAttrStep(json.attr, json.value);\n  }\n}\nStep.jsonID(\"docAttr\", DocAttrStep);\nvar TransformError = class extends Error {\n};\nTransformError = function TransformError2(message) {\n  let err = Error.call(this, message);\n  err.__proto__ = TransformError2.prototype;\n  return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\nclass Transform {\n  constructor(doc2) {\n    this.doc = doc2;\n    this.steps = [];\n    this.docs = [];\n    this.mapping = new Mapping;\n  }\n  get before() {\n    return this.docs.length ? this.docs[0] : this.doc;\n  }\n  step(step) {\n    let result = this.maybeStep(step);\n    if (result.failed)\n      throw new TransformError(result.failed);\n    return this;\n  }\n  maybeStep(step) {\n    let result = step.apply(this.doc);\n    if (!result.failed)\n      this.addStep(step, result.doc);\n    return result;\n  }\n  get docChanged() {\n    return this.steps.length > 0;\n  }\n  changedRange() {\n    let from = 1e9, to = -1e9;\n    for (let i = 0;i < this.mapping.maps.length; i++) {\n      let map = this.mapping.maps[i];\n      if (i) {\n        from = map.map(from, 1);\n        to = map.map(to, -1);\n      }\n      map.forEach((_f, _t, fromB, toB) => {\n        from = Math.min(from, fromB);\n        to = Math.max(to, toB);\n      });\n    }\n    return from == 1e9 ? null : { from, to };\n  }\n  addStep(step, doc2) {\n    this.docs.push(this.doc);\n    this.steps.push(step);\n    this.mapping.appendMap(step.getMap());\n    this.doc = doc2;\n  }\n  replace(from, to = from, slice = Slice.empty) {\n    let step = replaceStep(this.doc, from, to, slice);\n    if (step)\n      this.step(step);\n    return this;\n  }\n  replaceWith(from, to, content) {\n    return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));\n  }\n  delete(from, to) {\n    return this.replace(from, to, Slice.empty);\n  }\n  insert(pos, content) {\n    return this.replaceWith(pos, pos, content);\n  }\n  replaceRange(from, to, slice) {\n    replaceRange(this, from, to, slice);\n    return this;\n  }\n  replaceRangeWith(from, to, node) {\n    replaceRangeWith(this, from, to, node);\n    return this;\n  }\n  deleteRange(from, to) {\n    deleteRange(this, from, to);\n    return this;\n  }\n  lift(range, target) {\n    lift(this, range, target);\n    return this;\n  }\n  join(pos, depth = 1) {\n    join(this, pos, depth);\n    return this;\n  }\n  wrap(range, wrappers) {\n    wrap(this, range, wrappers);\n    return this;\n  }\n  setBlockType(from, to = from, type, attrs = null) {\n    setBlockType(this, from, to, type, attrs);\n    return this;\n  }\n  setNodeMarkup(pos, type, attrs = null, marks) {\n    setNodeMarkup(this, pos, type, attrs, marks);\n    return this;\n  }\n  setNodeAttribute(pos, attr, value) {\n    this.step(new AttrStep(pos, attr, value));\n    return this;\n  }\n  setDocAttribute(attr, value) {\n    this.step(new DocAttrStep(attr, value));\n    return this;\n  }\n  addNodeMark(pos, mark) {\n    this.step(new AddNodeMarkStep(pos, mark));\n    return this;\n  }\n  removeNodeMark(pos, mark) {\n    let node = this.doc.nodeAt(pos);\n    if (!node)\n      throw new RangeError(\"No node at position \" + pos);\n    if (mark instanceof Mark) {\n      if (mark.isInSet(node.marks))\n        this.step(new RemoveNodeMarkStep(pos, mark));\n    } else {\n      let set = node.marks, found2, steps = [];\n      while (found2 = mark.isInSet(set)) {\n        steps.push(new RemoveNodeMarkStep(pos, found2));\n        set = found2.removeFromSet(set);\n      }\n      for (let i = steps.length - 1;i >= 0; i--)\n        this.step(steps[i]);\n    }\n    return this;\n  }\n  split(pos, depth = 1, typesAfter) {\n    split(this, pos, depth, typesAfter);\n    return this;\n  }\n  addMark(from, to, mark) {\n    addMark(this, from, to, mark);\n    return this;\n  }\n  removeMark(from, to, mark) {\n    removeMark(this, from, to, mark);\n    return this;\n  }\n  clearIncompatible(pos, parentType, match) {\n    clearIncompatible(this, pos, parentType, match);\n    return this;\n  }\n}\n\n// node_modules/prosemirror-state/dist/index.js\nvar classesById = Object.create(null);\n\nclass Selection {\n  constructor($anchor, $head, ranges) {\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n  get anchor() {\n    return this.$anchor.pos;\n  }\n  get head() {\n    return this.$head.pos;\n  }\n  get from() {\n    return this.$from.pos;\n  }\n  get to() {\n    return this.$to.pos;\n  }\n  get $from() {\n    return this.ranges[0].$from;\n  }\n  get $to() {\n    return this.ranges[0].$to;\n  }\n  get empty() {\n    let ranges = this.ranges;\n    for (let i = 0;i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos)\n        return false;\n    return true;\n  }\n  content() {\n    return this.$from.doc.slice(this.from, this.to, true);\n  }\n  replace(tr, content = Slice.empty) {\n    let lastNode = content.content.lastChild, lastParent = null;\n    for (let i = 0;i < content.openEnd; i++) {\n      lastParent = lastNode;\n      lastNode = lastNode.lastChild;\n    }\n    let mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0;i < ranges.length; i++) {\n      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n    }\n  }\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0;i < ranges.length; i++) {\n      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      let from = mapping.map($from.pos), to = mapping.map($to.pos);\n      if (i) {\n        tr.deleteRange(from, to);\n      } else {\n        tr.replaceRangeWith(from, to, node);\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n      }\n    }\n  }\n  static findFrom($pos, dir, textOnly = false) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n    if (inner)\n      return inner;\n    for (let depth = $pos.depth - 1;depth >= 0; depth--) {\n      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n      if (found2)\n        return found2;\n    }\n    return null;\n  }\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n  }\n  static atStart(doc2) {\n    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);\n  }\n  static atEnd(doc2) {\n    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);\n  }\n  static fromJSON(doc2, json) {\n    if (!json || !json.type)\n      throw new RangeError(\"Invalid input for Selection.fromJSON\");\n    let cls = classesById[json.type];\n    if (!cls)\n      throw new RangeError(`No selection type ${json.type} defined`);\n    return cls.fromJSON(doc2, json);\n  }\n  static jsonID(id, selectionClass) {\n    if (id in classesById)\n      throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n    classesById[id] = selectionClass;\n    selectionClass.prototype.jsonID = id;\n    return selectionClass;\n  }\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark();\n  }\n}\nSelection.prototype.visible = true;\n\nclass SelectionRange {\n  constructor($from, $to) {\n    this.$from = $from;\n    this.$to = $to;\n  }\n}\nvar warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\n\nclass TextSelection extends Selection {\n  constructor($anchor, $head = $anchor) {\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    super($anchor, $head);\n  }\n  get $cursor() {\n    return this.$anchor.pos == this.$head.pos ? this.$head : null;\n  }\n  map(doc2, mapping) {\n    let $head = doc2.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent)\n      return Selection.near($head);\n    let $anchor = doc2.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n  }\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content);\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to);\n      if (marks)\n        tr.ensureMarks(marks);\n    }\n  }\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n  }\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head);\n  }\n  toJSON() {\n    return { type: \"text\", anchor: this.anchor, head: this.head };\n  }\n  static fromJSON(doc2, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));\n  }\n  static create(doc2, anchor, head = anchor) {\n    let $anchor = doc2.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));\n  }\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos)\n      bias = dPos >= 0 ? 1 : -1;\n    if (!$head.parent.inlineContent) {\n      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found2)\n        $head = found2.$head;\n      else\n        return Selection.near($head, bias);\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if ($anchor.pos < $head.pos != dPos < 0)\n          $anchor = $head;\n      }\n    }\n    return new TextSelection($anchor, $head);\n  }\n}\nSelection.jsonID(\"text\", TextSelection);\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc2) {\n    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));\n  }\n}\n\nclass NodeSelection extends Selection {\n  constructor($pos) {\n    let node = $pos.nodeAfter;\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    super($pos, $end);\n    this.node = node;\n  }\n  map(doc2, mapping) {\n    let { deleted, pos } = mapping.mapResult(this.anchor);\n    let $pos = doc2.resolve(pos);\n    if (deleted)\n      return Selection.near($pos);\n    return new NodeSelection($pos);\n  }\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0);\n  }\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor;\n  }\n  toJSON() {\n    return { type: \"node\", anchor: this.anchor };\n  }\n  getBookmark() {\n    return new NodeBookmark(this.anchor);\n  }\n  static fromJSON(doc2, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n    return new NodeSelection(doc2.resolve(json.anchor));\n  }\n  static create(doc2, from) {\n    return new NodeSelection(doc2.resolve(from));\n  }\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false;\n  }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n  map(mapping) {\n    let { deleted, pos } = mapping.mapResult(this.anchor);\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n  }\n  resolve(doc2) {\n    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;\n    if (node && NodeSelection.isSelectable(node))\n      return new NodeSelection($pos);\n    return Selection.near($pos);\n  }\n}\n\nclass AllSelection extends Selection {\n  constructor(doc2) {\n    super(doc2.resolve(0), doc2.resolve(doc2.content.size));\n  }\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      let sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection))\n        tr.setSelection(sel);\n    } else {\n      super.replace(tr, content);\n    }\n  }\n  toJSON() {\n    return { type: \"all\" };\n  }\n  static fromJSON(doc2) {\n    return new AllSelection(doc2);\n  }\n  map(doc2) {\n    return new AllSelection(doc2);\n  }\n  eq(other) {\n    return other instanceof AllSelection;\n  }\n  getBookmark() {\n    return AllBookmark;\n  }\n}\nSelection.jsonID(\"all\", AllSelection);\nvar AllBookmark = {\n  map() {\n    return this;\n  },\n  resolve(doc2) {\n    return new AllSelection(doc2);\n  }\n};\nfunction findSelectionIn(doc2, node, pos, index, dir, text = false) {\n  if (node.inlineContent)\n    return TextSelection.create(doc2, pos);\n  for (let i = index - (dir > 0 ? 0 : 1);dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i);\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner)\n        return inner;\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n    pos += child.nodeSize * dir;\n  }\n  return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1;\n  if (last < startLen)\n    return;\n  let step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))\n    return;\n  let map = tr.mapping.maps[last], end;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end == null)\n      end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nvar UPDATED_SEL = 1;\nvar UPDATED_MARKS = 2;\nvar UPDATED_SCROLL = 4;\n\nclass Transaction extends Transform {\n  constructor(state) {\n    super(state.doc);\n    this.curSelectionFor = 0;\n    this.updated = 0;\n    this.meta = Object.create(null);\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    this.storedMarks = state.storedMarks;\n  }\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection;\n  }\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this;\n  }\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0;\n  }\n  setStoredMarks(marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this;\n  }\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks);\n    return this;\n  }\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n  }\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n  }\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0;\n  }\n  addStep(step, doc2) {\n    super.addStep(step, doc2);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  }\n  setTime(time) {\n    this.time = time;\n    return this;\n  }\n  replaceSelection(slice) {\n    this.selection.replace(this, slice);\n    return this;\n  }\n  replaceSelectionWith(node, inheritMarks = true) {\n    let selection = this.selection;\n    if (inheritMarks)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));\n    selection.replaceWith(this, node);\n    return this;\n  }\n  deleteSelection() {\n    this.selection.replace(this);\n    return this;\n  }\n  insertText(text, from, to) {\n    let schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text)\n        return this.deleteSelection();\n      return this.replaceSelectionWith(schema.text(text), true);\n    } else {\n      if (to == null)\n        to = from;\n      if (!text)\n        return this.deleteRange(from, to);\n      let marks = this.storedMarks;\n      if (!marks) {\n        let $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty && this.selection.to == from + text.length)\n        this.setSelection(Selection.near(this.selection.$to));\n      return this;\n    }\n  }\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this;\n  }\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key];\n  }\n  get isGeneric() {\n    for (let _ in this.meta)\n      return false;\n    return true;\n  }\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL;\n    return this;\n  }\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0;\n  }\n}\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name;\n    this.init = bind(desc.init, self);\n    this.apply = bind(desc.apply, self);\n  }\n}\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) {\n      return config.doc || config.schema.topNodeType.createAndFill();\n    },\n    apply(tr) {\n      return tr.doc;\n    }\n  }),\n  new FieldDesc(\"selection\", {\n    init(config, instance) {\n      return config.selection || Selection.atStart(instance.doc);\n    },\n    apply(tr) {\n      return tr.selection;\n    }\n  }),\n  new FieldDesc(\"storedMarks\", {\n    init(config) {\n      return config.storedMarks || null;\n    },\n    apply(tr, _marks, _old, state) {\n      return state.selection.$cursor ? tr.storedMarks : null;\n    }\n  }),\n  new FieldDesc(\"scrollToSelection\", {\n    init() {\n      return 0;\n    },\n    apply(tr, prev) {\n      return tr.scrolledIntoView ? prev + 1 : prev;\n    }\n  })\n];\n\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema;\n    this.plugins = [];\n    this.pluginsByKey = Object.create(null);\n    this.fields = baseFields.slice();\n    if (plugins)\n      plugins.forEach((plugin) => {\n        if (this.pluginsByKey[plugin.key])\n          throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n        this.plugins.push(plugin);\n        this.pluginsByKey[plugin.key] = plugin;\n        if (plugin.spec.state)\n          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n      });\n  }\n}\n\nclass EditorState {\n  constructor(config) {\n    this.config = config;\n  }\n  get schema() {\n    return this.config.schema;\n  }\n  get plugins() {\n    return this.config.plugins;\n  }\n  apply(tr) {\n    return this.applyTransaction(tr).state;\n  }\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0;i < this.config.plugins.length; i++)\n      if (i != ignore) {\n        let plugin = this.config.plugins[i];\n        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n          return false;\n      }\n    return true;\n  }\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr))\n      return { state: this, transactions: [] };\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n    for (;; ) {\n      let haveNew = false;\n      for (let i = 0;i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i];\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr);\n            if (!seen) {\n              seen = [];\n              for (let j = 0;j < this.config.plugins.length; j++)\n                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n            }\n            trs.push(tr);\n            newState = newState.applyInner(tr);\n            haveNew = true;\n          }\n          if (seen)\n            seen[i] = { state: newState, n: trs.length };\n        }\n      }\n      if (!haveNew)\n        return { state: newState, transactions: trs };\n    }\n  }\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc))\n      throw new RangeError(\"Applying a mismatched transaction\");\n    let newInstance = new EditorState(this.config), fields = this.config.fields;\n    for (let i = 0;i < fields.length; i++) {\n      let field = fields[i];\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n    }\n    return newInstance;\n  }\n  get tr() {\n    return new Transaction(this);\n  }\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n    let instance = new EditorState($config);\n    for (let i = 0;i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n    return instance;\n  }\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins);\n    let fields = $config.fields, instance = new EditorState($config);\n    for (let i = 0;i < fields.length; i++) {\n      let name = fields[i].name;\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n    }\n    return instance;\n  }\n  toJSON(pluginFields) {\n    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n    if (this.storedMarks)\n      result.storedMarks = this.storedMarks.map((m) => m.toJSON());\n    if (pluginFields && typeof pluginFields == \"object\")\n      for (let prop in pluginFields) {\n        if (prop == \"doc\" || prop == \"selection\")\n          throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n        let plugin = pluginFields[prop], state = plugin.spec.state;\n        if (state && state.toJSON)\n          result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n      }\n    return result;\n  }\n  static fromJSON(config, json, pluginFields) {\n    if (!json)\n      throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n    if (!config.schema)\n      throw new RangeError(\"Required config field 'schema' missing\");\n    let $config = new Configuration(config.schema, config.plugins);\n    let instance = new EditorState($config);\n    $config.fields.forEach((field) => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc);\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection);\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks)\n          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n      } else {\n        if (pluginFields)\n          for (let prop in pluginFields) {\n            let plugin = pluginFields[prop], state = plugin.spec.state;\n            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n              return;\n            }\n          }\n        instance[field.name] = field.init(config, instance);\n      }\n    });\n    return instance;\n  }\n}\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop];\n    if (val instanceof Function)\n      val = val.bind(self);\n    else if (prop == \"handleDOMEvents\")\n      val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n  return target;\n}\n\nclass Plugin {\n  constructor(spec) {\n    this.spec = spec;\n    this.props = {};\n    if (spec.props)\n      bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n  getState(state) {\n    return state[this.key];\n  }\n}\nvar keys = Object.create(null);\nfunction createKey(name) {\n  if (name in keys)\n    return name + \"$\" + ++keys[name];\n  keys[name] = 0;\n  return name + \"$\";\n}\n\nclass PluginKey {\n  constructor(name = \"key\") {\n    this.key = createKey(name);\n  }\n  get(state) {\n    return state.config.pluginsByKey[this.key];\n  }\n  getState(state) {\n    return state[this.key];\n  }\n}\n\n// node_modules/prosemirror-view/dist/index.js\nvar domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node)\n      return index;\n  }\n};\nvar parentNode = function(node) {\n  let parent = node.assignedSlot || node.parentNode;\n  return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nvar reusedRange = null;\nvar textRange = function(node, from, to) {\n  let range = reusedRange || (reusedRange = document.createRange());\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range;\n};\nvar clearReusedRange = function() {\n  reusedRange = null;\n};\nvar isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nvar atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  var _a;\n  for (;; ) {\n    if (node == targetNode && off == targetOff)\n      return true;\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      let parent = node.parentNode;\n      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (child.nodeType == 1 && child.contentEditable == \"false\") {\n        if ((_a = child.pmViewDesc) === null || _a === undefined ? undefined : _a.ignoreForSelection)\n          off += dir;\n        else\n          return false;\n      } else {\n        node = child;\n        off = dir < 0 ? nodeSize(node) : 0;\n      }\n    } else {\n      return false;\n    }\n  }\n}\nfunction nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n  for (;; ) {\n    if (node.nodeType == 3 && offset)\n      return node;\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.contentEditable == \"false\")\n        return null;\n      node = node.childNodes[offset - 1];\n      offset = nodeSize(node);\n    } else if (node.parentNode && !hasBlockDesc(node)) {\n      offset = domIndex(node);\n      node = node.parentNode;\n    } else {\n      return null;\n    }\n  }\n}\nfunction textNodeAfter$1(node, offset) {\n  for (;; ) {\n    if (node.nodeType == 3 && offset < node.nodeValue.length)\n      return node;\n    if (node.nodeType == 1 && offset < node.childNodes.length) {\n      if (node.contentEditable == \"false\")\n        return null;\n      node = node.childNodes[offset];\n      offset = 0;\n    } else if (node.parentNode && !hasBlockDesc(node)) {\n      offset = domIndex(node) + 1;\n      node = node.parentNode;\n    } else {\n      return null;\n    }\n  }\n}\nfunction isOnEdge(node, offset, parent) {\n  for (let atStart = offset == 0, atEnd = offset == nodeSize(node);atStart || atEnd; ) {\n    if (node == parent)\n      return true;\n    let index = domIndex(node);\n    node = node.parentNode;\n    if (!node)\n      return false;\n    atStart = atStart && index == 0;\n    atEnd = atEnd && index == nodeSize(node);\n  }\n}\nfunction hasBlockDesc(dom) {\n  let desc;\n  for (let cur = dom;cur; cur = cur.parentNode)\n    if (desc = cur.pmViewDesc)\n      break;\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\nvar selectionCollapsed = function(domSel) {\n  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n  let event = document.createEvent(\"Event\");\n  event.initEvent(\"keydown\", true, true);\n  event.keyCode = keyCode;\n  event.key = event.code = key;\n  return event;\n}\nfunction deepActiveElement(doc2) {\n  let elt = doc2.activeElement;\n  while (elt && elt.shadowRoot)\n    elt = elt.shadowRoot.activeElement;\n  return elt;\n}\nfunction caretFromPoint(doc2, x, y) {\n  if (doc2.caretPositionFromPoint) {\n    try {\n      let pos = doc2.caretPositionFromPoint(x, y);\n      if (pos)\n        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };\n    } catch (_) {}\n  }\n  if (doc2.caretRangeFromPoint) {\n    let range = doc2.caretRangeFromPoint(x, y);\n    if (range)\n      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };\n  }\n}\nvar nav = typeof navigator != \"undefined\" ? navigator : null;\nvar doc2 = typeof document != \"undefined\" ? document : null;\nvar agent = nav && nav.userAgent || \"\";\nvar ie_edge = /Edge\\/(\\d+)/.exec(agent);\nvar ie_upto10 = /MSIE \\d/.exec(agent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nvar ie = !!(ie_upto10 || ie_11up || ie_edge);\nvar ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nvar gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\nvar _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nvar chrome = !!_chrome;\nvar chrome_version = _chrome ? +_chrome[1] : 0;\nvar safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\nvar ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nvar mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nvar windows = nav ? /Win/.test(nav.platform) : false;\nvar android = /Android \\d/.test(agent);\nvar webkit = !!doc2 && \"webkitFontSmoothing\" in doc2.documentElement.style;\nvar webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\nfunction windowRect(doc3) {\n  let vp = doc3.defaultView && doc3.defaultView.visualViewport;\n  if (vp)\n    return {\n      left: 0,\n      right: vp.width,\n      top: 0,\n      bottom: vp.height\n    };\n  return {\n    left: 0,\n    right: doc3.documentElement.clientWidth,\n    top: 0,\n    bottom: doc3.documentElement.clientHeight\n  };\n}\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n  let rect = node.getBoundingClientRect();\n  let scaleX = rect.width / node.offsetWidth || 1;\n  let scaleY = rect.height / node.offsetHeight || 1;\n  return {\n    left: rect.left,\n    right: rect.left + node.clientWidth * scaleX,\n    top: rect.top,\n    bottom: rect.top + node.clientHeight * scaleY\n  };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n  let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n  let doc3 = view.dom.ownerDocument;\n  for (let parent = startDOM || view.dom;; ) {\n    if (!parent)\n      break;\n    if (parent.nodeType != 1) {\n      parent = parentNode(parent);\n      continue;\n    }\n    let elt = parent;\n    let atTop = elt == doc3.body;\n    let bounding = atTop ? windowRect(doc3) : clientRect(elt);\n    let moveX = 0, moveY = 0;\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n    if (moveX || moveY) {\n      if (atTop) {\n        doc3.defaultView.scrollBy(moveX, moveY);\n      } else {\n        let { scrollLeft: startX, scrollTop: startY } = elt;\n        if (moveY)\n          elt.scrollTop += moveY;\n        if (moveX)\n          elt.scrollLeft += moveX;\n        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n      }\n    }\n    let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n    if (/^(fixed|sticky)$/.test(pos))\n      break;\n    parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n  }\n}\nfunction storeScrollPos(view) {\n  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n  let refDOM, refTop;\n  for (let x = (rect.left + rect.right) / 2, y = startY + 1;y < Math.min(innerHeight, rect.bottom); y += 5) {\n    let dom = view.root.elementFromPoint(x, y);\n    if (!dom || dom == view.dom || !view.dom.contains(dom))\n      continue;\n    let localRect = dom.getBoundingClientRect();\n    if (localRect.top >= startY - 20) {\n      refDOM = dom;\n      refTop = localRect.top;\n      break;\n    }\n  }\n  return { refDOM, refTop, stack: scrollStack(view.dom) };\n}\nfunction scrollStack(dom) {\n  let stack = [], doc3 = dom.ownerDocument;\n  for (let cur = dom;cur; cur = parentNode(cur)) {\n    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n    if (dom == doc3)\n      break;\n  }\n  return stack;\n}\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n  for (let i = 0;i < stack.length; i++) {\n    let { dom, top, left } = stack[i];\n    if (dom.scrollTop != top + dTop)\n      dom.scrollTop = top + dTop;\n    if (dom.scrollLeft != left)\n      dom.scrollLeft = left;\n  }\n}\nvar preventScrollSupported = null;\nfunction focusPreventScroll(dom) {\n  if (dom.setActive)\n    return dom.setActive();\n  if (preventScrollSupported)\n    return dom.focus(preventScrollSupported);\n  let stored = scrollStack(dom);\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = { preventScroll: true };\n      return true;\n    }\n  } : undefined);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    restoreScrollStack(stored, 0);\n  }\n}\nfunction findOffsetInNode(node, coords) {\n  let closest, dxClosest = 200000000, coordsClosest, offset = 0;\n  let { top: rowBot, top: rowTop } = coords;\n  let firstBelow, coordsBelow;\n  for (let child = node.firstChild, childIndex = 0;child; child = child.nextSibling, childIndex++) {\n    let rects;\n    if (child.nodeType == 1)\n      rects = child.getClientRects();\n    else if (child.nodeType == 3)\n      rects = textRange(child).getClientRects();\n    else\n      continue;\n    for (let i = 0;i < rects.length; i++) {\n      let rect = rects[i];\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot);\n        rowTop = Math.min(rect.top, rowTop);\n        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? {\n            left: rect.right < coords.left ? rect.right : rect.left,\n            top: coords.top\n          } : coords;\n          if (child.nodeType == 1 && dx)\n            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n          continue;\n        }\n      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n        firstBelow = child;\n        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))\n        offset = childIndex + 1;\n    }\n  }\n  if (!closest && firstBelow) {\n    closest = firstBelow;\n    coordsClosest = coordsBelow;\n    dxClosest = 0;\n  }\n  if (closest && closest.nodeType == 3)\n    return findOffsetInText(closest, coordsClosest);\n  if (!closest || dxClosest && closest.nodeType == 1)\n    return { node, offset };\n  return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n  let len = node.nodeValue.length;\n  let range = document.createRange(), result;\n  for (let i = 0;i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    let rect = singleRect(range, 1);\n    if (rect.top == rect.bottom)\n      continue;\n    if (inRect(coords, rect)) {\n      result = { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n      break;\n    }\n  }\n  range.detach();\n  return result || { node, offset: 0 };\n}\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n  let parent = dom.parentNode;\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    return parent;\n  return dom;\n}\nfunction posFromElement(view, elt, coords) {\n  let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n  if (node.nodeType == 1 && !node.firstChild) {\n    let rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n  return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n  let outsideBlock = -1;\n  for (let cur = node, sawBlock = false;; ) {\n    if (cur == view.dom)\n      break;\n    let desc = view.docView.nearestDesc(cur, true), rect;\n    if (!desc)\n      return null;\n    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)\n          outsideBlock = desc.posBefore;\n        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)\n          outsideBlock = desc.posAfter;\n        sawBlock = true;\n      }\n      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n        return before ? desc.posBefore : desc.posAfter;\n      }\n    }\n    cur = desc.dom.parentNode;\n  }\n  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n  let len = element.childNodes.length;\n  if (len && box.top < box.bottom) {\n    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;; ) {\n      let child = element.childNodes[i];\n      if (child.nodeType == 1) {\n        let rects = child.getClientRects();\n        for (let j = 0;j < rects.length; j++) {\n          let rect = rects[j];\n          if (inRect(coords, rect))\n            return elementFromPoint(child, coords, rect);\n        }\n      }\n      if ((i = (i + 1) % len) == startI)\n        break;\n    }\n  }\n  return element;\n}\nfunction posAtCoords(view, coords) {\n  let doc3 = view.dom.ownerDocument, node, offset = 0;\n  let caret = caretFromPoint(doc3, coords.left, coords.top);\n  if (caret)\n    ({ node, offset } = caret);\n  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);\n  let pos;\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    let box = view.dom.getBoundingClientRect();\n    if (!inRect(coords, box))\n      return null;\n    elt = elementFromPoint(view.dom, coords, box);\n    if (!elt)\n      return null;\n  }\n  if (safari) {\n    for (let p = elt;node && p; p = parentNode(p))\n      if (p.draggable)\n        node = undefined;\n  }\n  elt = targetKludge(elt, coords);\n  if (node) {\n    if (gecko && node.nodeType == 1) {\n      offset = Math.min(offset, node.childNodes.length);\n      if (offset < node.childNodes.length) {\n        let next = node.childNodes[offset], box;\n        if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)\n          offset++;\n      }\n    }\n    let prev;\n    if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top)\n      offset--;\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)\n      pos = view.state.doc.content.size;\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      pos = posFromCaret(view, node, offset, coords);\n  }\n  if (pos == null)\n    pos = posFromElement(view, elt, coords);\n  let desc = view.docView.nearestDesc(elt, true);\n  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n}\nfunction nonZero(rect) {\n  return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n  let rects = target.getClientRects();\n  if (rects.length) {\n    let first = rects[bias < 0 ? 0 : rects.length - 1];\n    if (nonZero(first))\n      return first;\n  }\n  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nvar BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\nfunction coordsAtPos(view, pos, side) {\n  let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n  let supportEmptyRange = webkit || gecko;\n  if (node.nodeType == 3) {\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      let rect = singleRect(textRange(node, offset, offset), side);\n      if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n        if (rectBefore.top == rect.top) {\n          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n          if (rectAfter.top != rect.top)\n            return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n        }\n      }\n      return rect;\n    } else {\n      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n      if (side < 0 && !offset) {\n        to++;\n        takeSide = -1;\n      } else if (side >= 0 && offset == node.nodeValue.length) {\n        from--;\n        takeSide = 1;\n      } else if (side < 0) {\n        from--;\n      } else {\n        to++;\n      }\n      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n    }\n  }\n  let $dom = view.state.doc.resolve(pos - (atom || 0));\n  if (!$dom.parent.inlineContent) {\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1];\n      if (before.nodeType == 1)\n        return flattenH(before.getBoundingClientRect(), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n      let after = node.childNodes[offset];\n      if (after.nodeType == 1)\n        return flattenH(after.getBoundingClientRect(), true);\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0);\n  }\n  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n    let before = node.childNodes[offset - 1];\n    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n    if (target)\n      return flattenV(singleRect(target, 1), false);\n  }\n  if (atom == null && offset < nodeSize(node)) {\n    let after = node.childNodes[offset];\n    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n      after = after.nextSibling;\n    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n    if (target)\n      return flattenV(singleRect(target, -1), true);\n  }\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n  if (rect.width == 0)\n    return rect;\n  let x = left ? rect.left : rect.right;\n  return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nfunction flattenH(rect, top) {\n  if (rect.height == 0)\n    return rect;\n  let y = top ? rect.top : rect.bottom;\n  return { top: y, bottom: y, left: rect.left, right: rect.right };\n}\nfunction withFlushedState(view, state, f) {\n  let viewState = view.state, active = view.root.activeElement;\n  if (viewState != state)\n    view.updateState(state);\n  if (active != view.dom)\n    view.focus();\n  try {\n    return f();\n  } finally {\n    if (viewState != state)\n      view.updateState(viewState);\n    if (active != view.dom && active)\n      active.focus();\n  }\n}\nfunction endOfTextblockVertical(view, state, dir) {\n  let sel = state.selection;\n  let $pos = dir == \"up\" ? sel.$from : sel.$to;\n  return withFlushedState(view, state, () => {\n    let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n    for (;; ) {\n      let nearest = view.docView.nearestDesc(dom, true);\n      if (!nearest)\n        break;\n      if (nearest.node.isBlock) {\n        dom = nearest.contentDOM || nearest.dom;\n        break;\n      }\n      dom = nearest.dom.parentNode;\n    }\n    let coords = coordsAtPos(view, $pos.pos, 1);\n    for (let child = dom.firstChild;child; child = child.nextSibling) {\n      let boxes;\n      if (child.nodeType == 1)\n        boxes = child.getClientRects();\n      else if (child.nodeType == 3)\n        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n      else\n        continue;\n      for (let i = 0;i < boxes.length; i++) {\n        let box = boxes[i];\n        if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n          return false;\n      }\n    }\n    return true;\n  });\n}\nvar maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n  let { $head } = state.selection;\n  if (!$head.parent.isTextblock)\n    return false;\n  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n  let sel = view.domSelection();\n  if (!sel)\n    return $head.pos == $head.start() || $head.pos == $head.end();\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n  return withFlushedState(view, state, () => {\n    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n    let oldBidiLevel = sel.caretBidiLevel;\n    sel.modify(\"move\", dir, \"character\");\n    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n    try {\n      sel.collapse(anchorNode, anchorOffset);\n      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n        sel.extend(oldNode, oldOff);\n    } catch (_) {}\n    if (oldBidiLevel != null)\n      sel.caretBidiLevel = oldBidiLevel;\n    return result;\n  });\n}\nvar cachedState = null;\nvar cachedDir = null;\nvar cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir)\n    return cachedResult;\n  cachedState = state;\n  cachedDir = dir;\n  return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\nvar NOT_DIRTY = 0;\nvar CHILD_DIRTY = 1;\nvar CONTENT_DIRTY = 2;\nvar NODE_DIRTY = 3;\n\nclass ViewDesc {\n  constructor(parent, children, dom, contentDOM) {\n    this.parent = parent;\n    this.children = children;\n    this.dom = dom;\n    this.contentDOM = contentDOM;\n    this.dirty = NOT_DIRTY;\n    dom.pmViewDesc = this;\n  }\n  matchesWidget(widget) {\n    return false;\n  }\n  matchesMark(mark) {\n    return false;\n  }\n  matchesNode(node, outerDeco, innerDeco) {\n    return false;\n  }\n  matchesHack(nodeName) {\n    return false;\n  }\n  parseRule() {\n    return null;\n  }\n  stopEvent(event) {\n    return false;\n  }\n  get size() {\n    let size = 0;\n    for (let i = 0;i < this.children.length; i++)\n      size += this.children[i].size;\n    return size;\n  }\n  get border() {\n    return 0;\n  }\n  destroy() {\n    this.parent = undefined;\n    if (this.dom.pmViewDesc == this)\n      this.dom.pmViewDesc = undefined;\n    for (let i = 0;i < this.children.length; i++)\n      this.children[i].destroy();\n  }\n  posBeforeChild(child) {\n    for (let i = 0, pos = this.posAtStart;; i++) {\n      let cur = this.children[i];\n      if (cur == child)\n        return pos;\n      pos += cur.size;\n    }\n  }\n  get posBefore() {\n    return this.parent.posBeforeChild(this);\n  }\n  get posAtStart() {\n    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n  }\n  get posAfter() {\n    return this.posBefore + this.size;\n  }\n  get posAtEnd() {\n    return this.posAtStart + this.size - 2 * this.border;\n  }\n  localPosFromDOM(dom, offset, bias) {\n    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n      if (bias < 0) {\n        let domBefore, desc;\n        if (dom == this.contentDOM) {\n          domBefore = dom.childNodes[offset - 1];\n        } else {\n          while (dom.parentNode != this.contentDOM)\n            dom = dom.parentNode;\n          domBefore = dom.previousSibling;\n        }\n        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n          domBefore = domBefore.previousSibling;\n        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n      } else {\n        let domAfter, desc;\n        if (dom == this.contentDOM) {\n          domAfter = dom.childNodes[offset];\n        } else {\n          while (dom.parentNode != this.contentDOM)\n            dom = dom.parentNode;\n          domAfter = dom.nextSibling;\n        }\n        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n          domAfter = domAfter.nextSibling;\n        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n      }\n    }\n    let atEnd;\n    if (dom == this.dom && this.contentDOM) {\n      atEnd = offset > domIndex(this.contentDOM);\n    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n    } else if (this.dom.firstChild) {\n      if (offset == 0)\n        for (let search = dom;; search = search.parentNode) {\n          if (search == this.dom) {\n            atEnd = false;\n            break;\n          }\n          if (search.previousSibling)\n            break;\n        }\n      if (atEnd == null && offset == dom.childNodes.length)\n        for (let search = dom;; search = search.parentNode) {\n          if (search == this.dom) {\n            atEnd = true;\n            break;\n          }\n          if (search.nextSibling)\n            break;\n        }\n    }\n    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n  }\n  nearestDesc(dom, onlyNodes = false) {\n    for (let first = true, cur = dom;cur; cur = cur.parentNode) {\n      let desc = this.getDesc(cur), nodeDOM;\n      if (desc && (!onlyNodes || desc.node)) {\n        if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n          first = false;\n        else\n          return desc;\n      }\n    }\n  }\n  getDesc(dom) {\n    let desc = dom.pmViewDesc;\n    for (let cur = desc;cur; cur = cur.parent)\n      if (cur == this)\n        return desc;\n  }\n  posFromDOM(dom, offset, bias) {\n    for (let scan = dom;scan; scan = scan.parentNode) {\n      let desc = this.getDesc(scan);\n      if (desc)\n        return desc.localPosFromDOM(dom, offset, bias);\n    }\n    return -1;\n  }\n  descAt(pos) {\n    for (let i = 0, offset = 0;i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (offset == pos && end != offset) {\n        while (!child.border && child.children.length) {\n          for (let i2 = 0;i2 < child.children.length; i2++) {\n            let inner = child.children[i2];\n            if (inner.size) {\n              child = inner;\n              break;\n            }\n          }\n        }\n        return child;\n      }\n      if (pos < end)\n        return child.descAt(pos - offset - child.border);\n      offset = end;\n    }\n  }\n  domFromPos(pos, side) {\n    if (!this.contentDOM)\n      return { node: this.dom, offset: 0, atom: pos + 1 };\n    let i = 0, offset = 0;\n    for (let curPos = 0;i < this.children.length; i++) {\n      let child = this.children[i], end = curPos + child.size;\n      if (end > pos || child instanceof TrailingHackViewDesc) {\n        offset = pos - curPos;\n        break;\n      }\n      curPos = end;\n    }\n    if (offset)\n      return this.children[i].domFromPos(offset - this.children[i].border, side);\n    for (let prev;i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}\n    if (side <= 0) {\n      let prev, enter = true;\n      for (;; i--, enter = false) {\n        prev = i ? this.children[i - 1] : null;\n        if (!prev || prev.dom.parentNode == this.contentDOM)\n          break;\n      }\n      if (prev && side && enter && !prev.border && !prev.domAtom)\n        return prev.domFromPos(prev.size, side);\n      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n    } else {\n      let next, enter = true;\n      for (;; i++, enter = false) {\n        next = i < this.children.length ? this.children[i] : null;\n        if (!next || next.dom.parentNode == this.contentDOM)\n          break;\n      }\n      if (next && enter && !next.border && !next.domAtom)\n        return next.domFromPos(0, side);\n      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n    }\n  }\n  parseRange(from, to, base = 0) {\n    if (this.children.length == 0)\n      return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n    let fromOffset = -1, toOffset = -1;\n    for (let offset = base, i = 0;; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (fromOffset == -1 && from <= end) {\n        let childBase = offset + child.border;\n        if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))\n          return child.parseRange(from, to, childBase);\n        from = offset;\n        for (let j = i;j > 0; j--) {\n          let prev = this.children[j - 1];\n          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n            fromOffset = domIndex(prev.dom) + 1;\n            break;\n          }\n          from -= prev.size;\n        }\n        if (fromOffset == -1)\n          fromOffset = 0;\n      }\n      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n        to = end;\n        for (let j = i + 1;j < this.children.length; j++) {\n          let next = this.children[j];\n          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n            toOffset = domIndex(next.dom);\n            break;\n          }\n          to += next.size;\n        }\n        if (toOffset == -1)\n          toOffset = this.contentDOM.childNodes.length;\n        break;\n      }\n      offset = end;\n    }\n    return { node: this.contentDOM, from, to, fromOffset, toOffset };\n  }\n  emptyChildAt(side) {\n    if (this.border || !this.contentDOM || !this.children.length)\n      return false;\n    let child = this.children[side < 0 ? 0 : this.children.length - 1];\n    return child.size == 0 || child.emptyChildAt(side);\n  }\n  domAfterPos(pos) {\n    let { node, offset } = this.domFromPos(pos, 0);\n    if (node.nodeType != 1 || offset == node.childNodes.length)\n      throw new RangeError(\"No node after pos \" + pos);\n    return node.childNodes[offset];\n  }\n  setSelection(anchor, head, view, force = false) {\n    let from = Math.min(anchor, head), to = Math.max(anchor, head);\n    for (let i = 0, offset = 0;i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (from > offset && to < end)\n        return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n      offset = end;\n    }\n    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n    let domSel = view.root.getSelection();\n    let selRange = view.domSelectionRange();\n    let brKludge = false;\n    if ((gecko || safari) && anchor == head) {\n      let { node, offset } = anchorDOM;\n      if (node.nodeType == 3) {\n        brKludge = !!(offset && node.nodeValue[offset - 1] == `\n`);\n        if (brKludge && offset == node.nodeValue.length) {\n          for (let scan = node, after;scan; scan = scan.parentNode) {\n            if (after = scan.nextSibling) {\n              if (after.nodeName == \"BR\")\n                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n              break;\n            }\n            let desc = scan.pmViewDesc;\n            if (desc && desc.node && desc.node.isBlock)\n              break;\n          }\n        }\n      } else {\n        let prev = node.childNodes[offset - 1];\n        brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n      }\n    }\n    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n      let after = selRange.focusNode.childNodes[selRange.focusOffset];\n      if (after && after.contentEditable == \"false\")\n        force = true;\n    }\n    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))\n      return;\n    let domSelExtended = false;\n    if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n      domSel.collapse(anchorDOM.node, anchorDOM.offset);\n      try {\n        if (anchor != head)\n          domSel.extend(headDOM.node, headDOM.offset);\n        domSelExtended = true;\n      } catch (_) {}\n    }\n    if (!domSelExtended) {\n      if (anchor > head) {\n        let tmp = anchorDOM;\n        anchorDOM = headDOM;\n        headDOM = tmp;\n      }\n      let range = document.createRange();\n      range.setEnd(headDOM.node, headDOM.offset);\n      range.setStart(anchorDOM.node, anchorDOM.offset);\n      domSel.removeAllRanges();\n      domSel.addRange(range);\n    }\n  }\n  ignoreMutation(mutation) {\n    return !this.contentDOM && mutation.type != \"selection\";\n  }\n  get contentLost() {\n    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n  }\n  markDirty(from, to) {\n    for (let offset = 0, i = 0;i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n        let startInside = offset + child.border, endInside = end - child.border;\n        if (from >= startInside && to <= endInside) {\n          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n          if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))\n            child.dirty = NODE_DIRTY;\n          else\n            child.markDirty(from - startInside, to - startInside);\n          return;\n        } else {\n          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n        }\n      }\n      offset = end;\n    }\n    this.dirty = CONTENT_DIRTY;\n  }\n  markParentsDirty() {\n    let level = 1;\n    for (let node = this.parent;node; node = node.parent, level++) {\n      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n      if (node.dirty < dirty)\n        node.dirty = dirty;\n    }\n  }\n  get domAtom() {\n    return false;\n  }\n  get ignoreForCoords() {\n    return false;\n  }\n  get ignoreForSelection() {\n    return false;\n  }\n  isText(text) {\n    return false;\n  }\n}\n\nclass WidgetViewDesc extends ViewDesc {\n  constructor(parent, widget, view, pos) {\n    let self, dom = widget.type.toDOM;\n    if (typeof dom == \"function\")\n      dom = dom(view, () => {\n        if (!self)\n          return pos;\n        if (self.parent)\n          return self.parent.posBeforeChild(self);\n      });\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        let wrap2 = document.createElement(\"span\");\n        wrap2.appendChild(dom);\n        dom = wrap2;\n      }\n      dom.contentEditable = \"false\";\n      dom.classList.add(\"ProseMirror-widget\");\n    }\n    super(parent, [], dom, null);\n    this.widget = widget;\n    this.widget = widget;\n    self = this;\n  }\n  matchesWidget(widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n  }\n  parseRule() {\n    return { ignore: true };\n  }\n  stopEvent(event) {\n    let stop = this.widget.spec.stopEvent;\n    return stop ? stop(event) : false;\n  }\n  ignoreMutation(mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n  }\n  destroy() {\n    this.widget.type.destroy(this.dom);\n    super.destroy();\n  }\n  get domAtom() {\n    return true;\n  }\n  get ignoreForSelection() {\n    return !!this.widget.type.spec.relaxedSide;\n  }\n  get side() {\n    return this.widget.type.side;\n  }\n}\n\nclass CompositionViewDesc extends ViewDesc {\n  constructor(parent, dom, textDOM, text) {\n    super(parent, [], dom, null);\n    this.textDOM = textDOM;\n    this.text = text;\n  }\n  get size() {\n    return this.text.length;\n  }\n  localPosFromDOM(dom, offset) {\n    if (dom != this.textDOM)\n      return this.posAtStart + (offset ? this.size : 0);\n    return this.posAtStart + offset;\n  }\n  domFromPos(pos) {\n    return { node: this.textDOM, offset: pos };\n  }\n  ignoreMutation(mut) {\n    return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n  }\n}\n\nclass MarkViewDesc extends ViewDesc {\n  constructor(parent, mark, dom, contentDOM, spec) {\n    super(parent, [], dom, contentDOM);\n    this.mark = mark;\n    this.spec = spec;\n  }\n  static create(parent, mark, inline, view) {\n    let custom = view.nodeViews[mark.type.name];\n    let spec = custom && custom(mark, view, inline);\n    if (!spec || !spec.dom)\n      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n  }\n  parseRule() {\n    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)\n      return null;\n    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };\n  }\n  matchesMark(mark) {\n    return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n  }\n  markDirty(from, to) {\n    super.markDirty(from, to);\n    if (this.dirty != NOT_DIRTY) {\n      let parent = this.parent;\n      while (!parent.node)\n        parent = parent.parent;\n      if (parent.dirty < this.dirty)\n        parent.dirty = this.dirty;\n      this.dirty = NOT_DIRTY;\n    }\n  }\n  slice(from, to, view) {\n    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);\n    let nodes = this.children, size = this.size;\n    if (to < size)\n      nodes = replaceNodes(nodes, to, size, view);\n    if (from > 0)\n      nodes = replaceNodes(nodes, 0, from, view);\n    for (let i = 0;i < nodes.length; i++)\n      nodes[i].parent = copy2;\n    copy2.children = nodes;\n    return copy2;\n  }\n  ignoreMutation(mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n  }\n  destroy() {\n    if (this.spec.destroy)\n      this.spec.destroy();\n    super.destroy();\n  }\n}\n\nclass NodeViewDesc extends ViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    super(parent, [], dom, contentDOM);\n    this.node = node;\n    this.outerDeco = outerDeco;\n    this.innerDeco = innerDeco;\n    this.nodeDOM = nodeDOM;\n  }\n  static create(parent, node, outerDeco, innerDeco, view, pos) {\n    let custom = view.nodeViews[node.type.name], descObj;\n    let spec = custom && custom(node, view, () => {\n      if (!descObj)\n        return pos;\n      if (descObj.parent)\n        return descObj.parent.posBeforeChild(descObj);\n    }, outerDeco, innerDeco);\n    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n    if (node.isText) {\n      if (!dom)\n        dom = document.createTextNode(node.text);\n      else if (dom.nodeType != 3)\n        throw new RangeError(\"Text must be rendered as a DOM text node\");\n    } else if (!dom) {\n      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n      ({ dom, contentDOM } = spec2);\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n      if (!dom.hasAttribute(\"contenteditable\"))\n        dom.contentEditable = \"false\";\n      if (node.type.spec.draggable)\n        dom.draggable = true;\n    }\n    let nodeDOM = dom;\n    dom = applyOuterDeco(dom, outerDeco, node);\n    if (spec)\n      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n    else if (node.isText)\n      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n    else\n      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n  }\n  parseRule() {\n    if (this.node.type.spec.reparseInView)\n      return null;\n    let rule = { node: this.node.type.name, attrs: this.node.attrs };\n    if (this.node.type.whitespace == \"pre\")\n      rule.preserveWhitespace = \"full\";\n    if (!this.contentDOM) {\n      rule.getContent = () => this.node.content;\n    } else if (!this.contentLost) {\n      rule.contentElement = this.contentDOM;\n    } else {\n      for (let i = this.children.length - 1;i >= 0; i--) {\n        let child = this.children[i];\n        if (this.dom.contains(child.dom.parentNode)) {\n          rule.contentElement = child.dom.parentNode;\n          break;\n        }\n      }\n      if (!rule.contentElement)\n        rule.getContent = () => Fragment.empty;\n    }\n    return rule;\n  }\n  matchesNode(node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n  }\n  get size() {\n    return this.node.nodeSize;\n  }\n  get border() {\n    return this.node.isLeaf ? 0 : 1;\n  }\n  updateChildren(view, pos) {\n    let inline = this.node.inlineContent, off = pos;\n    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n    let localComposition = composition && composition.pos > -1 ? composition : null;\n    let compositionInChild = composition && composition.pos < 0;\n    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n      if (widget.spec.marks)\n        updater.syncToMarks(widget.spec.marks, inline, view, i);\n      else if (widget.type.side >= 0 && !insideNode)\n        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view, i);\n      updater.placeWidget(widget, view, off);\n    }, (child, outerDeco, innerDeco, i) => {\n      updater.syncToMarks(child.marks, inline, view, i);\n      let compIndex;\n      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))\n        ;\n      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))\n        ;\n      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))\n        ;\n      else {\n        updater.addNode(child, outerDeco, innerDeco, view, off);\n      }\n      off += child.nodeSize;\n    });\n    updater.syncToMarks([], inline, view, 0);\n    if (this.node.isTextblock)\n      updater.addTextblockHacks();\n    updater.destroyRest();\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      if (localComposition)\n        this.protectLocalComposition(view, localComposition);\n      renderDescs(this.contentDOM, this.children, view);\n      if (ios)\n        iosHacks(this.dom);\n    }\n  }\n  localCompositionInfo(view, pos) {\n    let { from, to } = view.state.selection;\n    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size)\n      return null;\n    let textNode = view.input.compositionNode;\n    if (!textNode || !this.dom.contains(textNode.parentNode))\n      return null;\n    if (this.node.inlineContent) {\n      let text = textNode.nodeValue;\n      let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n      return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n    } else {\n      return { node: textNode, pos: -1, text: \"\" };\n    }\n  }\n  protectLocalComposition(view, { node, pos, text }) {\n    if (this.getDesc(node))\n      return;\n    let topNode = node;\n    for (;; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM)\n        break;\n      while (topNode.previousSibling)\n        topNode.parentNode.removeChild(topNode.previousSibling);\n      while (topNode.nextSibling)\n        topNode.parentNode.removeChild(topNode.nextSibling);\n      if (topNode.pmViewDesc)\n        topNode.pmViewDesc = undefined;\n    }\n    let desc = new CompositionViewDesc(this, topNode, node, text);\n    view.input.compositionNodes.push(desc);\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n  }\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))\n      return false;\n    this.updateInner(node, outerDeco, innerDeco, view);\n    return true;\n  }\n  updateInner(node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco);\n    this.node = node;\n    this.innerDeco = innerDeco;\n    if (this.contentDOM)\n      this.updateChildren(view, this.posAtStart);\n    this.dirty = NOT_DIRTY;\n  }\n  updateOuterDeco(outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco))\n      return;\n    let needsWrap = this.nodeDOM.nodeType != 1;\n    let oldDOM = this.dom;\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = undefined;\n      this.dom.pmViewDesc = this;\n    }\n    this.outerDeco = outerDeco;\n  }\n  selectNode() {\n    if (this.nodeDOM.nodeType == 1) {\n      this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n      if (this.contentDOM || !this.node.type.spec.draggable)\n        this.nodeDOM.draggable = true;\n    }\n  }\n  deselectNode() {\n    if (this.nodeDOM.nodeType == 1) {\n      this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n      if (this.contentDOM || !this.node.type.spec.draggable)\n        this.nodeDOM.removeAttribute(\"draggable\");\n    }\n  }\n  get domAtom() {\n    return this.node.isAtom;\n  }\n}\nfunction docViewDesc(doc3, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc3);\n  let docView = new NodeViewDesc(undefined, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);\n  if (docView.contentDOM)\n    docView.updateChildren(view, 0);\n  return docView;\n}\n\nclass TextViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n  }\n  parseRule() {\n    let skip = this.nodeDOM.parentNode;\n    while (skip && skip != this.dom && !skip.pmIsDeco)\n      skip = skip.parentNode;\n    return { skip: skip || true };\n  }\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))\n      return false;\n    this.updateOuterDeco(outerDeco);\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text;\n      if (view.trackWrites == this.nodeDOM)\n        view.trackWrites = null;\n    }\n    this.node = node;\n    this.dirty = NOT_DIRTY;\n    return true;\n  }\n  inParent() {\n    let parentDOM = this.parent.contentDOM;\n    for (let n = this.nodeDOM;n; n = n.parentNode)\n      if (n == parentDOM)\n        return true;\n    return false;\n  }\n  domFromPos(pos) {\n    return { node: this.nodeDOM, offset: pos };\n  }\n  localPosFromDOM(dom, offset, bias) {\n    if (dom == this.nodeDOM)\n      return this.posAtStart + Math.min(offset, this.node.text.length);\n    return super.localPosFromDOM(dom, offset, bias);\n  }\n  ignoreMutation(mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\";\n  }\n  slice(from, to, view) {\n    let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n  }\n  markDirty(from, to) {\n    super.markDirty(from, to);\n    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n      this.dirty = NODE_DIRTY;\n  }\n  get domAtom() {\n    return false;\n  }\n  isText(text) {\n    return this.node.text == text;\n  }\n}\n\nclass TrailingHackViewDesc extends ViewDesc {\n  parseRule() {\n    return { ignore: true };\n  }\n  matchesHack(nodeName) {\n    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n  }\n  get domAtom() {\n    return true;\n  }\n  get ignoreForCoords() {\n    return this.dom.nodeName == \"IMG\";\n  }\n}\n\nclass CustomNodeViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n    this.spec = spec;\n  }\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY)\n      return false;\n    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n      let result = this.spec.update(node, outerDeco, innerDeco);\n      if (result)\n        this.updateInner(node, outerDeco, innerDeco, view);\n      return result;\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false;\n    } else {\n      return super.update(node, outerDeco, innerDeco, view);\n    }\n  }\n  selectNode() {\n    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n  }\n  deselectNode() {\n    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n  }\n  setSelection(anchor, head, view, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);\n  }\n  destroy() {\n    if (this.spec.destroy)\n      this.spec.destroy();\n    super.destroy();\n  }\n  stopEvent(event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n  }\n  ignoreMutation(mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n  }\n}\nfunction renderDescs(parentDOM, descs, view) {\n  let dom = parentDOM.firstChild, written = false;\n  for (let i = 0;i < descs.length; i++) {\n    let desc = descs[i], childDOM = desc.dom;\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) {\n        dom = rm(dom);\n        written = true;\n      }\n      dom = dom.nextSibling;\n    } else {\n      written = true;\n      parentDOM.insertBefore(childDOM, dom);\n    }\n    if (desc instanceof MarkViewDesc) {\n      let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n      renderDescs(desc.contentDOM, desc.children, view);\n      dom = pos ? pos.nextSibling : parentDOM.firstChild;\n    }\n  }\n  while (dom) {\n    dom = rm(dom);\n    written = true;\n  }\n  if (written && view.trackWrites == parentDOM)\n    view.trackWrites = null;\n}\nvar OuterDecoLevel = function(nodeName) {\n  if (nodeName)\n    this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nvar noDeco = [new OuterDecoLevel];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0)\n    return noDeco;\n  let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n  for (let i = 0;i < outerDeco.length; i++) {\n    let attrs = outerDeco[i].type.attrs;\n    if (!attrs)\n      continue;\n    if (attrs.nodeName)\n      result.push(top = new OuterDecoLevel(attrs.nodeName));\n    for (let name in attrs) {\n      let val = attrs[name];\n      if (val == null)\n        continue;\n      if (needsWrap && result.length == 1)\n        result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n      if (name == \"class\")\n        top.class = (top.class ? top.class + \" \" : \"\") + val;\n      else if (name == \"style\")\n        top.style = (top.style ? top.style + \";\" : \"\") + val;\n      else if (name != \"nodeName\")\n        top[name] = val;\n    }\n  }\n  return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  if (prevComputed == noDeco && curComputed == noDeco)\n    return nodeDOM;\n  let curDOM = nodeDOM;\n  for (let i = 0;i < curComputed.length; i++) {\n    let deco = curComputed[i], prev = prevComputed[i];\n    if (i) {\n      let parent;\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n        curDOM = parent;\n      } else {\n        parent = document.createElement(deco.nodeName);\n        parent.pmIsDeco = true;\n        parent.appendChild(curDOM);\n        prev = noDeco[0];\n        curDOM = parent;\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco);\n  }\n  return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n  for (let name in prev)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      dom.removeAttribute(name);\n  for (let name in cur)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n      dom.setAttribute(name, cur[name]);\n  if (prev.class != cur.class) {\n    let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n    let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n    for (let i = 0;i < prevList.length; i++)\n      if (curList.indexOf(prevList[i]) == -1)\n        dom.classList.remove(prevList[i]);\n    for (let i = 0;i < curList.length; i++)\n      if (prevList.indexOf(curList[i]) == -1)\n        dom.classList.add(curList[i]);\n    if (dom.classList.length == 0)\n      dom.removeAttribute(\"class\");\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n      while (m = prop.exec(prev.style))\n        dom.style.removeProperty(m[1]);\n    }\n    if (cur.style)\n      dom.style.cssText += cur.style;\n  }\n}\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length)\n    return false;\n  for (let i = 0;i < a.length; i++)\n    if (!a[i].type.eq(b[i].type))\n      return false;\n  return true;\n}\nfunction rm(dom) {\n  let next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\n\nclass ViewTreeUpdater {\n  constructor(top, lock, view) {\n    this.lock = lock;\n    this.view = view;\n    this.index = 0;\n    this.stack = [];\n    this.changed = false;\n    this.top = top;\n    this.preMatch = preMatch(top.node.content, top);\n  }\n  destroyBetween(start, end) {\n    if (start == end)\n      return;\n    for (let i = start;i < end; i++)\n      this.top.children[i].destroy();\n    this.top.children.splice(start, end - start);\n    this.changed = true;\n  }\n  destroyRest() {\n    this.destroyBetween(this.index, this.top.children.length);\n  }\n  syncToMarks(marks, inline, view, parentIndex) {\n    let keep = 0, depth = this.stack.length >> 1;\n    let maxKeep = Math.min(depth, marks.length);\n    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n      keep++;\n    while (keep < depth) {\n      this.destroyRest();\n      this.top.dirty = NOT_DIRTY;\n      this.index = this.stack.pop();\n      this.top = this.stack.pop();\n      depth--;\n    }\n    while (depth < marks.length) {\n      this.stack.push(this.top, this.index + 1);\n      let found2 = -1, scanTo = this.top.children.length;\n      if (parentIndex < this.preMatch.index)\n        scanTo = Math.min(this.index + 3, scanTo);\n      for (let i = this.index;i < scanTo; i++) {\n        let next = this.top.children[i];\n        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n          found2 = i;\n          break;\n        }\n      }\n      if (found2 > -1) {\n        if (found2 > this.index) {\n          this.changed = true;\n          this.destroyBetween(this.index, found2);\n        }\n        this.top = this.top.children[this.index];\n      } else {\n        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n        this.top.children.splice(this.index, 0, markDesc);\n        this.top = markDesc;\n        this.changed = true;\n      }\n      this.index = 0;\n      depth++;\n    }\n  }\n  findNodeMatch(node, outerDeco, innerDeco, index) {\n    let found2 = -1, targetDesc;\n    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n      found2 = this.top.children.indexOf(targetDesc, this.index);\n    } else {\n      for (let i = this.index, e = Math.min(this.top.children.length, i + 5);i < e; i++) {\n        let child = this.top.children[i];\n        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n          found2 = i;\n          break;\n        }\n      }\n    }\n    if (found2 < 0)\n      return false;\n    this.destroyBetween(this.index, found2);\n    this.index++;\n    return true;\n  }\n  updateNodeAt(node, outerDeco, innerDeco, index, view) {\n    let child = this.top.children[index];\n    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n      child.dirty = CONTENT_DIRTY;\n    if (!child.update(node, outerDeco, innerDeco, view))\n      return false;\n    this.destroyBetween(this.index, index);\n    this.index++;\n    return true;\n  }\n  findIndexWithChild(domNode) {\n    for (;; ) {\n      let parent = domNode.parentNode;\n      if (!parent)\n        return -1;\n      if (parent == this.top.contentDOM) {\n        let desc = domNode.pmViewDesc;\n        if (desc)\n          for (let i = this.index;i < this.top.children.length; i++) {\n            if (this.top.children[i] == desc)\n              return i;\n          }\n        return -1;\n      }\n      domNode = parent;\n    }\n  }\n  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n    for (let i = this.index;i < this.top.children.length; i++) {\n      let next = this.top.children[i];\n      if (next instanceof NodeViewDesc) {\n        let preMatch = this.preMatch.matched.get(next);\n        if (preMatch != null && preMatch != index)\n          return false;\n        let nextDOM = next.dom, updated;\n        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n        if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n          this.destroyBetween(this.index, i);\n          if (next.dom != nextDOM)\n            this.changed = true;\n          this.index++;\n          return true;\n        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n          this.destroyBetween(this.index, i);\n          this.top.children[this.index] = updated;\n          if (updated.contentDOM) {\n            updated.dirty = CONTENT_DIRTY;\n            updated.updateChildren(view, pos + 1);\n            updated.dirty = NOT_DIRTY;\n          }\n          this.changed = true;\n          this.index++;\n          return true;\n        }\n        break;\n      }\n    }\n    return false;\n  }\n  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))\n      return null;\n    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n    if (wrapper.contentDOM) {\n      wrapper.children = next.children;\n      next.children = [];\n      for (let ch of wrapper.children)\n        ch.parent = wrapper;\n    }\n    next.destroy();\n    return wrapper;\n  }\n  addNode(node, outerDeco, innerDeco, view, pos) {\n    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n    if (desc.contentDOM)\n      desc.updateChildren(view, pos + 1);\n    this.top.children.splice(this.index++, 0, desc);\n    this.changed = true;\n  }\n  placeWidget(widget, view, pos) {\n    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n      this.index++;\n    } else {\n      let desc = new WidgetViewDesc(this.top, widget, view, pos);\n      this.top.children.splice(this.index++, 0, desc);\n      this.changed = true;\n    }\n  }\n  addTextblockHacks() {\n    let lastChild = this.top.children[this.index - 1], parent = this.top;\n    while (lastChild instanceof MarkViewDesc) {\n      parent = lastChild;\n      lastChild = parent.children[parent.children.length - 1];\n    }\n    if (!lastChild || !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n        this.addHackNode(\"IMG\", parent);\n      this.addHackNode(\"BR\", this.top);\n    }\n  }\n  addHackNode(nodeName, parent) {\n    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n      this.index++;\n    } else {\n      let dom = document.createElement(nodeName);\n      if (nodeName == \"IMG\") {\n        dom.className = \"ProseMirror-separator\";\n        dom.alt = \"\";\n      }\n      if (nodeName == \"BR\")\n        dom.className = \"ProseMirror-trailingBreak\";\n      let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n      if (parent != this.top)\n        parent.children.push(hack);\n      else\n        parent.children.splice(this.index++, 0, hack);\n      this.changed = true;\n    }\n  }\n  isLocked(node) {\n    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n  }\n}\nfunction preMatch(frag, parentDesc) {\n  let curDesc = parentDesc, descI = curDesc.children.length;\n  let fI = frag.childCount, matched = new Map, matches2 = [];\n  outer:\n    while (fI > 0) {\n      let desc;\n      for (;; ) {\n        if (descI) {\n          let next = curDesc.children[descI - 1];\n          if (next instanceof MarkViewDesc) {\n            curDesc = next;\n            descI = next.children.length;\n          } else {\n            desc = next;\n            descI--;\n            break;\n          }\n        } else if (curDesc == parentDesc) {\n          break outer;\n        } else {\n          descI = curDesc.parent.children.indexOf(curDesc);\n          curDesc = curDesc.parent;\n        }\n      }\n      let node = desc.node;\n      if (!node)\n        continue;\n      if (node != frag.child(fI - 1))\n        break;\n      --fI;\n      matched.set(desc, fI);\n      matches2.push(desc);\n    }\n  return { index: fI, matched, matches: matches2.reverse() };\n}\nfunction compareSide(a, b) {\n  return a.type.side - b.type.side;\n}\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  let locals = deco.locals(parent), offset = 0;\n  if (locals.length == 0) {\n    for (let i = 0;i < parent.childCount; i++) {\n      let child = parent.child(i);\n      onNode(child, locals, deco.forChild(offset, child), i);\n      offset += child.nodeSize;\n    }\n    return;\n  }\n  let decoIndex = 0, active = [], restNode = null;\n  for (let parentIndex = 0;; ) {\n    let widget, widgets;\n    while (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      let next = locals[decoIndex++];\n      if (next.widget) {\n        if (!widget)\n          widget = next;\n        else\n          (widgets || (widgets = [widget])).push(next);\n      }\n    }\n    if (widget) {\n      if (widgets) {\n        widgets.sort(compareSide);\n        for (let i = 0;i < widgets.length; i++)\n          onWidget(widgets[i], parentIndex, !!restNode);\n      } else {\n        onWidget(widget, parentIndex, !!restNode);\n      }\n    }\n    let child, index;\n    if (restNode) {\n      index = -1;\n      child = restNode;\n      restNode = null;\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex;\n      child = parent.child(parentIndex++);\n    } else {\n      break;\n    }\n    for (let i = 0;i < active.length; i++)\n      if (active[i].to <= offset)\n        active.splice(i--, 1);\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      active.push(locals[decoIndex++]);\n    let end = offset + child.nodeSize;\n    if (child.isText) {\n      let cutAt = end;\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n        cutAt = locals[decoIndex].from;\n      for (let i = 0;i < active.length; i++)\n        if (active[i].to < cutAt)\n          cutAt = active[i].to;\n      if (cutAt < end) {\n        restNode = child.cut(cutAt - offset);\n        child = child.cut(0, cutAt - offset);\n        end = cutAt;\n        index = -1;\n      }\n    } else {\n      while (decoIndex < locals.length && locals[decoIndex].to < end)\n        decoIndex++;\n    }\n    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();\n    onNode(child, outerDeco, deco.forChild(offset, child), index);\n    offset = end;\n  }\n}\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    let oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\nfunction findTextInFragment(frag, text, from, to) {\n  for (let i = 0, pos = 0;i < frag.childCount && pos <= to; ) {\n    let child = frag.child(i++), childStart = pos;\n    pos += child.nodeSize;\n    if (!child.isText)\n      continue;\n    let str = child.text;\n    while (i < frag.childCount) {\n      let next = frag.child(i++);\n      pos += next.nodeSize;\n      if (!next.isText)\n        break;\n      str += next.text;\n    }\n    if (pos >= from) {\n      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)\n        return to - text.length;\n      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n      if (found2 >= 0 && found2 + text.length + childStart >= from)\n        return childStart + found2;\n      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)\n        return to;\n    }\n  }\n  return -1;\n}\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  let result = [];\n  for (let i = 0, off = 0;i < nodes.length; i++) {\n    let child = nodes[i], start = off, end = off += child.size;\n    if (start >= to || end <= from) {\n      result.push(child);\n    } else {\n      if (start < from)\n        result.push(child.slice(0, from - start, view));\n      if (replacement) {\n        result.push(replacement);\n        replacement = undefined;\n      }\n      if (end > to)\n        result.push(child.slice(to - start, child.size, view));\n    }\n  }\n  return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n  let domSel = view.domSelectionRange(), doc3 = view.state.doc;\n  if (!domSel.focusNode)\n    return null;\n  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n  if (head < 0)\n    return null;\n  let $head = doc3.resolve(head), anchor, selection;\n  if (selectionCollapsed(domSel)) {\n    anchor = head;\n    while (nearestDesc && !nearestDesc.node)\n      nearestDesc = nearestDesc.parent;\n    let nearestDescNode = nearestDesc.node;\n    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      let pos = nearestDesc.posBefore;\n      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));\n    }\n  } else {\n    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n      let min = head, max = head;\n      for (let i = 0;i < domSel.rangeCount; i++) {\n        let range = domSel.getRangeAt(i);\n        min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n        max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n      }\n      if (min < 0)\n        return null;\n      [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];\n      $head = doc3.resolve(head);\n    } else {\n      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n    }\n    if (anchor < 0)\n      return null;\n  }\n  let $anchor = doc3.resolve(anchor);\n  if (!selection) {\n    let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n    selection = selectionBetween(view, $anchor, $head, bias);\n  }\n  return selection;\n}\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n  let sel = view.state.selection;\n  syncNodeSelection(view, sel);\n  if (!editorOwnsSelection(view))\n    return;\n  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n      view.input.mouseDown.delayedSelectionSync = true;\n      view.domObserver.setCurSelection();\n      return;\n    }\n  }\n  view.domObserver.disconnectSelection();\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view);\n  } else {\n    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        resetEditableFrom = temporarilyEditableNear(view, sel.from);\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        resetEditableTo = temporarilyEditableNear(view, sel.to);\n    }\n    view.docView.setSelection(anchor, head, view, force);\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom)\n        resetEditable(resetEditableFrom);\n      if (resetEditableTo)\n        resetEditable(resetEditableTo);\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\");\n      if (\"onselectionchange\" in document)\n        removeClassOnSelectionChange(view);\n    }\n  }\n  view.domObserver.setCurSelection();\n  view.domObserver.connectSelection();\n}\nvar brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n  let { node, offset } = view.docView.domFromPos(pos, 0);\n  let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n  let before = offset ? node.childNodes[offset - 1] : null;\n  if (safari && after && after.contentEditable == \"false\")\n    return setEditable(after);\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after)\n      return setEditable(after);\n    else if (before)\n      return setEditable(before);\n  }\n}\nfunction setEditable(element) {\n  element.contentEditable = \"true\";\n  if (safari && element.draggable) {\n    element.draggable = false;\n    element.wasDraggable = true;\n  }\n  return element;\n}\nfunction resetEditable(element) {\n  element.contentEditable = \"false\";\n  if (element.wasDraggable) {\n    element.draggable = true;\n    element.wasDraggable = null;\n  }\n}\nfunction removeClassOnSelectionChange(view) {\n  let doc3 = view.dom.ownerDocument;\n  doc3.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n  let domSel = view.domSelectionRange();\n  let { anchorNode: node, anchorOffset: offset } = domSel;\n  doc3.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc3.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n      setTimeout(() => {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          view.dom.classList.remove(\"ProseMirror-hideselection\");\n      }, 20);\n    }\n  });\n}\nfunction selectCursorWrapper(view) {\n  let domSel = view.domSelection();\n  if (!domSel)\n    return;\n  let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n  if (img)\n    domSel.collapse(node.parentNode, domIndex(node) + 1);\n  else\n    domSel.collapse(node, 0);\n  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n    node.disabled = true;\n    node.disabled = false;\n  }\n}\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    let desc = view.docView.descAt(sel.from);\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view);\n      if (desc)\n        desc.selectNode();\n      view.lastSelectedViewDesc = desc;\n    }\n  } else {\n    clearNodeSelection(view);\n  }\n}\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      view.lastSelectedViewDesc.deselectNode();\n    view.lastSelectedViewDesc = undefined;\n  }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n  if (view.editable && !view.hasFocus())\n    return false;\n  return hasSelection(view);\n}\nfunction hasSelection(view) {\n  let sel = view.domSelectionRange();\n  if (!sel.anchorNode)\n    return false;\n  try {\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n  } catch (_) {\n    return false;\n  }\n}\nfunction anchorInRightPlace(view) {\n  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n  let domSel = view.domSelectionRange();\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n  let { $anchor, $head } = state.selection;\n  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n  return $start && Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n  return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n  let sel = view.state.selection;\n  if (sel instanceof TextSelection) {\n    if (mods.indexOf(\"s\") > -1) {\n      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n      if (!node || node.isText || !node.isLeaf)\n        return false;\n      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n      return apply(view, new TextSelection(sel.$anchor, $newHead));\n    } else if (!sel.empty) {\n      return false;\n    } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n      let next = moveSelectionBlock(view.state, dir);\n      if (next && next instanceof NodeSelection)\n        return apply(view, next);\n      return false;\n    } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n      if (!node || node.isText)\n        return false;\n      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n        return false;\n      if (NodeSelection.isSelectable(node)) {\n        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n      } else if (webkit) {\n        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n      } else {\n        return false;\n      }\n    }\n  } else if (sel instanceof NodeSelection && sel.node.isInline) {\n    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));\n  } else {\n    let next = moveSelectionBlock(view.state, dir);\n    if (next)\n      return apply(view, next);\n    return false;\n  }\n}\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n  let desc = dom.pmViewDesc;\n  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\nfunction skipIgnoredNodesBefore(view) {\n  let sel = view.domSelectionRange();\n  let { focusNode: node, focusOffset: offset } = sel;\n  if (!node)\n    return;\n  let moveNode, moveOffset, force = false;\n  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))\n    force = true;\n  for (;; ) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break;\n      } else {\n        let before = node.childNodes[offset - 1];\n        if (isIgnorable(before, -1)) {\n          moveNode = node;\n          moveOffset = --offset;\n        } else if (before.nodeType == 3) {\n          node = before;\n          offset = node.nodeValue.length;\n        } else\n          break;\n      }\n    } else if (isBlockNode(node)) {\n      break;\n    } else {\n      let prev = node.previousSibling;\n      while (prev && isIgnorable(prev, -1)) {\n        moveNode = node.parentNode;\n        moveOffset = domIndex(prev);\n        prev = prev.previousSibling;\n      }\n      if (!prev) {\n        node = node.parentNode;\n        if (node == view.dom)\n          break;\n        offset = 0;\n      } else {\n        node = prev;\n        offset = nodeLen(node);\n      }\n    }\n  }\n  if (force)\n    setSelFocus(view, node, offset);\n  else if (moveNode)\n    setSelFocus(view, moveNode, moveOffset);\n}\nfunction skipIgnoredNodesAfter(view) {\n  let sel = view.domSelectionRange();\n  let { focusNode: node, focusOffset: offset } = sel;\n  if (!node)\n    return;\n  let len = nodeLen(node);\n  let moveNode, moveOffset;\n  for (;; ) {\n    if (offset < len) {\n      if (node.nodeType != 1)\n        break;\n      let after = node.childNodes[offset];\n      if (isIgnorable(after, 1)) {\n        moveNode = node;\n        moveOffset = ++offset;\n      } else\n        break;\n    } else if (isBlockNode(node)) {\n      break;\n    } else {\n      let next = node.nextSibling;\n      while (next && isIgnorable(next, 1)) {\n        moveNode = next.parentNode;\n        moveOffset = domIndex(next) + 1;\n        next = next.nextSibling;\n      }\n      if (!next) {\n        node = node.parentNode;\n        if (node == view.dom)\n          break;\n        offset = len = 0;\n      } else {\n        node = next;\n        offset = 0;\n        len = nodeLen(node);\n      }\n    }\n  }\n  if (moveNode)\n    setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n  let desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n  while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {\n    offset = domIndex(node) + 1;\n    node = node.parentNode;\n  }\n  while (node && offset < node.childNodes.length) {\n    let next = node.childNodes[offset];\n    if (next.nodeType == 3)\n      return next;\n    if (next.nodeType == 1 && next.contentEditable == \"false\")\n      break;\n    node = next;\n    offset = 0;\n  }\n}\nfunction textNodeBefore(node, offset) {\n  while (node && !offset && !hasBlockDesc(node)) {\n    offset = domIndex(node);\n    node = node.parentNode;\n  }\n  while (node && offset) {\n    let next = node.childNodes[offset - 1];\n    if (next.nodeType == 3)\n      return next;\n    if (next.nodeType == 1 && next.contentEditable == \"false\")\n      break;\n    node = next;\n    offset = node.childNodes.length;\n  }\n}\nfunction setSelFocus(view, node, offset) {\n  if (node.nodeType != 3) {\n    let before, after;\n    if (after = textNodeAfter(node, offset)) {\n      node = after;\n      offset = 0;\n    } else if (before = textNodeBefore(node, offset)) {\n      node = before;\n      offset = before.nodeValue.length;\n    }\n  }\n  let sel = view.domSelection();\n  if (!sel)\n    return;\n  if (selectionCollapsed(sel)) {\n    let range = document.createRange();\n    range.setEnd(node, offset);\n    range.setStart(node, offset);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  } else if (sel.extend) {\n    sel.extend(node, offset);\n  }\n  view.domObserver.setCurSelection();\n  let { state } = view;\n  setTimeout(() => {\n    if (view.state == state)\n      selectionToDOM(view);\n  }, 50);\n}\nfunction findDirection(view, pos) {\n  let $pos = view.state.doc.resolve(pos);\n  if (!(chrome || windows) && $pos.parent.inlineContent) {\n    let coords = view.coordsAtPos(pos);\n    if (pos > $pos.start()) {\n      let before = view.coordsAtPos(pos - 1);\n      let mid = (before.top + before.bottom) / 2;\n      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n        return before.left < coords.left ? \"ltr\" : \"rtl\";\n    }\n    if (pos < $pos.end()) {\n      let after = view.coordsAtPos(pos + 1);\n      let mid = (after.top + after.bottom) / 2;\n      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n        return after.left > coords.left ? \"ltr\" : \"rtl\";\n    }\n  }\n  let computed = getComputedStyle(view.dom).direction;\n  return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\nfunction selectVertically(view, dir, mods) {\n  let sel = view.state.selection;\n  if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n    return false;\n  if (mac && mods.indexOf(\"m\") > -1)\n    return false;\n  let { $from, $to } = sel;\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    let next = moveSelectionBlock(view.state, dir);\n    if (next && next instanceof NodeSelection)\n      return apply(view, next);\n  }\n  if (!$from.parent.inlineContent) {\n    let side = dir < 0 ? $from : $to;\n    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);\n    return beyond ? apply(view, beyond) : false;\n  }\n  return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof TextSelection))\n    return true;\n  let { $head, $anchor, empty } = view.state.selection;\n  if (!$head.sameParent($anchor))\n    return true;\n  if (!empty)\n    return false;\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n    return true;\n  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n  if (nextNode && !nextNode.isText) {\n    let tr = view.state.tr;\n    if (dir < 0)\n      tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n    else\n      tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n    view.dispatch(tr);\n    return true;\n  }\n  return false;\n}\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop();\n  node.contentEditable = state;\n  view.domObserver.start();\n}\nfunction safariDownArrowBug(view) {\n  if (!safari || view.state.selection.$head.parentOffset > 0)\n    return false;\n  let { focusNode, focusOffset } = view.domSelectionRange();\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    let child = focusNode.firstChild;\n    switchEditable(view, child, \"true\");\n    setTimeout(() => switchEditable(view, child, \"false\"), 20);\n  }\n  return false;\n}\nfunction getMods(event) {\n  let result = \"\";\n  if (event.ctrlKey)\n    result += \"c\";\n  if (event.metaKey)\n    result += \"m\";\n  if (event.altKey)\n    result += \"a\";\n  if (event.shiftKey)\n    result += \"s\";\n  return result;\n}\nfunction captureKeyDown(view, event) {\n  let code = event.keyCode, mods = getMods(event);\n  if (code == 8 || mac && code == 72 && mods == \"c\") {\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n  } else if (code == 13 || code == 27) {\n    return true;\n  } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n    let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n  } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n    let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n  } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n  } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n  } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n    return true;\n  }\n  return false;\n}\nfunction serializeForClipboard(view, slice) {\n  view.someProp(\"transformCopied\", (f) => {\n    slice = f(slice, view);\n  });\n  let context = [], { content, openStart, openEnd } = slice;\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--;\n    openEnd--;\n    let node = content.firstChild;\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n    content = node.content;\n  }\n  let serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema);\n  let doc3 = detachedDoc(), wrap2 = doc3.createElement(\"div\");\n  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));\n  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (let i = needsWrap.length - 1;i >= 0; i--) {\n      let wrapper = doc3.createElement(needsWrap[i]);\n      while (wrap2.firstChild)\n        wrapper.appendChild(wrap2.firstChild);\n      wrap2.appendChild(wrapper);\n      wrappers++;\n    }\n    firstChild = wrap2.firstChild;\n  }\n  if (firstChild && firstChild.nodeType == 1)\n    firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n  let text = view.someProp(\"clipboardTextSerializer\", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, `\n\n`);\n  return { dom: wrap2, text, slice };\n}\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n  let inCode = $context.parent.type.spec.code;\n  let dom, slice;\n  if (!html && !text)\n    return null;\n  let asText = !!text && (plainText || inCode || !html);\n  if (asText) {\n    view.someProp(\"transformPastedText\", (f) => {\n      text = f(text, inCode || plainText, view);\n    });\n    if (inCode) {\n      slice = new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, `\n`))), 0, 0);\n      view.someProp(\"transformPasted\", (f) => {\n        slice = f(slice, view, true);\n      });\n      return slice;\n    }\n    let parsed = view.someProp(\"clipboardTextParser\", (f) => f(text, $context, plainText, view));\n    if (parsed) {\n      slice = parsed;\n    } else {\n      let marks = $context.marks();\n      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);\n      dom = document.createElement(\"div\");\n      text.split(/(?:\\r\\n?|\\n)+/).forEach((block) => {\n        let p = dom.appendChild(document.createElement(\"p\"));\n        if (block)\n          p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n      });\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", (f) => {\n      html = f(html, view);\n    });\n    dom = readHTML(html);\n    if (webkit)\n      restoreReplacedSpaces(dom);\n  }\n  let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n  let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n  if (sliceData && sliceData[3])\n    for (let i = +sliceData[3];i > 0; i--) {\n      let child = dom.firstChild;\n      while (child && child.nodeType != 1)\n        child = child.nextSibling;\n      if (!child)\n        break;\n      dom = child;\n    }\n  if (!slice) {\n    let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n    slice = parser.parseSlice(dom, {\n      preserveWhitespace: !!(asText || sliceData),\n      context: $context,\n      ruleFromNode(dom2) {\n        if (dom2.nodeName == \"BR\" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))\n          return { ignore: true };\n        return null;\n      }\n    });\n  }\n  if (sliceData) {\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n  } else {\n    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n    if (slice.openStart || slice.openEnd) {\n      let openStart = 0, openEnd = 0;\n      for (let node = slice.content.firstChild;openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}\n      for (let node = slice.content.lastChild;openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {}\n      slice = closeSlice(slice, openStart, openEnd);\n    }\n  }\n  view.someProp(\"transformPasted\", (f) => {\n    slice = f(slice, view, asText);\n  });\n  return slice;\n}\nvar inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2)\n    return fragment;\n  for (let d = $context.depth;d >= 0; d--) {\n    let parent = $context.node(d);\n    let match = parent.contentMatchAt($context.index(d));\n    let lastWrap, result = [];\n    fragment.forEach((node) => {\n      if (!result)\n        return;\n      let wrap2 = match.findWrapping(node.type), inLast;\n      if (!wrap2)\n        return result = null;\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast;\n      } else {\n        if (result.length)\n          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n        let wrapped = withWrappers(node, wrap2);\n        result.push(wrapped);\n        match = match.matchType(wrapped.type);\n        lastWrap = wrap2;\n      }\n    });\n    if (result)\n      return Fragment.from(result);\n  }\n  return fragment;\n}\nfunction withWrappers(node, wrap2, from = 0) {\n  for (let i = wrap2.length - 1;i >= from; i--)\n    node = wrap2[i].create(null, Fragment.from(node));\n  return node;\n}\nfunction addToSibling(wrap2, lastWrap, node, sibling, depth) {\n  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {\n    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);\n    if (inner)\n      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n    let match = sibling.contentMatchAt(sibling.childCount);\n    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))\n      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));\n  }\n}\nfunction closeRight(node, depth) {\n  if (depth == 0)\n    return node;\n  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);\n  return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n  if (fragment.childCount > 1)\n    openEnd = 0;\n  if (depth < to - 1)\n    inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n  if (depth >= from)\n    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n  if (openEnd < slice.openEnd)\n    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n  return slice;\n}\nvar wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n};\nvar _detachedDoc = null;\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nvar _policy = null;\nfunction maybeWrapTrusted(html) {\n  let trustedTypes = window.trustedTypes;\n  if (!trustedTypes)\n    return html;\n  if (!_policy)\n    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", { createHTML: (s) => s });\n  return _policy.createHTML(html);\n}\nfunction readHTML(html) {\n  let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n  if (metas)\n    html = html.slice(metas[0].length);\n  let elt = detachedDoc().createElement(\"div\");\n  let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap2;\n  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    html = wrap2.map((n) => \"<\" + n + \">\").join(\"\") + html + wrap2.map((n) => \"</\" + n + \">\").reverse().join(\"\");\n  elt.innerHTML = maybeWrapTrusted(html);\n  if (wrap2)\n    for (let i = 0;i < wrap2.length; i++)\n      elt = elt.querySelector(wrap2[i]) || elt;\n  return elt;\n}\nfunction restoreReplacedSpaces(dom) {\n  let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n  for (let i = 0;i < nodes.length; i++) {\n    let node = nodes[i];\n    if (node.childNodes.length == 1 && node.textContent == \"¬†\" && node.parentNode)\n      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n  }\n}\nfunction addContext(slice, context) {\n  if (!slice.size)\n    return slice;\n  let schema = slice.content.firstChild.type.schema, array;\n  try {\n    array = JSON.parse(context);\n  } catch (e) {\n    return slice;\n  }\n  let { content, openStart, openEnd } = slice;\n  for (let i = array.length - 2;i >= 0; i -= 2) {\n    let type = schema.nodes[array[i]];\n    if (!type || type.hasRequiredAttrs())\n      break;\n    content = Fragment.from(type.create(array[i + 1], content));\n    openStart++;\n    openEnd++;\n  }\n  return new Slice(content, openStart, openEnd);\n}\nvar handlers = {};\nvar editHandlers = {};\nvar passiveHandlers = { touchstart: true, touchmove: true };\n\nclass InputState {\n  constructor() {\n    this.shiftKey = false;\n    this.mouseDown = null;\n    this.lastKeyCode = null;\n    this.lastKeyCodeTime = 0;\n    this.lastClick = { time: 0, x: 0, y: 0, type: \"\", button: 0 };\n    this.lastSelectionOrigin = null;\n    this.lastSelectionTime = 0;\n    this.lastIOSEnter = 0;\n    this.lastIOSEnterFallbackTimeout = -1;\n    this.lastFocus = 0;\n    this.lastTouch = 0;\n    this.lastChromeDelete = 0;\n    this.composing = false;\n    this.compositionNode = null;\n    this.composingTimeout = -1;\n    this.compositionNodes = [];\n    this.compositionEndedAt = -200000000;\n    this.compositionID = 1;\n    this.badSafariComposition = false;\n    this.compositionPendingChanges = 0;\n    this.domChangeCount = 0;\n    this.eventHandlers = Object.create(null);\n    this.hideSelectionGuard = null;\n  }\n}\nfunction initInput(view) {\n  for (let event in handlers) {\n    let handler = handlers[event];\n    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {\n      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))\n        handler(view, event2);\n    }, passiveHandlers[event] ? { passive: true } : undefined);\n  }\n  if (safari)\n    view.dom.addEventListener(\"input\", () => null);\n  ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n  view.input.lastSelectionOrigin = origin;\n  view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n  view.domObserver.stop();\n  for (let type in view.input.eventHandlers)\n    view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n  clearTimeout(view.input.composingTimeout);\n  clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", (currentHandlers) => {\n    for (let type in currentHandlers)\n      if (!view.input.eventHandlers[type])\n        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));\n  });\n}\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", (handlers2) => {\n    let handler = handlers2[event.type];\n    return handler ? handler(view, event) || event.defaultPrevented : false;\n  });\n}\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles)\n    return true;\n  if (event.defaultPrevented)\n    return false;\n  for (let node = event.target;node != view.dom; node = node.parentNode)\n    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))\n      return false;\n  return true;\n}\nfunction dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))\n    handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event) => {\n  let event = _event;\n  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n  if (inOrNearComposition(view, event))\n    return;\n  view.input.lastKeyCode = event.keyCode;\n  view.input.lastKeyCodeTime = Date.now();\n  if (android && chrome && event.keyCode == 13)\n    return;\n  if (event.keyCode != 229)\n    view.domObserver.forceFlush();\n  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    let now = Date.now();\n    view.input.lastIOSEnter = now;\n    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n      if (view.input.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")));\n        view.input.lastIOSEnter = 0;\n      }\n    }, 200);\n  } else if (view.someProp(\"handleKeyDown\", (f) => f(view, event)) || captureKeyDown(view, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"key\");\n  }\n};\neditHandlers.keyup = (view, event) => {\n  if (event.keyCode == 16)\n    view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event) => {\n  let event = _event;\n  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)\n    return;\n  if (view.someProp(\"handleKeyPress\", (f) => f(view, event))) {\n    event.preventDefault();\n    return;\n  }\n  let sel = view.state.selection;\n  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    let text = String.fromCharCode(event.charCode);\n    let deflt = () => view.state.tr.insertText(text).scrollIntoView();\n    if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))\n      view.dispatch(deflt());\n    event.preventDefault();\n  }\n};\nfunction eventCoords(event) {\n  return { left: event.clientX, top: event.clientY };\n}\nfunction isNear(event, click) {\n  let dx = click.x - event.clientX, dy = click.y - event.clientY;\n  return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1)\n    return false;\n  let $pos = view.state.doc.resolve(inside);\n  for (let i = $pos.depth + 1;i > 0; i--) {\n    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n      return true;\n  }\n  return false;\n}\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused)\n    view.focus();\n  if (view.state.selection.eq(selection))\n    return;\n  let tr = view.state.tr.setSelection(selection);\n  if (origin == \"pointer\")\n    tr.setMeta(\"pointer\", true);\n  view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1)\n    return false;\n  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n  if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\");\n    return true;\n  }\n  return false;\n}\nfunction selectClickedNode(view, inside) {\n  if (inside == -1)\n    return false;\n  let sel = view.state.selection, selectedNode, selectAt;\n  if (sel instanceof NodeSelection)\n    selectedNode = sel.node;\n  let $pos = view.state.doc.resolve(inside);\n  for (let i = $pos.depth + 1;i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    if (NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        selectAt = $pos.before(sel.$from.depth);\n      else\n        selectAt = $pos.before(i);\n      break;\n    }\n  }\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f) => f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n  if (event.button != 0)\n    return false;\n  let doc3 = view.state.doc;\n  if (inside == -1) {\n    if (doc3.inlineContent) {\n      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), \"pointer\");\n      return true;\n    }\n    return false;\n  }\n  let $pos = doc3.resolve(inside);\n  for (let i = $pos.depth + 1;i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    let nodePos = $pos.before(i);\n    if (node.inlineContent)\n      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n    else if (NodeSelection.isSelectable(node))\n      updateSelection(view, NodeSelection.create(doc3, nodePos), \"pointer\");\n    else\n      continue;\n    return true;\n  }\n}\nfunction forceDOMFlush(view) {\n  return endComposition(view);\n}\nvar selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event) => {\n  let event = _event;\n  view.input.shiftKey = event.shiftKey;\n  let flushed = forceDOMFlush(view);\n  let now = Date.now(), type = \"singleClick\";\n  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {\n    if (view.input.lastClick.type == \"singleClick\")\n      type = \"doubleClick\";\n    else if (view.input.lastClick.type == \"doubleClick\")\n      type = \"tripleClick\";\n  }\n  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };\n  let pos = view.posAtCoords(eventCoords(event));\n  if (!pos)\n    return;\n  if (type == \"singleClick\") {\n    if (view.input.mouseDown)\n      view.input.mouseDown.done();\n    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n  } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"pointer\");\n  }\n};\n\nclass MouseDown {\n  constructor(view, pos, event, flushed) {\n    this.view = view;\n    this.pos = pos;\n    this.event = event;\n    this.flushed = flushed;\n    this.delayedSelectionSync = false;\n    this.mightDrag = null;\n    this.startDoc = view.state.doc;\n    this.selectNode = !!event[selectNodeModifier];\n    this.allowDefault = event.shiftKey;\n    let targetNode, targetPos;\n    if (pos.inside > -1) {\n      targetNode = view.state.doc.nodeAt(pos.inside);\n      targetPos = pos.inside;\n    } else {\n      let $pos = view.state.doc.resolve(pos.pos);\n      targetNode = $pos.parent;\n      targetPos = $pos.depth ? $pos.before() : 0;\n    }\n    const target = flushed ? null : event.target;\n    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n    this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n    let { selection } = view.state;\n    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n      this.mightDrag = {\n        node: targetNode,\n        pos: targetPos,\n        addAttr: !!(this.target && !this.target.draggable),\n        setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n      };\n    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n      this.view.domObserver.stop();\n      if (this.mightDrag.addAttr)\n        this.target.draggable = true;\n      if (this.mightDrag.setUneditable)\n        setTimeout(() => {\n          if (this.view.input.mouseDown == this)\n            this.target.setAttribute(\"contentEditable\", \"false\");\n        }, 20);\n      this.view.domObserver.start();\n    }\n    view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    setSelectionOrigin(view, \"pointer\");\n  }\n  done() {\n    this.view.root.removeEventListener(\"mouseup\", this.up);\n    this.view.root.removeEventListener(\"mousemove\", this.move);\n    if (this.mightDrag && this.target) {\n      this.view.domObserver.stop();\n      if (this.mightDrag.addAttr)\n        this.target.removeAttribute(\"draggable\");\n      if (this.mightDrag.setUneditable)\n        this.target.removeAttribute(\"contentEditable\");\n      this.view.domObserver.start();\n    }\n    if (this.delayedSelectionSync)\n      setTimeout(() => selectionToDOM(this.view));\n    this.view.input.mouseDown = null;\n  }\n  up(event) {\n    this.done();\n    if (!this.view.dom.contains(event.target))\n      return;\n    let pos = this.pos;\n    if (this.view.state.doc != this.startDoc)\n      pos = this.view.posAtCoords(eventCoords(event));\n    this.updateAllowDefault(event);\n    if (this.allowDefault || !pos) {\n      setSelectionOrigin(this.view, \"pointer\");\n    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n      event.preventDefault();\n    } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n      event.preventDefault();\n    } else {\n      setSelectionOrigin(this.view, \"pointer\");\n    }\n  }\n  move(event) {\n    this.updateAllowDefault(event);\n    setSelectionOrigin(this.view, \"pointer\");\n    if (event.buttons == 0)\n      this.done();\n  }\n  updateAllowDefault(event) {\n    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))\n      this.allowDefault = true;\n  }\n}\nhandlers.touchstart = (view) => {\n  view.input.lastTouch = Date.now();\n  forceDOMFlush(view);\n  setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view) => {\n  view.input.lastTouch = Date.now();\n  setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view) => forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n  if (view.composing)\n    return true;\n  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n    view.input.compositionEndedAt = -200000000;\n    return true;\n  }\n  return false;\n}\nvar timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view) => {\n  if (!view.composing) {\n    view.domObserver.flush();\n    let { state } = view, $pos = state.selection.$to;\n    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false) || chrome && windows && selectionBeforeUneditable(view))) {\n      view.markCursor = view.state.storedMarks || $pos.marks();\n      endComposition(view, true);\n      view.markCursor = null;\n    } else {\n      endComposition(view, !state.selection.empty);\n      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        let sel = view.domSelectionRange();\n        for (let { focusNode: node, focusOffset: offset } = sel;node && node.nodeType == 1 && offset != 0; ) {\n          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n          if (!before)\n            break;\n          if (before.nodeType == 3) {\n            let sel2 = view.domSelection();\n            if (sel2)\n              sel2.collapse(before, before.nodeValue.length);\n            break;\n          } else {\n            node = before;\n            offset = -1;\n          }\n        }\n      }\n    }\n    view.input.composing = true;\n  }\n  scheduleComposeEnd(view, timeoutComposition);\n};\nfunction selectionBeforeUneditable(view) {\n  let { focusNode, focusOffset } = view.domSelectionRange();\n  if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length)\n    return false;\n  let next = focusNode.childNodes[focusOffset];\n  return next.nodeType == 1 && next.contentEditable == \"false\";\n}\neditHandlers.compositionend = (view, event) => {\n  if (view.composing) {\n    view.input.composing = false;\n    view.input.compositionEndedAt = event.timeStamp;\n    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n    view.input.compositionNode = null;\n    if (view.input.badSafariComposition)\n      view.domObserver.forceFlush();\n    else if (view.input.compositionPendingChanges)\n      Promise.resolve().then(() => view.domObserver.flush());\n    view.input.compositionID++;\n    scheduleComposeEnd(view, 20);\n  }\n};\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.input.composingTimeout);\n  if (delay > -1)\n    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n}\nfunction clearComposition(view) {\n  if (view.composing) {\n    view.input.composing = false;\n    view.input.compositionEndedAt = timestampFromCustomEvent();\n  }\n  while (view.input.compositionNodes.length > 0)\n    view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n  let sel = view.domSelectionRange();\n  if (!sel.focusNode)\n    return null;\n  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n  if (textBefore && textAfter && textBefore != textAfter) {\n    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n    if (textBefore == lastChanged || textAfter == lastChanged)\n      return lastChanged;\n    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n      return textAfter;\n    } else if (view.input.compositionNode == textAfter) {\n      let descBefore = textBefore.pmViewDesc;\n      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))\n        return textAfter;\n    }\n  }\n  return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n  let event = document.createEvent(\"Event\");\n  event.initEvent(\"event\", true, true);\n  return event.timeStamp;\n}\nfunction endComposition(view, restarting = false) {\n  if (android && view.domObserver.flushingSoon >= 0)\n    return;\n  view.domObserver.forceFlush();\n  clearComposition(view);\n  if (restarting || view.docView && view.docView.dirty) {\n    let sel = selectionFromDOM(view), cur = view.state.selection;\n    if (sel && !sel.eq(cur))\n      view.dispatch(view.state.tr.setSelection(sel));\n    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)\n      view.dispatch(view.state.tr.deleteSelection());\n    else\n      view.updateState(view.state);\n    return true;\n  }\n  return false;\n}\nfunction captureCopy(view, dom) {\n  if (!view.dom.parentNode)\n    return;\n  let wrap2 = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n  wrap2.appendChild(dom);\n  wrap2.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  let sel = getSelection(), range = document.createRange();\n  range.selectNodeContents(dom);\n  view.dom.blur();\n  sel.removeAllRanges();\n  sel.addRange(range);\n  setTimeout(() => {\n    if (wrap2.parentNode)\n      wrap2.parentNode.removeChild(wrap2);\n    view.focus();\n  }, 50);\n}\nvar brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event) => {\n  let event = _event;\n  let sel = view.state.selection, cut = event.type == \"cut\";\n  if (sel.empty)\n    return;\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n  if (data) {\n    event.preventDefault();\n    data.clearData();\n    data.setData(\"text/html\", dom.innerHTML);\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, dom);\n  }\n  if (cut)\n    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n  if (!view.dom.parentNode)\n    return;\n  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n  if (!plainText)\n    target.contentEditable = \"true\";\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n  setTimeout(() => {\n    view.focus();\n    if (target.parentNode)\n      target.parentNode.removeChild(target);\n    if (plainText)\n      doPaste(view, target.value, null, plain, event);\n    else\n      doPaste(view, target.textContent, target.innerHTML, plain, event);\n  }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n  let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n  if (view.someProp(\"handlePaste\", (f) => f(view, event, slice || Slice.empty)))\n    return true;\n  if (!slice)\n    return false;\n  let singleNode = sliceSingleNode(slice);\n  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n  return true;\n}\nfunction getText(clipboardData) {\n  let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n  if (text)\n    return text;\n  let uris = clipboardData.getData(\"text/uri-list\");\n  return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event) => {\n  let event = _event;\n  if (view.composing && !android)\n    return;\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n  if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event))\n    event.preventDefault();\n  else\n    capturePaste(view, event);\n};\n\nclass Dragging {\n  constructor(slice, move, node) {\n    this.slice = slice;\n    this.move = move;\n    this.node = node;\n  }\n}\nvar dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nfunction dragMoves(view, event) {\n  let moves = view.someProp(\"dragCopies\", (test) => !test(event));\n  return moves != null ? moves : !event[dragCopyModifier];\n}\nhandlers.dragstart = (view, _event) => {\n  let event = _event;\n  let mouseDown = view.input.mouseDown;\n  if (mouseDown)\n    mouseDown.done();\n  if (!event.dataTransfer)\n    return;\n  let sel = view.state.selection;\n  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n  let node;\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))\n    ;\n  else if (mouseDown && mouseDown.mightDrag) {\n    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n  } else if (event.target && event.target.nodeType == 1) {\n    let desc = view.docView.nearestDesc(event.target, true);\n    if (desc && desc.node.type.spec.draggable && desc != view.docView)\n      node = NodeSelection.create(view.state.doc, desc.posBefore);\n  }\n  let draggedSlice = (node || view.state.selection).content();\n  let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)\n    event.dataTransfer.clearData();\n  event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n  event.dataTransfer.effectAllowed = \"copyMove\";\n  if (!brokenClipboardAPI)\n    event.dataTransfer.setData(\"text/plain\", text);\n  view.dragging = new Dragging(slice, dragMoves(view, event), node);\n};\nhandlers.dragend = (view) => {\n  let dragging = view.dragging;\n  window.setTimeout(() => {\n    if (view.dragging == dragging)\n      view.dragging = null;\n  }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\neditHandlers.drop = (view, event) => {\n  try {\n    handleDrop(view, event, view.dragging);\n  } finally {\n    view.dragging = null;\n  }\n};\nfunction handleDrop(view, event, dragging) {\n  if (!event.dataTransfer)\n    return;\n  let eventPos = view.posAtCoords(eventCoords(event));\n  if (!eventPos)\n    return;\n  let $mouse = view.state.doc.resolve(eventPos.pos);\n  let slice = dragging && dragging.slice;\n  if (slice) {\n    view.someProp(\"transformPasted\", (f) => {\n      slice = f(slice, view, false);\n    });\n  } else {\n    slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n  }\n  let move = !!(dragging && dragMoves(view, event));\n  if (view.someProp(\"handleDrop\", (f) => f(view, event, slice || Slice.empty, move))) {\n    event.preventDefault();\n    return;\n  }\n  if (!slice)\n    return;\n  event.preventDefault();\n  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n  if (insertPos == null)\n    insertPos = $mouse.pos;\n  let tr = view.state.tr;\n  if (move) {\n    let { node } = dragging;\n    if (node)\n      node.replace(tr);\n    else\n      tr.deleteSelection();\n  }\n  let pos = tr.mapping.map(insertPos);\n  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n  let beforeInsert = tr.doc;\n  if (isNode)\n    tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n  else\n    tr.replaceRange(pos, pos, slice);\n  if (tr.doc.eq(beforeInsert))\n    return;\n  let $pos = tr.doc.resolve(pos);\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new NodeSelection($pos));\n  } else {\n    let end = tr.mapping.map(insertPos);\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n  }\n  view.focus();\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n}\nhandlers.focus = (view) => {\n  view.input.lastFocus = Date.now();\n  if (!view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.add(\"ProseMirror-focused\");\n    view.domObserver.start();\n    view.focused = true;\n    setTimeout(() => {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n        selectionToDOM(view);\n    }, 20);\n  }\n};\nhandlers.blur = (view, _event) => {\n  let event = _event;\n  if (view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.remove(\"ProseMirror-focused\");\n    view.domObserver.start();\n    if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n      view.domObserver.currentSelection.clear();\n    view.focused = false;\n  }\n};\nhandlers.beforeinput = (view, _event) => {\n  let event = _event;\n  if (chrome && android && event.inputType == \"deleteContentBackward\") {\n    view.domObserver.flushSoon();\n    let { domChangeCount } = view.input;\n    setTimeout(() => {\n      if (view.input.domChangeCount != domChangeCount)\n        return;\n      view.dom.blur();\n      view.focus();\n      if (view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\"))))\n        return;\n      let { $cursor } = view.state.selection;\n      if ($cursor && $cursor.pos > 0)\n        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n    }, 50);\n  }\n};\nfor (let prop in editHandlers)\n  handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n  if (a == b)\n    return true;\n  for (let p in a)\n    if (a[p] !== b[p])\n      return false;\n  for (let p in b)\n    if (!(p in a))\n      return false;\n  return true;\n}\n\nclass WidgetType {\n  constructor(toDOM, spec) {\n    this.toDOM = toDOM;\n    this.spec = spec || noSpec;\n    this.side = this.spec.side || 0;\n  }\n  map(mapping, span, offset, oldOffset) {\n    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n    return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n  }\n  valid() {\n    return true;\n  }\n  eq(other) {\n    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n  }\n  destroy(node) {\n    if (this.spec.destroy)\n      this.spec.destroy(node);\n  }\n}\n\nclass InlineType {\n  constructor(attrs, spec) {\n    this.attrs = attrs;\n    this.spec = spec || noSpec;\n  }\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n    return from >= to ? null : new Decoration(from, to, this);\n  }\n  valid(_, span) {\n    return span.from < span.to;\n  }\n  eq(other) {\n    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n  }\n  static is(span) {\n    return span.type instanceof InlineType;\n  }\n  destroy() {}\n}\n\nclass NodeType2 {\n  constructor(attrs, spec) {\n    this.attrs = attrs;\n    this.spec = spec || noSpec;\n  }\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.mapResult(span.from + oldOffset, 1);\n    if (from.deleted)\n      return null;\n    let to = mapping.mapResult(span.to + oldOffset, -1);\n    if (to.deleted || to.pos <= from.pos)\n      return null;\n    return new Decoration(from.pos - offset, to.pos - offset, this);\n  }\n  valid(node, span) {\n    let { index, offset } = node.content.findIndex(span.from), child;\n    return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n  }\n  eq(other) {\n    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n  }\n  destroy() {}\n}\n\nclass Decoration {\n  constructor(from, to, type) {\n    this.from = from;\n    this.to = to;\n    this.type = type;\n  }\n  copy(from, to) {\n    return new Decoration(from, to, this.type);\n  }\n  eq(other, offset = 0) {\n    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n  }\n  map(mapping, offset, oldOffset) {\n    return this.type.map(mapping, this, offset, oldOffset);\n  }\n  static widget(pos, toDOM, spec) {\n    return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n  }\n  static inline(from, to, attrs, spec) {\n    return new Decoration(from, to, new InlineType(attrs, spec));\n  }\n  static node(from, to, attrs, spec) {\n    return new Decoration(from, to, new NodeType2(attrs, spec));\n  }\n  get spec() {\n    return this.type.spec;\n  }\n  get inline() {\n    return this.type instanceof InlineType;\n  }\n  get widget() {\n    return this.type instanceof WidgetType;\n  }\n}\nvar none = [];\nvar noSpec = {};\n\nclass DecorationSet {\n  constructor(local, children) {\n    this.local = local.length ? local : none;\n    this.children = children.length ? children : none;\n  }\n  static create(doc3, decorations) {\n    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;\n  }\n  find(start, end, predicate) {\n    let result = [];\n    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n    return result;\n  }\n  findInner(start, end, result, offset, predicate) {\n    for (let i = 0;i < this.local.length; i++) {\n      let span = this.local[i];\n      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n        result.push(span.copy(span.from + offset, span.to + offset));\n    }\n    for (let i = 0;i < this.children.length; i += 3) {\n      if (this.children[i] < end && this.children[i + 1] > start) {\n        let childOff = this.children[i] + 1;\n        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n      }\n    }\n  }\n  map(mapping, doc3, options) {\n    if (this == empty || mapping.maps.length == 0)\n      return this;\n    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);\n  }\n  mapInner(mapping, node, offset, oldOffset, options) {\n    let newLocal;\n    for (let i = 0;i < this.local.length; i++) {\n      let mapped = this.local[i].map(mapping, offset, oldOffset);\n      if (mapped && mapped.type.valid(node, mapped))\n        (newLocal || (newLocal = [])).push(mapped);\n      else if (options.onRemove)\n        options.onRemove(this.local[i].spec);\n    }\n    if (this.children.length)\n      return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n    else\n      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n  }\n  add(doc3, decorations) {\n    if (!decorations.length)\n      return this;\n    if (this == empty)\n      return DecorationSet.create(doc3, decorations);\n    return this.addInner(doc3, decorations, 0);\n  }\n  addInner(doc3, decorations, offset) {\n    let children, childIndex = 0;\n    doc3.forEach((childNode, childOffset) => {\n      let baseOffset = childOffset + offset, found2;\n      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))\n        return;\n      if (!children)\n        children = this.children.slice();\n      while (childIndex < children.length && children[childIndex] < childOffset)\n        childIndex += 3;\n      if (children[childIndex] == childOffset)\n        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);\n      else\n        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));\n      childIndex += 3;\n    });\n    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n    for (let i = 0;i < local.length; i++)\n      if (!local[i].type.valid(doc3, local[i]))\n        local.splice(i--, 1);\n    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n  }\n  remove(decorations) {\n    if (decorations.length == 0 || this == empty)\n      return this;\n    return this.removeInner(decorations, 0);\n  }\n  removeInner(decorations, offset) {\n    let children = this.children, local = this.local;\n    for (let i = 0;i < children.length; i += 3) {\n      let found2;\n      let from = children[i] + offset, to = children[i + 1] + offset;\n      for (let j = 0, span;j < decorations.length; j++)\n        if (span = decorations[j]) {\n          if (span.from > from && span.to < to) {\n            decorations[j] = null;\n            (found2 || (found2 = [])).push(span);\n          }\n        }\n      if (!found2)\n        continue;\n      if (children == this.children)\n        children = this.children.slice();\n      let removed = children[i + 2].removeInner(found2, from + 1);\n      if (removed != empty) {\n        children[i + 2] = removed;\n      } else {\n        children.splice(i, 3);\n        i -= 3;\n      }\n    }\n    if (local.length) {\n      for (let i = 0, span;i < decorations.length; i++)\n        if (span = decorations[i]) {\n          for (let j = 0;j < local.length; j++)\n            if (local[j].eq(span, offset)) {\n              if (local == this.local)\n                local = this.local.slice();\n              local.splice(j--, 1);\n            }\n        }\n    }\n    if (children == this.children && local == this.local)\n      return this;\n    return local.length || children.length ? new DecorationSet(local, children) : empty;\n  }\n  forChild(offset, node) {\n    if (this == empty)\n      return this;\n    if (node.isLeaf)\n      return DecorationSet.empty;\n    let child, local;\n    for (let i = 0;i < this.children.length; i += 3)\n      if (this.children[i] >= offset) {\n        if (this.children[i] == offset)\n          child = this.children[i + 2];\n        break;\n      }\n    let start = offset + 1, end = start + node.content.size;\n    for (let i = 0;i < this.local.length; i++) {\n      let dec = this.local[i];\n      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n        if (from < to)\n          (local || (local = [])).push(dec.copy(from, to));\n      }\n    }\n    if (local) {\n      let localSet = new DecorationSet(local.sort(byPos), none);\n      return child ? new DecorationGroup([localSet, child]) : localSet;\n    }\n    return child || empty;\n  }\n  eq(other) {\n    if (this == other)\n      return true;\n    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)\n      return false;\n    for (let i = 0;i < this.local.length; i++)\n      if (!this.local[i].eq(other.local[i]))\n        return false;\n    for (let i = 0;i < this.children.length; i += 3)\n      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))\n        return false;\n    return true;\n  }\n  locals(node) {\n    return removeOverlap(this.localsInner(node));\n  }\n  localsInner(node) {\n    if (this == empty)\n      return none;\n    if (node.inlineContent || !this.local.some(InlineType.is))\n      return this.local;\n    let result = [];\n    for (let i = 0;i < this.local.length; i++) {\n      if (!(this.local[i].type instanceof InlineType))\n        result.push(this.local[i]);\n    }\n    return result;\n  }\n  forEachSet(f) {\n    f(this);\n  }\n}\nDecorationSet.empty = new DecorationSet([], []);\nDecorationSet.removeOverlap = removeOverlap;\nvar empty = DecorationSet.empty;\n\nclass DecorationGroup {\n  constructor(members) {\n    this.members = members;\n  }\n  map(mapping, doc3) {\n    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));\n    return DecorationGroup.from(mappedDecos);\n  }\n  forChild(offset, child) {\n    if (child.isLeaf)\n      return DecorationSet.empty;\n    let found2 = [];\n    for (let i = 0;i < this.members.length; i++) {\n      let result = this.members[i].forChild(offset, child);\n      if (result == empty)\n        continue;\n      if (result instanceof DecorationGroup)\n        found2 = found2.concat(result.members);\n      else\n        found2.push(result);\n    }\n    return DecorationGroup.from(found2);\n  }\n  eq(other) {\n    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)\n      return false;\n    for (let i = 0;i < this.members.length; i++)\n      if (!this.members[i].eq(other.members[i]))\n        return false;\n    return true;\n  }\n  locals(node) {\n    let result, sorted = true;\n    for (let i = 0;i < this.members.length; i++) {\n      let locals = this.members[i].localsInner(node);\n      if (!locals.length)\n        continue;\n      if (!result) {\n        result = locals;\n      } else {\n        if (sorted) {\n          result = result.slice();\n          sorted = false;\n        }\n        for (let j = 0;j < locals.length; j++)\n          result.push(locals[j]);\n      }\n    }\n    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n  }\n  static from(members) {\n    switch (members.length) {\n      case 0:\n        return empty;\n      case 1:\n        return members[0];\n      default:\n        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n    }\n  }\n  forEachSet(f) {\n    for (let i = 0;i < this.members.length; i++)\n      this.members[i].forEachSet(f);\n  }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  let children = oldChildren.slice();\n  for (let i = 0, baseOffset = oldOffset;i < mapping.maps.length; i++) {\n    let moved = 0;\n    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n      let dSize = newEnd - newStart - (oldEnd - oldStart);\n      for (let i2 = 0;i2 < children.length; i2 += 3) {\n        let end = children[i2 + 1];\n        if (end < 0 || oldStart > end + baseOffset - moved)\n          continue;\n        let start = children[i2] + baseOffset - moved;\n        if (oldEnd >= start) {\n          children[i2 + 1] = oldStart <= start ? -2 : -1;\n        } else if (oldStart >= baseOffset && dSize) {\n          children[i2] += dSize;\n          children[i2 + 1] += dSize;\n        }\n      }\n      moved += dSize;\n    });\n    baseOffset = mapping.maps[i].map(baseOffset, -1);\n  }\n  let mustRebuild = false;\n  for (let i = 0;i < children.length; i += 3)\n    if (children[i + 1] < 0) {\n      if (children[i + 1] == -2) {\n        mustRebuild = true;\n        children[i + 1] = -1;\n        continue;\n      }\n      let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n      if (fromLocal < 0 || fromLocal >= node.content.size) {\n        mustRebuild = true;\n        continue;\n      }\n      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n      let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n      let childNode = node.maybeChild(index);\n      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n        let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n        if (mapped != empty) {\n          children[i] = fromLocal;\n          children[i + 1] = toLocal;\n          children[i + 2] = mapped;\n        } else {\n          children[i + 1] = -2;\n          mustRebuild = true;\n        }\n      } else {\n        mustRebuild = true;\n      }\n    }\n  if (mustRebuild) {\n    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n    let built = buildTree(decorations, node, 0, options);\n    newLocal = built.local;\n    for (let i = 0;i < children.length; i += 3)\n      if (children[i + 1] < 0) {\n        children.splice(i, 3);\n        i -= 3;\n      }\n    for (let i = 0, j = 0;i < built.children.length; i += 3) {\n      let from = built.children[i];\n      while (j < children.length && children[j] < from)\n        j += 3;\n      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n    }\n  }\n  return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length)\n    return spans;\n  let result = [];\n  for (let i = 0;i < spans.length; i++) {\n    let span = spans[i];\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n  }\n  return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  function gather(set, oldOffset2) {\n    for (let i = 0;i < set.local.length; i++) {\n      let mapped = set.local[i].map(mapping, offset, oldOffset2);\n      if (mapped)\n        decorations.push(mapped);\n      else if (options.onRemove)\n        options.onRemove(set.local[i].spec);\n    }\n    for (let i = 0;i < set.children.length; i += 3)\n      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);\n  }\n  for (let i = 0;i < children.length; i += 3)\n    if (children[i + 1] == -1)\n      gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n  return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf)\n    return null;\n  let end = offset + node.nodeSize, found2 = null;\n  for (let i = 0, span;i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      (found2 || (found2 = [])).push(span);\n      spans[i] = null;\n    }\n  }\n  return found2;\n}\nfunction withoutNulls(array) {\n  let result = [];\n  for (let i = 0;i < array.length; i++)\n    if (array[i] != null)\n      result.push(array[i]);\n  return result;\n}\nfunction buildTree(spans, node, offset, options) {\n  let children = [], hasNulls = false;\n  node.forEach((childNode, localStart) => {\n    let found2 = takeSpansForNode(spans, childNode, localStart + offset);\n    if (found2) {\n      hasNulls = true;\n      let subtree = buildTree(found2, childNode, offset + localStart + 1, options);\n      if (subtree != empty)\n        children.push(localStart, localStart + childNode.nodeSize, subtree);\n    }\n  });\n  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n  for (let i = 0;i < locals.length; i++)\n    if (!locals[i].type.valid(node, locals[i])) {\n      if (options.onRemove)\n        options.onRemove(locals[i].spec);\n      locals.splice(i--, 1);\n    }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to;\n}\nfunction removeOverlap(spans) {\n  let working = spans;\n  for (let i = 0;i < working.length - 1; i++) {\n    let span = working[i];\n    if (span.from != span.to)\n      for (let j = i + 1;j < working.length; j++) {\n        let next = working[j];\n        if (next.from == span.from) {\n          if (next.to != span.to) {\n            if (working == spans)\n              working = spans.slice();\n            working[j] = next.copy(next.from, span.to);\n            insertAhead(working, j + 1, next.copy(span.to, next.to));\n          }\n          continue;\n        } else {\n          if (next.from < span.to) {\n            if (working == spans)\n              working = spans.slice();\n            working[i] = span.copy(span.from, next.from);\n            insertAhead(working, j, span.copy(next.from, span.to));\n          }\n          break;\n        }\n      }\n  }\n  return working;\n}\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0)\n    i++;\n  array.splice(i, 0, deco);\n}\nfunction viewDecorations(view) {\n  let found2 = [];\n  view.someProp(\"decorations\", (f) => {\n    let result = f(view.state);\n    if (result && result != empty)\n      found2.push(result);\n  });\n  if (view.cursorWrapper)\n    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n  return DecorationGroup.from(found2);\n}\nvar observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n};\nvar useCharData = ie && ie_version <= 11;\n\nclass SelectionState {\n  constructor() {\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n  set(sel) {\n    this.anchorNode = sel.anchorNode;\n    this.anchorOffset = sel.anchorOffset;\n    this.focusNode = sel.focusNode;\n    this.focusOffset = sel.focusOffset;\n  }\n  clear() {\n    this.anchorNode = this.focusNode = null;\n  }\n  eq(sel) {\n    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n  }\n}\n\nclass DOMObserver {\n  constructor(view, handleDOMChange) {\n    this.view = view;\n    this.handleDOMChange = handleDOMChange;\n    this.queue = [];\n    this.flushingSoon = -1;\n    this.observer = null;\n    this.currentSelection = new SelectionState;\n    this.onCharData = null;\n    this.suppressingSelectionUpdates = false;\n    this.lastChangedTextNode = null;\n    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {\n      for (let i = 0;i < mutations.length; i++)\n        this.queue.push(mutations[i]);\n      if (ie && ie_version <= 11 && mutations.some((m) => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) {\n        this.flushSoon();\n      } else if (safari && view.composing && mutations.some((m) => m.type == \"childList\" && m.target.nodeName == \"TR\")) {\n        view.input.badSafariComposition = true;\n        this.flushSoon();\n      } else {\n        this.flush();\n      }\n    });\n    if (useCharData) {\n      this.onCharData = (e) => {\n        this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n        this.flushSoon();\n      };\n    }\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n  }\n  flushSoon() {\n    if (this.flushingSoon < 0)\n      this.flushingSoon = window.setTimeout(() => {\n        this.flushingSoon = -1;\n        this.flush();\n      }, 20);\n  }\n  forceFlush() {\n    if (this.flushingSoon > -1) {\n      window.clearTimeout(this.flushingSoon);\n      this.flushingSoon = -1;\n      this.flush();\n    }\n  }\n  start() {\n    if (this.observer) {\n      this.observer.takeRecords();\n      this.observer.observe(this.view.dom, observeOptions);\n    }\n    if (this.onCharData)\n      this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.connectSelection();\n  }\n  stop() {\n    if (this.observer) {\n      let take = this.observer.takeRecords();\n      if (take.length) {\n        for (let i = 0;i < take.length; i++)\n          this.queue.push(take[i]);\n        window.setTimeout(() => this.flush(), 20);\n      }\n      this.observer.disconnect();\n    }\n    if (this.onCharData)\n      this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.disconnectSelection();\n  }\n  connectSelection() {\n    this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  disconnectSelection() {\n    this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  suppressSelectionUpdates() {\n    this.suppressingSelectionUpdates = true;\n    setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n  }\n  onSelectionChange() {\n    if (!hasFocusAndSelection(this.view))\n      return;\n    if (this.suppressingSelectionUpdates)\n      return selectionToDOM(this.view);\n    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n      let sel = this.view.domSelectionRange();\n      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n        return this.flushSoon();\n    }\n    this.flush();\n  }\n  setCurSelection() {\n    this.currentSelection.set(this.view.domSelectionRange());\n  }\n  ignoreSelectionChange(sel) {\n    if (!sel.focusNode)\n      return true;\n    let ancestors = new Set, container;\n    for (let scan = sel.focusNode;scan; scan = parentNode(scan))\n      ancestors.add(scan);\n    for (let scan = sel.anchorNode;scan; scan = parentNode(scan))\n      if (ancestors.has(scan)) {\n        container = scan;\n        break;\n      }\n    let desc = container && this.view.docView.nearestDesc(container);\n    if (desc && desc.ignoreMutation({\n      type: \"selection\",\n      target: container.nodeType == 3 ? container.parentNode : container\n    })) {\n      this.setCurSelection();\n      return true;\n    }\n  }\n  pendingRecords() {\n    if (this.observer)\n      for (let mut of this.observer.takeRecords())\n        this.queue.push(mut);\n    return this.queue;\n  }\n  flush() {\n    let { view } = this;\n    if (!view.docView || this.flushingSoon > -1)\n      return;\n    let mutations = this.pendingRecords();\n    if (mutations.length)\n      this.queue = [];\n    let sel = view.domSelectionRange();\n    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n    let from = -1, to = -1, typeOver = false, added = [];\n    if (view.editable) {\n      for (let i = 0;i < mutations.length; i++) {\n        let result = this.registerMutation(mutations[i], added);\n        if (result) {\n          from = from < 0 ? result.from : Math.min(result.from, from);\n          to = to < 0 ? result.to : Math.max(result.to, to);\n          if (result.typeOver)\n            typeOver = true;\n        }\n      }\n    }\n    if (added.some((n) => n.nodeName == \"BR\") && (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {\n      for (let node of added)\n        if (node.nodeName == \"BR\" && node.parentNode) {\n          let after = node.nextSibling;\n          if (after && after.nodeType == 1 && after.contentEditable == \"false\")\n            node.parentNode.removeChild(node);\n        }\n    } else if (gecko && added.length) {\n      let brs = added.filter((n) => n.nodeName == \"BR\");\n      if (brs.length == 2) {\n        let [a, b] = brs;\n        if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n          b.remove();\n        else\n          a.remove();\n      } else {\n        let { focusNode } = this.currentSelection;\n        for (let br of brs) {\n          let parent = br.parentNode;\n          if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent))\n            br.remove();\n        }\n      }\n    }\n    let readSel = null;\n    if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {\n      view.input.lastFocus = 0;\n      selectionToDOM(view);\n      this.currentSelection.set(sel);\n      view.scrollToSelection();\n    } else if (from > -1 || newSel) {\n      if (from > -1) {\n        view.docView.markDirty(from, to);\n        checkCSS(view);\n      }\n      if (view.input.badSafariComposition) {\n        view.input.badSafariComposition = false;\n        fixUpBadSafariComposition(view, added);\n      }\n      this.handleDOMChange(from, to, typeOver, added);\n      if (view.docView && view.docView.dirty)\n        view.updateState(view.state);\n      else if (!this.currentSelection.eq(sel))\n        selectionToDOM(view);\n      this.currentSelection.set(sel);\n    }\n  }\n  registerMutation(mut, added) {\n    if (added.indexOf(mut.target) > -1)\n      return null;\n    let desc = this.view.docView.nearestDesc(mut.target);\n    if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\")))\n      return null;\n    if (!desc || desc.ignoreMutation(mut))\n      return null;\n    if (mut.type == \"childList\") {\n      for (let i = 0;i < mut.addedNodes.length; i++) {\n        let node = mut.addedNodes[i];\n        added.push(node);\n        if (node.nodeType == 3)\n          this.lastChangedTextNode = node;\n      }\n      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n        return { from: desc.posBefore, to: desc.posAfter };\n      let { previousSibling: prev, nextSibling: next } = mut;\n      if (ie && ie_version <= 11 && mut.addedNodes.length) {\n        for (let i = 0;i < mut.addedNodes.length; i++) {\n          let { previousSibling, nextSibling } = mut.addedNodes[i];\n          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n            prev = previousSibling;\n          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n            next = nextSibling;\n        }\n      }\n      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n      let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n      let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n      return { from, to };\n    } else if (mut.type == \"attributes\") {\n      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n    } else {\n      this.lastChangedTextNode = mut.target;\n      return {\n        from: desc.posAtStart,\n        to: desc.posAtEnd,\n        typeOver: mut.target.nodeValue == mut.oldValue\n      };\n    }\n  }\n}\nvar cssChecked = new WeakMap;\nvar cssCheckWarned = false;\nfunction checkCSS(view) {\n  if (cssChecked.has(view))\n    return;\n  cssChecked.set(view, null);\n  if ([\"normal\", \"nowrap\", \"pre-line\"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n    view.requiresGeckoHackNode = gecko;\n    if (cssCheckWarned)\n      return;\n    console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n    cssCheckWarned = true;\n  }\n}\nfunction rangeToSelectionRange(view, range) {\n  let { startContainer: anchorNode, startOffset: anchorOffset } = range;\n  let { endContainer: focusNode, endOffset: focusOffset } = range;\n  let currentAnchor = view.domAtPos(view.state.selection.anchor);\n  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n  return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\nfunction safariShadowSelectionRange(view, selection) {\n  if (selection.getComposedRanges) {\n    let range = selection.getComposedRanges(view.root)[0];\n    if (range)\n      return rangeToSelectionRange(view, range);\n  }\n  let found2;\n  function read(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    found2 = event.getTargetRanges()[0];\n  }\n  view.dom.addEventListener(\"beforeinput\", read, true);\n  document.execCommand(\"indent\");\n  view.dom.removeEventListener(\"beforeinput\", read, true);\n  return found2 ? rangeToSelectionRange(view, found2) : null;\n}\nfunction blockParent(view, node) {\n  for (let p = node.parentNode;p && p != view.dom; p = p.parentNode) {\n    let desc = view.docView.nearestDesc(p, true);\n    if (desc && desc.node.isBlock)\n      return p;\n  }\n  return null;\n}\nfunction fixUpBadSafariComposition(view, addedNodes) {\n  var _a;\n  let { focusNode, focusOffset } = view.domSelectionRange();\n  for (let node of addedNodes) {\n    if (((_a = node.parentNode) === null || _a === undefined ? undefined : _a.nodeName) == \"TR\") {\n      let nextCell = node.nextSibling;\n      while (nextCell && (nextCell.nodeName != \"TD\" && nextCell.nodeName != \"TH\"))\n        nextCell = nextCell.nextSibling;\n      if (nextCell) {\n        let parent = nextCell;\n        for (;; ) {\n          let first = parent.firstChild;\n          if (!first || first.nodeType != 1 || first.contentEditable == \"false\" || /^(BR|IMG)$/.test(first.nodeName))\n            break;\n          parent = first;\n        }\n        parent.insertBefore(node, parent.firstChild);\n        if (focusNode == node)\n          view.domSelection().collapse(node, focusOffset);\n      } else {\n        node.parentNode.removeChild(node);\n      }\n    }\n  }\n}\nfunction parseBetween(view, from_, to_) {\n  let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n  let domSel = view.domSelectionRange();\n  let find;\n  let anchor = domSel.anchorNode;\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{ node: anchor, offset: domSel.anchorOffset }];\n    if (!selectionCollapsed(domSel))\n      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n  }\n  if (chrome && view.input.lastKeyCode === 8) {\n    for (let off = toOffset;off > fromOffset; off--) {\n      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n      if (node.nodeName == \"BR\" && !desc) {\n        toOffset = off;\n        break;\n      }\n      if (!desc || desc.size)\n        break;\n    }\n  }\n  let startDoc = view.state.doc;\n  let parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n  let $from = startDoc.resolve(from);\n  let sel = null, doc3 = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n    findPositions: find,\n    ruleFromNode,\n    context: $from\n  });\n  if (find && find[0].pos != null) {\n    let anchor2 = find[0].pos, head = find[1] && find[1].pos;\n    if (head == null)\n      head = anchor2;\n    sel = { anchor: anchor2 + from, head: head + from };\n  }\n  return { doc: doc3, sel, from, to };\n}\nfunction ruleFromNode(dom) {\n  let desc = dom.pmViewDesc;\n  if (desc) {\n    return desc.parseRule();\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      let skip = document.createElement(\"div\");\n      skip.appendChild(document.createElement(\"li\"));\n      return { skip };\n    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return { ignore: true };\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return { ignore: true };\n  }\n  return null;\n}\nvar isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n  view.input.compositionPendingChanges = 0;\n  if (from < 0) {\n    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n    let newSel = selectionFromDOM(view, origin);\n    if (newSel && !view.state.selection.eq(newSel)) {\n      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\"))))\n        return;\n      let tr = view.state.tr.setSelection(newSel);\n      if (origin == \"pointer\")\n        tr.setMeta(\"pointer\", true);\n      else if (origin == \"key\")\n        tr.scrollIntoView();\n      if (compositionID)\n        tr.setMeta(\"composition\", compositionID);\n      view.dispatch(tr);\n    }\n    return;\n  }\n  let $before = view.state.doc.resolve(from);\n  let shared = $before.sharedDepth(to);\n  from = $before.before(shared + 1);\n  to = view.state.doc.resolve(to).after(shared + 1);\n  let sel = view.state.selection;\n  let parse = parseBetween(view, from, to);\n  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);\n  let preferredPos, preferredSide;\n  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to;\n    preferredSide = \"end\";\n  } else {\n    preferredPos = view.state.selection.from;\n    preferredSide = \"start\";\n  }\n  view.input.lastKeyCode = null;\n  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n  if (change)\n    view.input.domChangeCount++;\n  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n    view.input.lastIOSEnter = 0;\n    return;\n  }\n  if (!change) {\n    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = { start: sel.from, endA: sel.to, endB: sel.to };\n    } else {\n      if (parse.sel) {\n        let sel2 = resolveSelection(view, view.state.doc, parse.sel);\n        if (sel2 && !sel2.eq(view.state.selection)) {\n          let tr = view.state.tr.setSelection(sel2);\n          if (compositionID)\n            tr.setMeta(\"composition\", compositionID);\n          view.dispatch(tr);\n        }\n      }\n      return;\n    }\n  }\n  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n      change.start = view.state.selection.from;\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n      change.endB += view.state.selection.to - change.endA;\n      change.endA = view.state.selection.to;\n    }\n  }\n  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" ¬†\") {\n    change.start--;\n    change.endA--;\n    change.endB--;\n  }\n  let $from = parse.doc.resolveNoCache(change.start - parse.from);\n  let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n  let $fromA = doc3.resolve(change.start);\n  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\"))) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n    view.input.lastIOSEnter = 0;\n    return;\n  }\n  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\")))) {\n    if (android && chrome)\n      view.domObserver.suppressSelectionUpdates();\n    return;\n  }\n  if (chrome && change.endB == change.start)\n    view.input.lastChromeDelete = Date.now();\n  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2;\n    $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    setTimeout(() => {\n      view.someProp(\"handleKeyDown\", function(f) {\n        return f(view, keyEvent(13, \"Enter\"));\n      });\n    }, 20);\n  }\n  let { start: chFrom, endA: chTo } = change;\n  let mkTr = (base) => {\n    let tr = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n    if (parse.sel) {\n      let sel2 = resolveSelection(view, tr.doc, parse.sel);\n      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))\n        tr.setSelection(sel2);\n    }\n    if (compositionID)\n      tr.setMeta(\"composition\", compositionID);\n    return tr.scrollIntoView();\n  };\n  let markChange;\n  if (inlineChange) {\n    if ($from.pos == $to.pos) {\n      if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates();\n        setTimeout(() => selectionToDOM(view), 20);\n      }\n      let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n      let marks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));\n      if (marks)\n        tr.ensureMarks(marks);\n      view.dispatch(tr);\n    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n      let tr = mkTr(view.state.tr);\n      if (markChange.type == \"add\")\n        tr.addMark(chFrom, chTo, markChange.mark);\n      else\n        tr.removeMark(chFrom, chTo, markChange.mark);\n      view.dispatch(tr);\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));\n      if (!view.someProp(\"handleTextInput\", (f) => f(view, chFrom, chTo, text, deflt)))\n        view.dispatch(deflt());\n    } else {\n      view.dispatch(mkTr());\n    }\n  } else {\n    view.dispatch(mkTr());\n  }\n}\nfunction resolveSelection(view, doc3, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)\n    return null;\n  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));\n}\nfunction isMarkChange(cur, prev) {\n  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n  let added = curMarks, removed = prevMarks, type, mark, update;\n  for (let i = 0;i < prevMarks.length; i++)\n    added = prevMarks[i].removeFromSet(added);\n  for (let i = 0;i < curMarks.length; i++)\n    removed = curMarks[i].removeFromSet(removed);\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0];\n    type = \"add\";\n    update = (node) => node.mark(mark.addToSet(node.marks));\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0];\n    type = \"remove\";\n    update = (node) => node.mark(mark.removeFromSet(node.marks));\n  } else {\n    return null;\n  }\n  let updated = [];\n  for (let i = 0;i < prev.childCount; i++)\n    updated.push(update(prev.child(i)));\n  if (Fragment.from(updated).eq(cur))\n    return { mark, type };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n  if (end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    return false;\n  let $start = old.resolve(start);\n  if (!$newStart.parent.isTextblock) {\n    let after = $start.nodeAfter;\n    return after != null && end == start + after.nodeSize;\n  }\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    return false;\n  let $next = old.resolve(skipClosingAndOpening($start, true, true));\n  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)\n    return false;\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--;\n    end++;\n    fromEnd = false;\n  }\n  if (mayOpen) {\n    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n    while (next && !next.isLeaf) {\n      next = next.firstChild;\n      end++;\n    }\n  }\n  return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  let start = a.findDiffStart(b, pos);\n  if (start == null)\n    return null;\n  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, start - Math.min(endA, endB));\n    preferredPos -= endA + adjust - start;\n  }\n  if (endA < start && a.size < b.size) {\n    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n    start -= move;\n    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))\n      start += move ? 1 : -1;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n    start -= move;\n    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))\n      start += move ? 1 : -1;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n  return { start, endA, endB };\n}\nfunction isSurrogatePair(str) {\n  if (str.length != 2)\n    return false;\n  let a = str.charCodeAt(0), b = str.charCodeAt(1);\n  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;\n}\nclass EditorView {\n  constructor(place, props) {\n    this._root = null;\n    this.focused = false;\n    this.trackWrites = null;\n    this.mounted = false;\n    this.markCursor = null;\n    this.cursorWrapper = null;\n    this.lastSelectedViewDesc = undefined;\n    this.input = new InputState;\n    this.prevDirectPlugins = [];\n    this.pluginViews = [];\n    this.requiresGeckoHackNode = false;\n    this.dragging = null;\n    this._props = props;\n    this.state = props.state;\n    this.directPlugins = props.plugins || [];\n    this.directPlugins.forEach(checkStateComponent);\n    this.dispatch = this.dispatch.bind(this);\n    this.dom = place && place.mount || document.createElement(\"div\");\n    if (place) {\n      if (place.appendChild)\n        place.appendChild(this.dom);\n      else if (typeof place == \"function\")\n        place(this.dom);\n      else if (place.mount)\n        this.mounted = true;\n    }\n    this.editable = getEditable(this);\n    updateCursorWrapper(this);\n    this.nodeViews = buildNodeViews(this);\n    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n    this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));\n    this.domObserver.start();\n    initInput(this);\n    this.updatePluginViews();\n  }\n  get composing() {\n    return this.input.composing;\n  }\n  get props() {\n    if (this._props.state != this.state) {\n      let prev = this._props;\n      this._props = {};\n      for (let name in prev)\n        this._props[name] = prev[name];\n      this._props.state = this.state;\n    }\n    return this._props;\n  }\n  update(props) {\n    if (props.handleDOMEvents != this._props.handleDOMEvents)\n      ensureListeners(this);\n    let prevProps = this._props;\n    this._props = props;\n    if (props.plugins) {\n      props.plugins.forEach(checkStateComponent);\n      this.directPlugins = props.plugins;\n    }\n    this.updateStateInner(props.state, prevProps);\n  }\n  setProps(props) {\n    let updated = {};\n    for (let name in this._props)\n      updated[name] = this._props[name];\n    updated.state = this.state;\n    for (let name in props)\n      updated[name] = props[name];\n    this.update(updated);\n  }\n  updateState(state) {\n    this.updateStateInner(state, this._props);\n  }\n  updateStateInner(state, prevProps) {\n    var _a;\n    let prev = this.state, redraw = false, updateSel = false;\n    if (state.storedMarks && this.composing) {\n      clearComposition(this);\n      updateSel = true;\n    }\n    this.state = state;\n    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n      let nodeViews = buildNodeViews(this);\n      if (changedNodeViews(nodeViews, this.nodeViews)) {\n        this.nodeViews = nodeViews;\n        redraw = true;\n      }\n    }\n    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n      ensureListeners(this);\n    }\n    this.editable = getEditable(this);\n    updateCursorWrapper(this);\n    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n    if (updateDoc || !state.selection.eq(prev.selection))\n      updateSel = true;\n    let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n    if (updateSel) {\n      this.domObserver.stop();\n      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n      if (updateDoc) {\n        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n        if (this.composing)\n          this.input.compositionNode = findCompositionNode(this);\n        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n          this.docView.updateOuterDeco(outerDeco);\n          this.docView.destroy();\n          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n        }\n        if (chromeKludge && (!this.trackWrites || !this.dom.contains(this.trackWrites)))\n          forceSelUpdate = true;\n      }\n      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n        selectionToDOM(this, forceSelUpdate);\n      } else {\n        syncNodeSelection(this, state.selection);\n        this.domObserver.setCurSelection();\n      }\n      this.domObserver.start();\n    }\n    this.updatePluginViews(prev);\n    if (((_a = this.dragging) === null || _a === undefined ? undefined : _a.node) && !prev.doc.eq(state.doc))\n      this.updateDraggedNode(this.dragging, prev);\n    if (scroll == \"reset\") {\n      this.dom.scrollTop = 0;\n    } else if (scroll == \"to selection\") {\n      this.scrollToSelection();\n    } else if (oldScrollPos) {\n      resetScrollPos(oldScrollPos);\n    }\n  }\n  scrollToSelection() {\n    let startDOM = this.domSelectionRange().focusNode;\n    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode))\n      ;\n    else if (this.someProp(\"handleScrollToSelection\", (f) => f(this)))\n      ;\n    else if (this.state.selection instanceof NodeSelection) {\n      let target = this.docView.domAfterPos(this.state.selection.from);\n      if (target.nodeType == 1)\n        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n    } else {\n      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n    }\n  }\n  destroyPluginViews() {\n    let view;\n    while (view = this.pluginViews.pop())\n      if (view.destroy)\n        view.destroy();\n  }\n  updatePluginViews(prevState) {\n    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n      this.prevDirectPlugins = this.directPlugins;\n      this.destroyPluginViews();\n      for (let i = 0;i < this.directPlugins.length; i++) {\n        let plugin = this.directPlugins[i];\n        if (plugin.spec.view)\n          this.pluginViews.push(plugin.spec.view(this));\n      }\n      for (let i = 0;i < this.state.plugins.length; i++) {\n        let plugin = this.state.plugins[i];\n        if (plugin.spec.view)\n          this.pluginViews.push(plugin.spec.view(this));\n      }\n    } else {\n      for (let i = 0;i < this.pluginViews.length; i++) {\n        let pluginView = this.pluginViews[i];\n        if (pluginView.update)\n          pluginView.update(this, prevState);\n      }\n    }\n  }\n  updateDraggedNode(dragging, prev) {\n    let sel = dragging.node, found2 = -1;\n    if (this.state.doc.nodeAt(sel.from) == sel.node) {\n      found2 = sel.from;\n    } else {\n      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n      if (moved == sel.node)\n        found2 = movedPos;\n    }\n    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? undefined : NodeSelection.create(this.state.doc, found2));\n  }\n  someProp(propName, f) {\n    let prop = this._props && this._props[propName], value;\n    if (prop != null && (value = f ? f(prop) : prop))\n      return value;\n    for (let i = 0;i < this.directPlugins.length; i++) {\n      let prop2 = this.directPlugins[i].props[propName];\n      if (prop2 != null && (value = f ? f(prop2) : prop2))\n        return value;\n    }\n    let plugins = this.state.plugins;\n    if (plugins)\n      for (let i = 0;i < plugins.length; i++) {\n        let prop2 = plugins[i].props[propName];\n        if (prop2 != null && (value = f ? f(prop2) : prop2))\n          return value;\n      }\n  }\n  hasFocus() {\n    if (ie) {\n      let node = this.root.activeElement;\n      if (node == this.dom)\n        return true;\n      if (!node || !this.dom.contains(node))\n        return false;\n      while (node && this.dom != node && this.dom.contains(node)) {\n        if (node.contentEditable == \"false\")\n          return false;\n        node = node.parentElement;\n      }\n      return true;\n    }\n    return this.root.activeElement == this.dom;\n  }\n  focus() {\n    this.domObserver.stop();\n    if (this.editable)\n      focusPreventScroll(this.dom);\n    selectionToDOM(this);\n    this.domObserver.start();\n  }\n  get root() {\n    let cached = this._root;\n    if (cached == null)\n      for (let search = this.dom.parentNode;search; search = search.parentNode) {\n        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n          if (!search.getSelection)\n            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n          return this._root = search;\n        }\n      }\n    return cached || document;\n  }\n  updateRoot() {\n    this._root = null;\n  }\n  posAtCoords(coords) {\n    return posAtCoords(this, coords);\n  }\n  coordsAtPos(pos, side = 1) {\n    return coordsAtPos(this, pos, side);\n  }\n  domAtPos(pos, side = 0) {\n    return this.docView.domFromPos(pos, side);\n  }\n  nodeDOM(pos) {\n    let desc = this.docView.descAt(pos);\n    return desc ? desc.nodeDOM : null;\n  }\n  posAtDOM(node, offset, bias = -1) {\n    let pos = this.docView.posFromDOM(node, offset, bias);\n    if (pos == null)\n      throw new RangeError(\"DOM position not inside the editor\");\n    return pos;\n  }\n  endOfTextblock(dir, state) {\n    return endOfTextblock(this, state || this.state, dir);\n  }\n  pasteHTML(html, event) {\n    return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n  }\n  pasteText(text, event) {\n    return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n  }\n  serializeForClipboard(slice) {\n    return serializeForClipboard(this, slice);\n  }\n  destroy() {\n    if (!this.docView)\n      return;\n    destroyInput(this);\n    this.destroyPluginViews();\n    if (this.mounted) {\n      this.docView.update(this.state.doc, [], viewDecorations(this), this);\n      this.dom.textContent = \"\";\n    } else if (this.dom.parentNode) {\n      this.dom.parentNode.removeChild(this.dom);\n    }\n    this.docView.destroy();\n    this.docView = null;\n    clearReusedRange();\n  }\n  get isDestroyed() {\n    return this.docView == null;\n  }\n  dispatchEvent(event) {\n    return dispatchEvent(this, event);\n  }\n  domSelectionRange() {\n    let sel = this.domSelection();\n    if (!sel)\n      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };\n    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n  }\n  domSelection() {\n    return this.root.getSelection();\n  }\n}\nEditorView.prototype.dispatch = function(tr) {\n  let dispatchTransaction = this._props.dispatchTransaction;\n  if (dispatchTransaction)\n    dispatchTransaction.call(this, tr);\n  else\n    this.updateState(this.state.apply(tr));\n};\nfunction computeDocDeco(view) {\n  let attrs = Object.create(null);\n  attrs.class = \"ProseMirror\";\n  attrs.contenteditable = String(view.editable);\n  view.someProp(\"attributes\", (value) => {\n    if (typeof value == \"function\")\n      value = value(view.state);\n    if (value)\n      for (let attr in value) {\n        if (attr == \"class\")\n          attrs.class += \" \" + value[attr];\n        else if (attr == \"style\")\n          attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n        else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n          attrs[attr] = String(value[attr]);\n      }\n  });\n  if (!attrs.translate)\n    attrs.translate = \"no\";\n  return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    let dom = document.createElement(\"img\");\n    dom.className = \"ProseMirror-separator\";\n    dom.setAttribute(\"mark-placeholder\", \"true\");\n    dom.setAttribute(\"alt\", \"\");\n    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };\n  } else {\n    view.cursorWrapper = null;\n  }\n}\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", (value) => value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n  let result = Object.create(null);\n  function add(obj) {\n    for (let prop in obj)\n      if (!Object.prototype.hasOwnProperty.call(result, prop))\n        result[prop] = obj[prop];\n  }\n  view.someProp(\"nodeViews\", add);\n  view.someProp(\"markViews\", add);\n  return result;\n}\nfunction changedNodeViews(a, b) {\n  let nA = 0, nB = 0;\n  for (let prop in a) {\n    if (a[prop] != b[prop])\n      return true;\n    nA++;\n  }\n  for (let _ in b)\n    nB++;\n  return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n    throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n// node_modules/prosemirror-commands/dist/index.js\nvar deleteSelection = (state, dispatch) => {\n  if (state.selection.empty)\n    return false;\n  if (dispatch)\n    dispatch(state.tr.deleteSelection().scrollIntoView());\n  return true;\n};\nfunction atBlockStart(state, view) {\n  let { $cursor } = state.selection;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0))\n    return null;\n  return $cursor;\n}\nvar joinBackward = (state, dispatch, view) => {\n  let $cursor = atBlockStart(state, view);\n  if (!$cursor)\n    return false;\n  let $cut = findCutBefore($cursor);\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  let before = $cut.nodeBefore;\n  if (deleteBarrier(state, $cut, dispatch, -1))\n    return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    for (let depth = $cursor.depth;; depth--) {\n      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);\n      if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n        if (dispatch) {\n          let tr = state.tr.step(delStep);\n          tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n        break;\n    }\n  }\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch)\n      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nfunction textblockAt(node, side, only = false) {\n  for (let scan = node;scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n    if (scan.isTextblock)\n      return true;\n    if (only && scan.childCount != 1)\n      return false;\n  }\n  return false;\n}\nvar selectNodeBackward = (state, dispatch, view) => {\n  let { $head, empty: empty2 } = state.selection, $cut = $head;\n  if (!empty2)\n    return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n      return false;\n    $cut = findCutBefore($head);\n  }\n  let node = $cut && $cut.nodeBefore;\n  if (!node || !NodeSelection.isSelectable(node))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  return true;\n};\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating)\n    for (let i = $pos.depth - 1;i >= 0; i--) {\n      if ($pos.index(i) > 0)\n        return $pos.doc.resolve($pos.before(i + 1));\n      if ($pos.node(i).type.spec.isolating)\n        break;\n    }\n  return null;\n}\nfunction atBlockEnd(state, view) {\n  let { $cursor } = state.selection;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size))\n    return null;\n  return $cursor;\n}\nvar joinForward = (state, dispatch, view) => {\n  let $cursor = atBlockEnd(state, view);\n  if (!$cursor)\n    return false;\n  let $cut = findCutAfter($cursor);\n  if (!$cut)\n    return false;\n  let after = $cut.nodeAfter;\n  if (deleteBarrier(state, $cut, dispatch, 1))\n    return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch)\n      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nvar selectNodeForward = (state, dispatch, view) => {\n  let { $head, empty: empty2 } = state.selection, $cut = $head;\n  if (!empty2)\n    return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false;\n    $cut = findCutAfter($head);\n  }\n  let node = $cut && $cut.nodeAfter;\n  if (!node || !NodeSelection.isSelectable(node))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  return true;\n};\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating)\n    for (let i = $pos.depth - 1;i >= 0; i--) {\n      let parent = $pos.node(i);\n      if ($pos.index(i) + 1 < parent.childCount)\n        return $pos.doc.resolve($pos.after(i + 1));\n      if (parent.type.spec.isolating)\n        break;\n    }\n  return null;\n}\nvar newlineInCode = (state, dispatch) => {\n  let { $head, $anchor } = state.selection;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.insertText(`\n`).scrollIntoView());\n  return true;\n};\nfunction defaultBlockAt(match) {\n  for (let i = 0;i < match.edgeCount; i++) {\n    let { type } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs())\n      return type;\n  }\n  return null;\n}\nvar exitCode = (state, dispatch) => {\n  let { $head, $anchor } = state.selection;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n    return false;\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n  if (!type || !above.canReplaceWith(after, after, type))\n    return false;\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar createParagraphNear = (state, dispatch) => {\n  let sel = state.selection, { $from, $to } = sel;\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n    return false;\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock)\n    return false;\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    let tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar liftEmptyBlock = (state, dispatch) => {\n  let { $cursor } = state.selection;\n  if (!$cursor || $cursor.parent.content.size)\n    return false;\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before();\n    if (canSplit(state.doc, before)) {\n      if (dispatch)\n        dispatch(state.tr.split(before).scrollIntoView());\n      return true;\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range);\n  if (target == null)\n    return false;\n  if (dispatch)\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nfunction splitBlockAs(splitNode) {\n  return (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))\n        return false;\n      if (dispatch)\n        dispatch(state.tr.split($from.pos).scrollIntoView());\n      return true;\n    }\n    if (!$from.depth)\n      return false;\n    let types = [];\n    let splitDepth, deflt, atEnd = false, atStart = false;\n    for (let d = $from.depth;; d--) {\n      let node = $from.node(d);\n      if (node.isBlock) {\n        atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n        atStart = $from.start(d) == $from.pos - ($from.depth - d);\n        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n        let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));\n        splitDepth = d;\n        break;\n      } else {\n        if (d == 1)\n          return false;\n        types.unshift(null);\n      }\n    }\n    let tr = state.tr;\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)\n      tr.deleteSelection();\n    let splitPos = tr.mapping.map($from.pos);\n    let can = canSplit(tr.doc, splitPos, types.length, types);\n    if (!can) {\n      types[0] = deflt ? { type: deflt } : null;\n      can = canSplit(tr.doc, splitPos, types.length, types);\n    }\n    if (!can)\n      return false;\n    tr.split(splitPos, types.length, types);\n    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n      let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n    }\n    if (dispatch)\n      dispatch(tr.scrollIntoView());\n    return true;\n  };\n}\nvar splitBlock = splitBlockAs();\nvar selectAll = (state, dispatch) => {\n  if (dispatch)\n    dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n  return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let { nodeBefore: before, nodeAfter: after } = $pos, index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type))\n    return false;\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch)\n      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    return true;\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.join($pos.pos).scrollIntoView());\n  return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n  let { nodeBefore: before, nodeAfter: after } = $cut, conn, match;\n  let isolated = before.type.spec.isolating || after.type.spec.isolating;\n  if (!isolated && joinMaybeClear(state, $cut, dispatch))\n    return true;\n  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;\n      for (let i = conn.length - 1;i >= 0; i--)\n        wrap2 = Fragment.from(conn[i].create(null, wrap2));\n      wrap2 = Fragment.from(before.copy(wrap2));\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));\n      let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))\n        tr.join($joinAt.pos);\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  }\n  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch)\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before, wrap2 = [];\n    for (;; ) {\n      wrap2.push(at);\n      if (at.isTextblock)\n        break;\n      at = at.lastChild;\n    }\n    let afterText = after, afterDepth = 1;\n    for (;!afterText.isTextblock; afterText = afterText.firstChild)\n      afterDepth++;\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = Fragment.empty;\n        for (let i = wrap2.length - 1;i >= 0; i--)\n          end = Fragment.from(wrap2[i].copy(end));\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n    let depth = $pos.depth;\n    while ($pos.node(depth).isInline) {\n      if (!depth)\n        return false;\n      depth--;\n    }\n    if (!$pos.node(depth).isTextblock)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n    return true;\n  };\n}\nvar selectTextblockStart = selectTextblockSide(-1);\nvar selectTextblockEnd = selectTextblockSide(1);\nfunction chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0;i < commands.length; i++)\n      if (commands[i](state, dispatch, view))\n        return true;\n    return false;\n  };\n}\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward);\nvar pcBaseKeymap = {\n  Enter: chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  Backspace: backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  Delete: del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n  macBaseKeymap[key] = pcBaseKeymap[key];\nvar mac2 = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\nvar baseKeymap = mac2 ? macBaseKeymap : pcBaseKeymap;\n\n// node_modules/rope-sequence/dist/index.js\nvar GOOD_LEAF_SIZE = 200;\nvar RopeSequence = function RopeSequence2() {};\nRopeSequence.prototype.append = function append(other) {\n  if (!other.length) {\n    return this;\n  }\n  other = RopeSequence.from(other);\n  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);\n};\nRopeSequence.prototype.prepend = function prepend(other) {\n  if (!other.length) {\n    return this;\n  }\n  return RopeSequence.from(other).append(this);\n};\nRopeSequence.prototype.appendInner = function appendInner(other) {\n  return new Append(this, other);\n};\nRopeSequence.prototype.slice = function slice(from, to) {\n  if (from === undefined)\n    from = 0;\n  if (to === undefined)\n    to = this.length;\n  if (from >= to) {\n    return RopeSequence.empty;\n  }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to));\n};\nRopeSequence.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) {\n    return;\n  }\n  return this.getInner(i);\n};\nRopeSequence.prototype.forEach = function forEach(f, from, to) {\n  if (from === undefined)\n    from = 0;\n  if (to === undefined)\n    to = this.length;\n  if (from <= to) {\n    this.forEachInner(f, from, to, 0);\n  } else {\n    this.forEachInvertedInner(f, from, to, 0);\n  }\n};\nRopeSequence.prototype.map = function map(f, from, to) {\n  if (from === undefined)\n    from = 0;\n  if (to === undefined)\n    to = this.length;\n  var result = [];\n  this.forEach(function(elt, i) {\n    return result.push(f(elt, i));\n  }, from, to);\n  return result;\n};\nRopeSequence.from = function from(values) {\n  if (values instanceof RopeSequence) {\n    return values;\n  }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty;\n};\nvar Leaf = /* @__PURE__ */ function(RopeSequence3) {\n  function Leaf2(values) {\n    RopeSequence3.call(this);\n    this.values = values;\n  }\n  if (RopeSequence3)\n    Leaf2.__proto__ = RopeSequence3;\n  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n  Leaf2.prototype.constructor = Leaf2;\n  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };\n  Leaf2.prototype.flatten = function flatten() {\n    return this.values;\n  };\n  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {\n    if (from2 == 0 && to == this.length) {\n      return this;\n    }\n    return new Leaf2(this.values.slice(from2, to));\n  };\n  Leaf2.prototype.getInner = function getInner(i) {\n    return this.values[i];\n  };\n  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {\n    for (var i = from2;i < to; i++) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {\n    for (var i = from2 - 1;i >= to; i--) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n  Leaf2.prototype.leafAppend = function leafAppend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf2(this.values.concat(other.flatten()));\n    }\n  };\n  Leaf2.prototype.leafPrepend = function leafPrepend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf2(other.flatten().concat(this.values));\n    }\n  };\n  prototypeAccessors.length.get = function() {\n    return this.values.length;\n  };\n  prototypeAccessors.depth.get = function() {\n    return 0;\n  };\n  Object.defineProperties(Leaf2.prototype, prototypeAccessors);\n  return Leaf2;\n}(RopeSequence);\nRopeSequence.empty = new Leaf([]);\nvar Append = /* @__PURE__ */ function(RopeSequence3) {\n  function Append2(left, right) {\n    RopeSequence3.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n  if (RopeSequence3)\n    Append2.__proto__ = RopeSequence3;\n  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n  Append2.prototype.constructor = Append2;\n  Append2.prototype.flatten = function flatten() {\n    return this.left.flatten().concat(this.right.flatten());\n  };\n  Append2.prototype.getInner = function getInner(i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);\n  };\n  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {\n    var leftLen = this.left.length;\n    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {\n      return false;\n    }\n    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n  };\n  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {\n    var leftLen = this.left.length;\n    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {\n      return false;\n    }\n  };\n  Append2.prototype.sliceInner = function sliceInner(from2, to) {\n    if (from2 == 0 && to == this.length) {\n      return this;\n    }\n    var leftLen = this.left.length;\n    if (to <= leftLen) {\n      return this.left.slice(from2, to);\n    }\n    if (from2 >= leftLen) {\n      return this.right.slice(from2 - leftLen, to - leftLen);\n    }\n    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));\n  };\n  Append2.prototype.leafAppend = function leafAppend(other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) {\n      return new Append2(this.left, inner);\n    }\n  };\n  Append2.prototype.leafPrepend = function leafPrepend(other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) {\n      return new Append2(inner, this.right);\n    }\n  };\n  Append2.prototype.appendInner = function appendInner(other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {\n      return new Append2(this.left, new Append2(this.right, other));\n    }\n    return new Append2(this, other);\n  };\n  return Append2;\n}(RopeSequence);\nvar dist_default2 = RopeSequence;\n\n// node_modules/prosemirror-history/dist/index.js\nvar max_empty_items = 500;\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0)\n      return null;\n    let end = this.items.length;\n    for (;; end--) {\n      let next = this.items.get(end - 1);\n      if (next.selection) {\n        --end;\n        break;\n      }\n    }\n    let remap, mapFrom;\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length);\n      mapFrom = remap.maps.length;\n    }\n    let transform = state.tr;\n    let selection, remaining;\n    let addAfter = [], addBefore = [];\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1);\n          mapFrom = remap.maps.length;\n        }\n        mapFrom--;\n        addBefore.push(item);\n        return;\n      }\n      if (remap) {\n        addBefore.push(new Item(item.map));\n        let step = item.step.map(remap.slice(mapFrom)), map2;\n        if (step && transform.maybeStep(step).doc) {\n          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];\n          addAfter.push(new Item(map2, undefined, undefined, addAfter.length + addBefore.length));\n        }\n        mapFrom--;\n        if (map2)\n          remap.appendMap(map2, mapFrom);\n      } else {\n        transform.maybeStep(item.step);\n      }\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n        return false;\n      }\n    }, this.items.length, 0);\n    return { remaining, transform, selection };\n  }\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount;\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n    for (let i = 0;i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i]);\n      let item = new Item(transform.mapping.maps[i], step, selection), merged;\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged;\n        if (i)\n          newItems.pop();\n        else\n          oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n      newItems.push(item);\n      if (selection) {\n        eventCount++;\n        selection = undefined;\n      }\n      if (!preserveItems)\n        lastItem = item;\n    }\n    let overflow = eventCount - histOptions.depth;\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow);\n      eventCount -= overflow;\n    }\n    return new Branch(oldItems.append(newItems), eventCount);\n  }\n  remapping(from2, to) {\n    let maps = new Mapping;\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : undefined;\n      maps.appendMap(item.map, mirrorPos);\n    }, from2, to);\n    return maps;\n  }\n  addMaps(array) {\n    if (this.eventCount == 0)\n      return this;\n    return new Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);\n  }\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount)\n      return this;\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n    let mapping = rebasedTransform.mapping;\n    let newUntil = rebasedTransform.steps.length;\n    let eventCount = this.eventCount;\n    this.items.forEach((item) => {\n      if (item.selection)\n        eventCount--;\n    }, start);\n    let iRebased = rebasedCount;\n    this.items.forEach((item) => {\n      let pos = mapping.getMirror(--iRebased);\n      if (pos == null)\n        return;\n      newUntil = Math.min(newUntil, pos);\n      let map2 = mapping.maps[pos];\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n        if (selection)\n          eventCount++;\n        rebasedItems.push(new Item(map2, step, selection));\n      } else {\n        rebasedItems.push(new Item(map2));\n      }\n    }, start);\n    let newMaps = [];\n    for (let i = rebasedCount;i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]));\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n    let branch = new Branch(items, eventCount);\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length);\n    return branch;\n  }\n  emptyItemCount() {\n    let count = 0;\n    this.items.forEach((item) => {\n      if (!item.step)\n        count++;\n    });\n    return count;\n  }\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n    let items = [], events = 0;\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item);\n        if (item.selection)\n          events++;\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();\n        mapFrom--;\n        if (map2)\n          remap.appendMap(map2, mapFrom);\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n          if (selection)\n            events++;\n          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged;\n          else\n            items.push(newItem);\n        }\n      } else if (item.map) {\n        mapFrom--;\n      }\n    }, this.items.length, 0);\n    return new Branch(dist_default2.from(items.reverse()), events);\n  }\n}\nBranch.empty = new Branch(dist_default2.empty, 0);\nfunction cutOffEvents(items, n) {\n  let cutPoint;\n  items.forEach((item, i) => {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\n\nclass Item {\n  constructor(map2, step, selection, mirrorOffset) {\n    this.map = map2;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step);\n      if (step)\n        return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}\n\nclass HistoryState {\n  constructor(done, undone, prevRanges, prevTime, prevComposition) {\n    this.done = done;\n    this.undone = undone;\n    this.prevRanges = prevRanges;\n    this.prevTime = prevTime;\n    this.prevComposition = prevComposition;\n  }\n}\nvar DEPTH_OVERFLOW = 20;\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased;\n  if (historyTr)\n    return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey))\n    history = new HistoryState(history.done, history.undone, null, 0, -1);\n  let appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    let composition = tr.getMeta(\"composition\");\n    let newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges)\n    return false;\n  if (!transform.docChanged)\n    return true;\n  let adjacent = false;\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0;i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(maps) {\n  let result = [];\n  for (let i = maps.length - 1;i >= 0 && result.length == 0; i--)\n    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges)\n    return null;\n  let result = [];\n  for (let i = 0;i < ranges.length; i += 2) {\n    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n    if (from2 <= to)\n      result.push(from2, to);\n  }\n  return result;\n}\nfunction histTransaction(history, state, redo) {\n  let preserveItems = mustPreserveItems(state);\n  let histOptions = historyKey.get(state).spec.config;\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop)\n    return null;\n  let selection = pop.selection.resolve(pop.transform.doc);\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n  return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nvar cachedPreserveItems = false;\nvar cachedPreserveItemsPlugins = null;\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (let i = 0;i < plugins.length; i++)\n      if (plugins[i].spec.historyPreserveItems) {\n        cachedPreserveItems = true;\n        break;\n      }\n  }\n  return cachedPreserveItems;\n}\nvar historyKey = new PluginKey(\"history\");\nvar closeHistoryKey = new PluginKey(\"closeHistory\");\nfunction history(config = {}) {\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config,\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let inputType = e.inputType;\n          let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command || !view.editable)\n            return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\nfunction buildCommand(redo, scroll) {\n  return (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n      return false;\n    if (dispatch) {\n      let tr = histTransaction(hist, state, redo);\n      if (tr)\n        dispatch(scroll ? tr.scrollIntoView() : tr);\n    }\n    return true;\n  };\n}\nvar undo = buildCommand(false, true);\nvar redo = buildCommand(true, true);\nvar undoNoScroll = buildCommand(false, false);\nvar redoNoScroll = buildCommand(true, false);\n\n// node_modules/w3c-keyname/index.js\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n};\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: '\"'\n};\nvar mac3 = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie2 = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nfor (i = 0;i < 10; i++)\n  base[48 + i] = base[96 + i] = String(i);\nvar i;\nfor (i = 1;i <= 24; i++)\n  base[i + 111] = \"F\" + i;\nvar i;\nfor (i = 65;i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\nvar i;\nfor (code in base)\n  if (!shift.hasOwnProperty(code))\n    shift[code] = base[code];\nvar code;\nfunction keyName(event) {\n  var ignoreKey = mac3 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == \"Unidentified\";\n  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\";\n  if (name == \"Esc\")\n    name = \"Escape\";\n  if (name == \"Del\")\n    name = \"Delete\";\n  if (name == \"Left\")\n    name = \"ArrowLeft\";\n  if (name == \"Up\")\n    name = \"ArrowUp\";\n  if (name == \"Right\")\n    name = \"ArrowRight\";\n  if (name == \"Down\")\n    name = \"ArrowDown\";\n  return name;\n}\n\n// node_modules/prosemirror-keymap/dist/index.js\nvar mac4 = typeof navigator != \"undefined\" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);\nvar windows2 = typeof navigator != \"undefined\" && /Win/.test(navigator.platform);\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n  if (result == \"Space\")\n    result = \" \";\n  let alt, ctrl, shift2, meta;\n  for (let i2 = 0;i2 < parts.length - 1; i2++) {\n    let mod = parts[i2];\n    if (/^(cmd|meta|m)$/i.test(mod))\n      meta = true;\n    else if (/^a(lt)?$/i.test(mod))\n      alt = true;\n    else if (/^(c|ctrl|control)$/i.test(mod))\n      ctrl = true;\n    else if (/^s(hift)?$/i.test(mod))\n      shift2 = true;\n    else if (/^mod$/i.test(mod)) {\n      if (mac4)\n        meta = true;\n      else\n        ctrl = true;\n    } else\n      throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt)\n    result = \"Alt-\" + result;\n  if (ctrl)\n    result = \"Ctrl-\" + result;\n  if (meta)\n    result = \"Meta-\" + result;\n  if (shift2)\n    result = \"Shift-\" + result;\n  return result;\n}\nfunction normalize(map2) {\n  let copy2 = Object.create(null);\n  for (let prop in map2)\n    copy2[normalizeKeyName(prop)] = map2[prop];\n  return copy2;\n}\nfunction modifiers(name, event, shift2 = true) {\n  if (event.altKey)\n    name = \"Alt-\" + name;\n  if (event.ctrlKey)\n    name = \"Ctrl-\" + name;\n  if (event.metaKey)\n    name = \"Meta-\" + name;\n  if (shift2 && event.shiftKey)\n    name = \"Shift-\" + name;\n  return name;\n}\nfunction keymap(bindings) {\n  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\nfunction keydownHandler(bindings) {\n  let map2 = normalize(bindings);\n  return function(view, event) {\n    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];\n    if (direct && direct(view.state, view.dispatch, view))\n      return true;\n    if (name.length == 1 && name != \" \") {\n      if (event.shiftKey) {\n        let noShift = map2[modifiers(name, event, false)];\n        if (noShift && noShift(view.state, view.dispatch, view))\n          return true;\n      }\n      if ((event.altKey || event.metaKey || event.ctrlKey) && !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {\n        let fromCode = map2[modifiers(baseName, event)];\n        if (fromCode && fromCode(view.state, view.dispatch, view))\n          return true;\n      }\n    }\n    return false;\n  };\n}\n\n// content/blog/structured-search-ui-5/program.ts\nvar schema = new Schema({\n  nodes: {\n    doc: {\n      content: \"text*\"\n    },\n    text: {}\n  }\n});\nvar createEditorView = ({ mountEl }) => {\n  const view = new EditorView(mountEl, {\n    state: EditorState.create({\n      schema,\n      doc: schema.nodes.doc.create(null, schema.text(\"ta-da!\")),\n      plugins: [\n        keymap({\n          ...baseKeymap,\n          \"Mod-z\": undo,\n          \"Mod-y\": redo\n        }),\n        history()\n      ]\n    })\n  });\nconsole.log(view.state.doc);\n\n  return view;\n};\n\ndocument.querySelectorAll(\"[data-pm-input]\").forEach((el) => {\n  createEditorView({ mountEl: el });\n});\n</script>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">Naming a few: <a href=\"https://github.com/nytimes/react-prosemirror\">The New York Times</a>, the FT (I don‚Äôt have a citation, mind), <a href=\"https://yle.fi/a/7-10000522\">YLE</a>, and <a href=\"https://theguardian.engineering/blog/info-2019-jan-24-leaving-scribe\">The Guardian.</a><a href=\"#fnref-1\" class=\"footnote-backref\">‚Ü©</a></li>\n</ol>\n</div>","frontmatter":{"title":"Structured search queries for web UIs, part 5: the interface, foundations","date":"June 02, 2025","description":"In which contenteditable is dead, and also long live contenteditable"}}},"pageContext":{"slug":"/structured-search-ui-5/","previous":{"fields":{"slug":"/structured-search-ui-4/"},"frontmatter":{"title":"Structured search queries for web UIs, part 4: parsing"}},"next":{"fields":{"slug":"/structured-search-ui-6/"},"frontmatter":{"title":"Structured search queries for web UIs, part 6: the interface, features"}}}},"staticQueryHashes":["1240129568","63159454"],"slicesMap":{}}